import getWithGlobals from "../../transport/getWithGlobals";
/**
 * Polygon API
 * The future of fintech.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CryptoEMA200Response,
  CryptoMACD200Response,
  CryptoRSI200Response,
  CryptoSMA200Response,
  V2AggsTickerIndicesTickerPrevGet200Response,
} from '../models/index';
import {
    CryptoEMA200ResponseFromJSON,
    CryptoEMA200ResponseToJSON,
    CryptoMACD200ResponseFromJSON,
    CryptoMACD200ResponseToJSON,
    CryptoRSI200ResponseFromJSON,
    CryptoRSI200ResponseToJSON,
    CryptoSMA200ResponseFromJSON,
    CryptoSMA200ResponseToJSON,
    V2AggsTickerIndicesTickerPrevGet200ResponseFromJSON,
    V2AggsTickerIndicesTickerPrevGet200ResponseToJSON,
} from '../models/index';

export interface IndicesEMARequest {
    indicesTicker: string;
    timestamp?: string;
    timespan?: IndicesEMATimespanEnum;
    adjusted?: boolean;
    window?: number;
    seriesType?: IndicesEMASeriesTypeEnum;
    expandUnderlying?: boolean;
    order?: IndicesEMAOrderEnum;
    limit?: number;
    timestampGte?: string;
    timestampGt?: string;
    timestampLte?: string;
    timestampLt?: string;
}

export interface IndicesMACDRequest {
    indicesTicker: string;
    timestamp?: string;
    timespan?: IndicesMACDTimespanEnum;
    adjusted?: boolean;
    shortWindow?: number;
    longWindow?: number;
    signalWindow?: number;
    seriesType?: IndicesMACDSeriesTypeEnum;
    expandUnderlying?: boolean;
    order?: IndicesMACDOrderEnum;
    limit?: number;
    timestampGte?: string;
    timestampGt?: string;
    timestampLte?: string;
    timestampLt?: string;
}

export interface IndicesRSIRequest {
    indicesTicker: string;
    timestamp?: string;
    timespan?: IndicesRSITimespanEnum;
    adjusted?: boolean;
    window?: number;
    seriesType?: IndicesRSISeriesTypeEnum;
    expandUnderlying?: boolean;
    order?: IndicesRSIOrderEnum;
    limit?: number;
    timestampGte?: string;
    timestampGt?: string;
    timestampLte?: string;
    timestampLt?: string;
}

export interface IndicesSMARequest {
    indicesTicker: string;
    timestamp?: string;
    timespan?: IndicesSMATimespanEnum;
    adjusted?: boolean;
    window?: number;
    seriesType?: IndicesSMASeriesTypeEnum;
    expandUnderlying?: boolean;
    order?: IndicesSMAOrderEnum;
    limit?: number;
    timestampGte?: string;
    timestampGt?: string;
    timestampLte?: string;
    timestampLt?: string;
}

export interface V2AggsTickerIndicesTickerPrevGetRequest {
    indicesTicker: string;
}

export interface V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetRequest {
    indicesTicker: string;
    multiplier: number;
    timespan: V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetTimespanEnum;
    from: string;
    to: string;
    sort?: V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetSortEnum;
    limit?: number;
}

/**
 * 
 */
export class IndicesAggregatesApi extends runtime.BaseAPI {

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * Exponential Moving Average (EMA)
     */
    async indicesEMARaw(requestParameters: IndicesEMARequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CryptoEMA200Response>> {
        if (requestParameters['indicesTicker'] == null) {
            throw new runtime.RequiredError(
                'indicesTicker',
                'Required parameter "indicesTicker" was null or undefined when calling indicesEMA().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['timestamp'] != null) {
            queryParameters['timestamp'] = requestParameters['timestamp'];
        }

        if (requestParameters['timespan'] != null) {
            queryParameters['timespan'] = requestParameters['timespan'];
        }

        if (requestParameters['adjusted'] != null) {
            queryParameters['adjusted'] = requestParameters['adjusted'];
        }

        if (requestParameters['window'] != null) {
            queryParameters['window'] = requestParameters['window'];
        }

        if (requestParameters['seriesType'] != null) {
            queryParameters['series_type'] = requestParameters['seriesType'];
        }

        if (requestParameters['expandUnderlying'] != null) {
            queryParameters['expand_underlying'] = requestParameters['expandUnderlying'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['timestampGte'] != null) {
            queryParameters['timestamp.gte'] = requestParameters['timestampGte'];
        }

        if (requestParameters['timestampGt'] != null) {
            queryParameters['timestamp.gt'] = requestParameters['timestampGt'];
        }

        if (requestParameters['timestampLte'] != null) {
            queryParameters['timestamp.lte'] = requestParameters['timestampLte'];
        }

        if (requestParameters['timestampLt'] != null) {
            queryParameters['timestamp.lt'] = requestParameters['timestampLt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKey authentication
        }

        const response = await this.request({
            path: `/v1/indicators/ema/{indicesTicker}`.replace(`{${"indicesTicker"}}`, encodeURIComponent(String(requestParameters['indicesTicker']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CryptoEMA200ResponseFromJSON(jsonValue));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * Exponential Moving Average (EMA)
     */
    async indicesEMA(requestParameters: IndicesEMARequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CryptoEMA200Response> {
        const response = await this.indicesEMARaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
     * Moving Average Convergence/Divergence (MACD)
     */
    async indicesMACDRaw(requestParameters: IndicesMACDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CryptoMACD200Response>> {
        if (requestParameters['indicesTicker'] == null) {
            throw new runtime.RequiredError(
                'indicesTicker',
                'Required parameter "indicesTicker" was null or undefined when calling indicesMACD().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['timestamp'] != null) {
            queryParameters['timestamp'] = requestParameters['timestamp'];
        }

        if (requestParameters['timespan'] != null) {
            queryParameters['timespan'] = requestParameters['timespan'];
        }

        if (requestParameters['adjusted'] != null) {
            queryParameters['adjusted'] = requestParameters['adjusted'];
        }

        if (requestParameters['shortWindow'] != null) {
            queryParameters['short_window'] = requestParameters['shortWindow'];
        }

        if (requestParameters['longWindow'] != null) {
            queryParameters['long_window'] = requestParameters['longWindow'];
        }

        if (requestParameters['signalWindow'] != null) {
            queryParameters['signal_window'] = requestParameters['signalWindow'];
        }

        if (requestParameters['seriesType'] != null) {
            queryParameters['series_type'] = requestParameters['seriesType'];
        }

        if (requestParameters['expandUnderlying'] != null) {
            queryParameters['expand_underlying'] = requestParameters['expandUnderlying'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['timestampGte'] != null) {
            queryParameters['timestamp.gte'] = requestParameters['timestampGte'];
        }

        if (requestParameters['timestampGt'] != null) {
            queryParameters['timestamp.gt'] = requestParameters['timestampGt'];
        }

        if (requestParameters['timestampLte'] != null) {
            queryParameters['timestamp.lte'] = requestParameters['timestampLte'];
        }

        if (requestParameters['timestampLt'] != null) {
            queryParameters['timestamp.lt'] = requestParameters['timestampLt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKey authentication
        }

        const response = await this.request({
            path: `/v1/indicators/macd/{indicesTicker}`.replace(`{${"indicesTicker"}}`, encodeURIComponent(String(requestParameters['indicesTicker']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CryptoMACD200ResponseFromJSON(jsonValue));
    }

    /**
     * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
     * Moving Average Convergence/Divergence (MACD)
     */
    async indicesMACD(requestParameters: IndicesMACDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CryptoMACD200Response> {
        const response = await this.indicesMACDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * Relative Strength Index (RSI)
     */
    async indicesRSIRaw(requestParameters: IndicesRSIRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CryptoRSI200Response>> {
        if (requestParameters['indicesTicker'] == null) {
            throw new runtime.RequiredError(
                'indicesTicker',
                'Required parameter "indicesTicker" was null or undefined when calling indicesRSI().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['timestamp'] != null) {
            queryParameters['timestamp'] = requestParameters['timestamp'];
        }

        if (requestParameters['timespan'] != null) {
            queryParameters['timespan'] = requestParameters['timespan'];
        }

        if (requestParameters['adjusted'] != null) {
            queryParameters['adjusted'] = requestParameters['adjusted'];
        }

        if (requestParameters['window'] != null) {
            queryParameters['window'] = requestParameters['window'];
        }

        if (requestParameters['seriesType'] != null) {
            queryParameters['series_type'] = requestParameters['seriesType'];
        }

        if (requestParameters['expandUnderlying'] != null) {
            queryParameters['expand_underlying'] = requestParameters['expandUnderlying'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['timestampGte'] != null) {
            queryParameters['timestamp.gte'] = requestParameters['timestampGte'];
        }

        if (requestParameters['timestampGt'] != null) {
            queryParameters['timestamp.gt'] = requestParameters['timestampGt'];
        }

        if (requestParameters['timestampLte'] != null) {
            queryParameters['timestamp.lte'] = requestParameters['timestampLte'];
        }

        if (requestParameters['timestampLt'] != null) {
            queryParameters['timestamp.lt'] = requestParameters['timestampLt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKey authentication
        }

        const response = await this.request({
            path: `/v1/indicators/rsi/{indicesTicker}`.replace(`{${"indicesTicker"}}`, encodeURIComponent(String(requestParameters['indicesTicker']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CryptoRSI200ResponseFromJSON(jsonValue));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * Relative Strength Index (RSI)
     */
    async indicesRSI(requestParameters: IndicesRSIRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CryptoRSI200Response> {
        const response = await this.indicesRSIRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * Simple Moving Average (SMA)
     */
    async indicesSMARaw(requestParameters: IndicesSMARequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CryptoSMA200Response>> {
        if (requestParameters['indicesTicker'] == null) {
            throw new runtime.RequiredError(
                'indicesTicker',
                'Required parameter "indicesTicker" was null or undefined when calling indicesSMA().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['timestamp'] != null) {
            queryParameters['timestamp'] = requestParameters['timestamp'];
        }

        if (requestParameters['timespan'] != null) {
            queryParameters['timespan'] = requestParameters['timespan'];
        }

        if (requestParameters['adjusted'] != null) {
            queryParameters['adjusted'] = requestParameters['adjusted'];
        }

        if (requestParameters['window'] != null) {
            queryParameters['window'] = requestParameters['window'];
        }

        if (requestParameters['seriesType'] != null) {
            queryParameters['series_type'] = requestParameters['seriesType'];
        }

        if (requestParameters['expandUnderlying'] != null) {
            queryParameters['expand_underlying'] = requestParameters['expandUnderlying'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['timestampGte'] != null) {
            queryParameters['timestamp.gte'] = requestParameters['timestampGte'];
        }

        if (requestParameters['timestampGt'] != null) {
            queryParameters['timestamp.gt'] = requestParameters['timestampGt'];
        }

        if (requestParameters['timestampLte'] != null) {
            queryParameters['timestamp.lte'] = requestParameters['timestampLte'];
        }

        if (requestParameters['timestampLt'] != null) {
            queryParameters['timestamp.lt'] = requestParameters['timestampLt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKey authentication
        }

        const response = await this.request({
            path: `/v1/indicators/sma/{indicesTicker}`.replace(`{${"indicesTicker"}}`, encodeURIComponent(String(requestParameters['indicesTicker']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CryptoSMA200ResponseFromJSON(jsonValue));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * Simple Moving Average (SMA)
     */
    async indicesSMA(requestParameters: IndicesSMARequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CryptoSMA200Response> {
        const response = await this.indicesSMARaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified index. 
     * Previous Close
     */
    async v2AggsTickerIndicesTickerPrevGetRaw(requestParameters: V2AggsTickerIndicesTickerPrevGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V2AggsTickerIndicesTickerPrevGet200Response>> {
        if (requestParameters['indicesTicker'] == null) {
            throw new runtime.RequiredError(
                'indicesTicker',
                'Required parameter "indicesTicker" was null or undefined when calling v2AggsTickerIndicesTickerPrevGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKey authentication
        }

        const response = await this.request({
            path: `/v2/aggs/ticker/{indicesTicker}/prev`.replace(`{${"indicesTicker"}}`, encodeURIComponent(String(requestParameters['indicesTicker']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V2AggsTickerIndicesTickerPrevGet200ResponseFromJSON(jsonValue));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified index. 
     * Previous Close
     */
    async v2AggsTickerIndicesTickerPrevGet(requestParameters: V2AggsTickerIndicesTickerPrevGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V2AggsTickerIndicesTickerPrevGet200Response> {
        const response = await this.v2AggsTickerIndicesTickerPrevGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get aggregate bars for an index over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = ‘minute’ and multiplier = ‘5’ then 5-minute bars will be returned. 
     * Aggregates (Bars)
     */
    async v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetRaw(requestParameters: V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V2AggsTickerIndicesTickerPrevGet200Response>> {
        if (requestParameters['indicesTicker'] == null) {
            throw new runtime.RequiredError(
                'indicesTicker',
                'Required parameter "indicesTicker" was null or undefined when calling v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet().'
            );
        }

        if (requestParameters['multiplier'] == null) {
            throw new runtime.RequiredError(
                'multiplier',
                'Required parameter "multiplier" was null or undefined when calling v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet().'
            );
        }

        if (requestParameters['timespan'] == null) {
            throw new runtime.RequiredError(
                'timespan',
                'Required parameter "timespan" was null or undefined when calling v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet().'
            );
        }

        if (requestParameters['from'] == null) {
            throw new runtime.RequiredError(
                'from',
                'Required parameter "from" was null or undefined when calling v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet().'
            );
        }

        if (requestParameters['to'] == null) {
            throw new runtime.RequiredError(
                'to',
                'Required parameter "to" was null or undefined when calling v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKey authentication
        }

        const response = await this.request({
            path: `/v2/aggs/ticker/{indicesTicker}/range/{multiplier}/{timespan}/{from}/{to}`.replace(`{${"indicesTicker"}}`, encodeURIComponent(String(requestParameters['indicesTicker']))).replace(`{${"multiplier"}}`, encodeURIComponent(String(requestParameters['multiplier']))).replace(`{${"timespan"}}`, encodeURIComponent(String(requestParameters['timespan']))).replace(`{${"from"}}`, encodeURIComponent(String(requestParameters['from']))).replace(`{${"to"}}`, encodeURIComponent(String(requestParameters['to']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V2AggsTickerIndicesTickerPrevGet200ResponseFromJSON(jsonValue));
    }

    /**
     * Get aggregate bars for an index over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = ‘minute’ and multiplier = ‘5’ then 5-minute bars will be returned. 
     * Aggregates (Bars)
     */
    async v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGet(requestParameters: V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V2AggsTickerIndicesTickerPrevGet200Response> {
        const response = await this.v2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const IndicesEMATimespanEnum = {
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Quarter: 'quarter',
    Year: 'year'
} as const;
export type IndicesEMATimespanEnum = typeof IndicesEMATimespanEnum[keyof typeof IndicesEMATimespanEnum];
/**
 * @export
 */
export const IndicesEMASeriesTypeEnum = {
    Open: 'open',
    High: 'high',
    Low: 'low',
    Close: 'close'
} as const;
export type IndicesEMASeriesTypeEnum = typeof IndicesEMASeriesTypeEnum[keyof typeof IndicesEMASeriesTypeEnum];
/**
 * @export
 */
export const IndicesEMAOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type IndicesEMAOrderEnum = typeof IndicesEMAOrderEnum[keyof typeof IndicesEMAOrderEnum];
/**
 * @export
 */
export const IndicesMACDTimespanEnum = {
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Quarter: 'quarter',
    Year: 'year'
} as const;
export type IndicesMACDTimespanEnum = typeof IndicesMACDTimespanEnum[keyof typeof IndicesMACDTimespanEnum];
/**
 * @export
 */
export const IndicesMACDSeriesTypeEnum = {
    Open: 'open',
    High: 'high',
    Low: 'low',
    Close: 'close'
} as const;
export type IndicesMACDSeriesTypeEnum = typeof IndicesMACDSeriesTypeEnum[keyof typeof IndicesMACDSeriesTypeEnum];
/**
 * @export
 */
export const IndicesMACDOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type IndicesMACDOrderEnum = typeof IndicesMACDOrderEnum[keyof typeof IndicesMACDOrderEnum];
/**
 * @export
 */
export const IndicesRSITimespanEnum = {
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Quarter: 'quarter',
    Year: 'year'
} as const;
export type IndicesRSITimespanEnum = typeof IndicesRSITimespanEnum[keyof typeof IndicesRSITimespanEnum];
/**
 * @export
 */
export const IndicesRSISeriesTypeEnum = {
    Open: 'open',
    High: 'high',
    Low: 'low',
    Close: 'close'
} as const;
export type IndicesRSISeriesTypeEnum = typeof IndicesRSISeriesTypeEnum[keyof typeof IndicesRSISeriesTypeEnum];
/**
 * @export
 */
export const IndicesRSIOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type IndicesRSIOrderEnum = typeof IndicesRSIOrderEnum[keyof typeof IndicesRSIOrderEnum];
/**
 * @export
 */
export const IndicesSMATimespanEnum = {
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Quarter: 'quarter',
    Year: 'year'
} as const;
export type IndicesSMATimespanEnum = typeof IndicesSMATimespanEnum[keyof typeof IndicesSMATimespanEnum];
/**
 * @export
 */
export const IndicesSMASeriesTypeEnum = {
    Open: 'open',
    High: 'high',
    Low: 'low',
    Close: 'close'
} as const;
export type IndicesSMASeriesTypeEnum = typeof IndicesSMASeriesTypeEnum[keyof typeof IndicesSMASeriesTypeEnum];
/**
 * @export
 */
export const IndicesSMAOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type IndicesSMAOrderEnum = typeof IndicesSMAOrderEnum[keyof typeof IndicesSMAOrderEnum];
/**
 * @export
 */
export const V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetTimespanEnum = {
    Second: 'second',
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Quarter: 'quarter',
    Year: 'year'
} as const;
export type V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetTimespanEnum = typeof V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetTimespanEnum[keyof typeof V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetTimespanEnum];
/**
 * @export
 */
export const V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetSortEnum = typeof V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetSortEnum[keyof typeof V2AggsTickerIndicesTickerRangeMultiplierTimespanFromToGetSortEnum];
