import getWithGlobals from "../../transport/getWithGlobals";
/**
 * Polygon API
 * The future of fintech.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CryptoEMA200Response,
  CryptoMACD200Response,
  CryptoRSI200Response,
  CryptoSMA200Response,
  V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response,
  V2AggsTickerCryptoTickerPrevGet200Response,
  V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response,
} from '../models/index';
import {
    CryptoEMA200ResponseFromJSON,
    CryptoEMA200ResponseToJSON,
    CryptoMACD200ResponseFromJSON,
    CryptoMACD200ResponseToJSON,
    CryptoRSI200ResponseFromJSON,
    CryptoRSI200ResponseToJSON,
    CryptoSMA200ResponseFromJSON,
    CryptoSMA200ResponseToJSON,
    V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseFromJSON,
    V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseToJSON,
    V2AggsTickerCryptoTickerPrevGet200ResponseFromJSON,
    V2AggsTickerCryptoTickerPrevGet200ResponseToJSON,
    V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseFromJSON,
    V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseToJSON,
} from '../models/index';

export interface CryptoEMARequest {
    cryptoTicker: string;
    timestamp?: string;
    timespan?: CryptoEMATimespanEnum;
    window?: number;
    seriesType?: CryptoEMASeriesTypeEnum;
    expandUnderlying?: boolean;
    order?: CryptoEMAOrderEnum;
    limit?: number;
    timestampGte?: string;
    timestampGt?: string;
    timestampLte?: string;
    timestampLt?: string;
}

export interface CryptoMACDRequest {
    cryptoTicker: string;
    timestamp?: string;
    timespan?: CryptoMACDTimespanEnum;
    shortWindow?: number;
    longWindow?: number;
    signalWindow?: number;
    seriesType?: CryptoMACDSeriesTypeEnum;
    expandUnderlying?: boolean;
    order?: CryptoMACDOrderEnum;
    limit?: number;
    timestampGte?: string;
    timestampGt?: string;
    timestampLte?: string;
    timestampLt?: string;
}

export interface CryptoRSIRequest {
    cryptoTicker: string;
    timestamp?: string;
    timespan?: CryptoRSITimespanEnum;
    window?: number;
    seriesType?: CryptoRSISeriesTypeEnum;
    expandUnderlying?: boolean;
    order?: CryptoRSIOrderEnum;
    limit?: number;
    timestampGte?: string;
    timestampGt?: string;
    timestampLte?: string;
    timestampLt?: string;
}

export interface CryptoSMARequest {
    cryptoTicker: string;
    timestamp?: string;
    timespan?: CryptoSMATimespanEnum;
    window?: number;
    seriesType?: CryptoSMASeriesTypeEnum;
    expandUnderlying?: boolean;
    order?: CryptoSMAOrderEnum;
    limit?: number;
    timestampGte?: string;
    timestampGt?: string;
    timestampLte?: string;
    timestampLt?: string;
}

export interface V2AggsGroupedLocaleGlobalMarketCryptoDateGetRequest {
    date: string;
    adjusted?: boolean;
}

export interface V2AggsTickerCryptoTickerPrevGetRequest {
    cryptoTicker: string;
    adjusted?: boolean;
}

export interface V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetRequest {
    cryptoTicker: string;
    multiplier: number;
    timespan: V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetTimespanEnum;
    from: string;
    to: string;
    adjusted?: boolean;
    sort?: V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetSortEnum;
    limit?: number;
}

/**
 * 
 */
export class CryptoAggregatesApi extends runtime.BaseAPI {

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * Exponential Moving Average (EMA)
     */
    async cryptoEMARaw(requestParameters: CryptoEMARequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CryptoEMA200Response>> {
        if (requestParameters['cryptoTicker'] == null) {
            throw new runtime.RequiredError(
                'cryptoTicker',
                'Required parameter "cryptoTicker" was null or undefined when calling cryptoEMA().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['timestamp'] != null) {
            queryParameters['timestamp'] = requestParameters['timestamp'];
        }

        if (requestParameters['timespan'] != null) {
            queryParameters['timespan'] = requestParameters['timespan'];
        }

        if (requestParameters['window'] != null) {
            queryParameters['window'] = requestParameters['window'];
        }

        if (requestParameters['seriesType'] != null) {
            queryParameters['series_type'] = requestParameters['seriesType'];
        }

        if (requestParameters['expandUnderlying'] != null) {
            queryParameters['expand_underlying'] = requestParameters['expandUnderlying'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['timestampGte'] != null) {
            queryParameters['timestamp.gte'] = requestParameters['timestampGte'];
        }

        if (requestParameters['timestampGt'] != null) {
            queryParameters['timestamp.gt'] = requestParameters['timestampGt'];
        }

        if (requestParameters['timestampLte'] != null) {
            queryParameters['timestamp.lte'] = requestParameters['timestampLte'];
        }

        if (requestParameters['timestampLt'] != null) {
            queryParameters['timestamp.lt'] = requestParameters['timestampLt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKey authentication
        }

        const response = await this.request({
            path: `/v1/indicators/ema/{cryptoTicker}`.replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(requestParameters['cryptoTicker']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CryptoEMA200ResponseFromJSON(jsonValue));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * Exponential Moving Average (EMA)
     */
    async cryptoEMA(requestParameters: CryptoEMARequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CryptoEMA200Response> {
        const response = await this.cryptoEMARaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * Moving Average Convergence/Divergence (MACD)
     */
    async cryptoMACDRaw(requestParameters: CryptoMACDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CryptoMACD200Response>> {
        if (requestParameters['cryptoTicker'] == null) {
            throw new runtime.RequiredError(
                'cryptoTicker',
                'Required parameter "cryptoTicker" was null or undefined when calling cryptoMACD().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['timestamp'] != null) {
            queryParameters['timestamp'] = requestParameters['timestamp'];
        }

        if (requestParameters['timespan'] != null) {
            queryParameters['timespan'] = requestParameters['timespan'];
        }

        if (requestParameters['shortWindow'] != null) {
            queryParameters['short_window'] = requestParameters['shortWindow'];
        }

        if (requestParameters['longWindow'] != null) {
            queryParameters['long_window'] = requestParameters['longWindow'];
        }

        if (requestParameters['signalWindow'] != null) {
            queryParameters['signal_window'] = requestParameters['signalWindow'];
        }

        if (requestParameters['seriesType'] != null) {
            queryParameters['series_type'] = requestParameters['seriesType'];
        }

        if (requestParameters['expandUnderlying'] != null) {
            queryParameters['expand_underlying'] = requestParameters['expandUnderlying'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['timestampGte'] != null) {
            queryParameters['timestamp.gte'] = requestParameters['timestampGte'];
        }

        if (requestParameters['timestampGt'] != null) {
            queryParameters['timestamp.gt'] = requestParameters['timestampGt'];
        }

        if (requestParameters['timestampLte'] != null) {
            queryParameters['timestamp.lte'] = requestParameters['timestampLte'];
        }

        if (requestParameters['timestampLt'] != null) {
            queryParameters['timestamp.lt'] = requestParameters['timestampLt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKey authentication
        }

        const response = await this.request({
            path: `/v1/indicators/macd/{cryptoTicker}`.replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(requestParameters['cryptoTicker']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CryptoMACD200ResponseFromJSON(jsonValue));
    }

    /**
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * Moving Average Convergence/Divergence (MACD)
     */
    async cryptoMACD(requestParameters: CryptoMACDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CryptoMACD200Response> {
        const response = await this.cryptoMACDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * Relative Strength Index (RSI)
     */
    async cryptoRSIRaw(requestParameters: CryptoRSIRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CryptoRSI200Response>> {
        if (requestParameters['cryptoTicker'] == null) {
            throw new runtime.RequiredError(
                'cryptoTicker',
                'Required parameter "cryptoTicker" was null or undefined when calling cryptoRSI().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['timestamp'] != null) {
            queryParameters['timestamp'] = requestParameters['timestamp'];
        }

        if (requestParameters['timespan'] != null) {
            queryParameters['timespan'] = requestParameters['timespan'];
        }

        if (requestParameters['window'] != null) {
            queryParameters['window'] = requestParameters['window'];
        }

        if (requestParameters['seriesType'] != null) {
            queryParameters['series_type'] = requestParameters['seriesType'];
        }

        if (requestParameters['expandUnderlying'] != null) {
            queryParameters['expand_underlying'] = requestParameters['expandUnderlying'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['timestampGte'] != null) {
            queryParameters['timestamp.gte'] = requestParameters['timestampGte'];
        }

        if (requestParameters['timestampGt'] != null) {
            queryParameters['timestamp.gt'] = requestParameters['timestampGt'];
        }

        if (requestParameters['timestampLte'] != null) {
            queryParameters['timestamp.lte'] = requestParameters['timestampLte'];
        }

        if (requestParameters['timestampLt'] != null) {
            queryParameters['timestamp.lt'] = requestParameters['timestampLt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKey authentication
        }

        const response = await this.request({
            path: `/v1/indicators/rsi/{cryptoTicker}`.replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(requestParameters['cryptoTicker']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CryptoRSI200ResponseFromJSON(jsonValue));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * Relative Strength Index (RSI)
     */
    async cryptoRSI(requestParameters: CryptoRSIRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CryptoRSI200Response> {
        const response = await this.cryptoRSIRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * Simple Moving Average (SMA)
     */
    async cryptoSMARaw(requestParameters: CryptoSMARequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CryptoSMA200Response>> {
        if (requestParameters['cryptoTicker'] == null) {
            throw new runtime.RequiredError(
                'cryptoTicker',
                'Required parameter "cryptoTicker" was null or undefined when calling cryptoSMA().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['timestamp'] != null) {
            queryParameters['timestamp'] = requestParameters['timestamp'];
        }

        if (requestParameters['timespan'] != null) {
            queryParameters['timespan'] = requestParameters['timespan'];
        }

        if (requestParameters['window'] != null) {
            queryParameters['window'] = requestParameters['window'];
        }

        if (requestParameters['seriesType'] != null) {
            queryParameters['series_type'] = requestParameters['seriesType'];
        }

        if (requestParameters['expandUnderlying'] != null) {
            queryParameters['expand_underlying'] = requestParameters['expandUnderlying'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['timestampGte'] != null) {
            queryParameters['timestamp.gte'] = requestParameters['timestampGte'];
        }

        if (requestParameters['timestampGt'] != null) {
            queryParameters['timestamp.gt'] = requestParameters['timestampGt'];
        }

        if (requestParameters['timestampLte'] != null) {
            queryParameters['timestamp.lte'] = requestParameters['timestampLte'];
        }

        if (requestParameters['timestampLt'] != null) {
            queryParameters['timestamp.lt'] = requestParameters['timestampLt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKey authentication
        }

        const response = await this.request({
            path: `/v1/indicators/sma/{cryptoTicker}`.replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(requestParameters['cryptoTicker']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CryptoSMA200ResponseFromJSON(jsonValue));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * Simple Moving Average (SMA)
     */
    async cryptoSMA(requestParameters: CryptoSMARequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CryptoSMA200Response> {
        const response = await this.cryptoSMARaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
     * Grouped Daily (Bars)
     */
    async v2AggsGroupedLocaleGlobalMarketCryptoDateGetRaw(requestParameters: V2AggsGroupedLocaleGlobalMarketCryptoDateGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response>> {
        if (requestParameters['date'] == null) {
            throw new runtime.RequiredError(
                'date',
                'Required parameter "date" was null or undefined when calling v2AggsGroupedLocaleGlobalMarketCryptoDateGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['adjusted'] != null) {
            queryParameters['adjusted'] = requestParameters['adjusted'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKey authentication
        }

        const response = await this.request({
            path: `/v2/aggs/grouped/locale/global/market/crypto/{date}`.replace(`{${"date"}}`, encodeURIComponent(String(requestParameters['date']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V2AggsGroupedLocaleGlobalMarketCryptoDateGet200ResponseFromJSON(jsonValue));
    }

    /**
     * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
     * Grouped Daily (Bars)
     */
    async v2AggsGroupedLocaleGlobalMarketCryptoDateGet(requestParameters: V2AggsGroupedLocaleGlobalMarketCryptoDateGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V2AggsGroupedLocaleGlobalMarketCryptoDateGet200Response> {
        const response = await this.v2AggsGroupedLocaleGlobalMarketCryptoDateGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
     * Previous Close
     */
    async v2AggsTickerCryptoTickerPrevGetRaw(requestParameters: V2AggsTickerCryptoTickerPrevGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V2AggsTickerCryptoTickerPrevGet200Response>> {
        if (requestParameters['cryptoTicker'] == null) {
            throw new runtime.RequiredError(
                'cryptoTicker',
                'Required parameter "cryptoTicker" was null or undefined when calling v2AggsTickerCryptoTickerPrevGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['adjusted'] != null) {
            queryParameters['adjusted'] = requestParameters['adjusted'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKey authentication
        }

        const response = await this.request({
            path: `/v2/aggs/ticker/{cryptoTicker}/prev`.replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(requestParameters['cryptoTicker']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V2AggsTickerCryptoTickerPrevGet200ResponseFromJSON(jsonValue));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
     * Previous Close
     */
    async v2AggsTickerCryptoTickerPrevGet(requestParameters: V2AggsTickerCryptoTickerPrevGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V2AggsTickerCryptoTickerPrevGet200Response> {
        const response = await this.v2AggsTickerCryptoTickerPrevGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = ‘minute’ and multiplier = ‘5’ then 5-minute bars will be returned. 
     * Aggregates (Bars)
     */
    async v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetRaw(requestParameters: V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response>> {
        if (requestParameters['cryptoTicker'] == null) {
            throw new runtime.RequiredError(
                'cryptoTicker',
                'Required parameter "cryptoTicker" was null or undefined when calling v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet().'
            );
        }

        if (requestParameters['multiplier'] == null) {
            throw new runtime.RequiredError(
                'multiplier',
                'Required parameter "multiplier" was null or undefined when calling v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet().'
            );
        }

        if (requestParameters['timespan'] == null) {
            throw new runtime.RequiredError(
                'timespan',
                'Required parameter "timespan" was null or undefined when calling v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet().'
            );
        }

        if (requestParameters['from'] == null) {
            throw new runtime.RequiredError(
                'from',
                'Required parameter "from" was null or undefined when calling v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet().'
            );
        }

        if (requestParameters['to'] == null) {
            throw new runtime.RequiredError(
                'to',
                'Required parameter "to" was null or undefined when calling v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['adjusted'] != null) {
            queryParameters['adjusted'] = requestParameters['adjusted'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKey authentication
        }

        const response = await this.request({
            path: `/v2/aggs/ticker/{cryptoTicker}/range/{multiplier}/{timespan}/{from}/{to}`.replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(requestParameters['cryptoTicker']))).replace(`{${"multiplier"}}`, encodeURIComponent(String(requestParameters['multiplier']))).replace(`{${"timespan"}}`, encodeURIComponent(String(requestParameters['timespan']))).replace(`{${"from"}}`, encodeURIComponent(String(requestParameters['from']))).replace(`{${"to"}}`, encodeURIComponent(String(requestParameters['to']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200ResponseFromJSON(jsonValue));
    }

    /**
     * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = ‘minute’ and multiplier = ‘5’ then 5-minute bars will be returned. 
     * Aggregates (Bars)
     */
    async v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet(requestParameters: V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGet200Response> {
        const response = await this.v2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CryptoEMATimespanEnum = {
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Quarter: 'quarter',
    Year: 'year'
} as const;
export type CryptoEMATimespanEnum = typeof CryptoEMATimespanEnum[keyof typeof CryptoEMATimespanEnum];
/**
 * @export
 */
export const CryptoEMASeriesTypeEnum = {
    Open: 'open',
    High: 'high',
    Low: 'low',
    Close: 'close'
} as const;
export type CryptoEMASeriesTypeEnum = typeof CryptoEMASeriesTypeEnum[keyof typeof CryptoEMASeriesTypeEnum];
/**
 * @export
 */
export const CryptoEMAOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type CryptoEMAOrderEnum = typeof CryptoEMAOrderEnum[keyof typeof CryptoEMAOrderEnum];
/**
 * @export
 */
export const CryptoMACDTimespanEnum = {
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Quarter: 'quarter',
    Year: 'year'
} as const;
export type CryptoMACDTimespanEnum = typeof CryptoMACDTimespanEnum[keyof typeof CryptoMACDTimespanEnum];
/**
 * @export
 */
export const CryptoMACDSeriesTypeEnum = {
    Open: 'open',
    High: 'high',
    Low: 'low',
    Close: 'close'
} as const;
export type CryptoMACDSeriesTypeEnum = typeof CryptoMACDSeriesTypeEnum[keyof typeof CryptoMACDSeriesTypeEnum];
/**
 * @export
 */
export const CryptoMACDOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type CryptoMACDOrderEnum = typeof CryptoMACDOrderEnum[keyof typeof CryptoMACDOrderEnum];
/**
 * @export
 */
export const CryptoRSITimespanEnum = {
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Quarter: 'quarter',
    Year: 'year'
} as const;
export type CryptoRSITimespanEnum = typeof CryptoRSITimespanEnum[keyof typeof CryptoRSITimespanEnum];
/**
 * @export
 */
export const CryptoRSISeriesTypeEnum = {
    Open: 'open',
    High: 'high',
    Low: 'low',
    Close: 'close'
} as const;
export type CryptoRSISeriesTypeEnum = typeof CryptoRSISeriesTypeEnum[keyof typeof CryptoRSISeriesTypeEnum];
/**
 * @export
 */
export const CryptoRSIOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type CryptoRSIOrderEnum = typeof CryptoRSIOrderEnum[keyof typeof CryptoRSIOrderEnum];
/**
 * @export
 */
export const CryptoSMATimespanEnum = {
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Quarter: 'quarter',
    Year: 'year'
} as const;
export type CryptoSMATimespanEnum = typeof CryptoSMATimespanEnum[keyof typeof CryptoSMATimespanEnum];
/**
 * @export
 */
export const CryptoSMASeriesTypeEnum = {
    Open: 'open',
    High: 'high',
    Low: 'low',
    Close: 'close'
} as const;
export type CryptoSMASeriesTypeEnum = typeof CryptoSMASeriesTypeEnum[keyof typeof CryptoSMASeriesTypeEnum];
/**
 * @export
 */
export const CryptoSMAOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type CryptoSMAOrderEnum = typeof CryptoSMAOrderEnum[keyof typeof CryptoSMAOrderEnum];
/**
 * @export
 */
export const V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetTimespanEnum = {
    Second: 'second',
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Quarter: 'quarter',
    Year: 'year'
} as const;
export type V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetTimespanEnum = typeof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetTimespanEnum[keyof typeof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetTimespanEnum];
/**
 * @export
 */
export const V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetSortEnum = typeof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetSortEnum[keyof typeof V2AggsTickerCryptoTickerRangeMultiplierTimespanFromToGetSortEnum];
