/* tslint:disable */
/* eslint-disable */
/**
 * Polygon API
 * The future of fintech.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Company
 */
export interface Company {
    /**
     * Indicates if the security is actively listed.  If false, this means the company is no longer listed and cannot be traded.
     * @type {boolean}
     * @memberof Company
     */
    'active'?: boolean;
    /**
     * The Bloomberg guid for the symbol.
     * @type {string}
     * @memberof Company
     */
    'bloomberg'?: string;
    /**
     * The name of the company\'s current CEO.
     * @type {string}
     * @memberof Company
     */
    'ceo'?: string;
    /**
     * The official CIK guid used for SEC database/filings.
     * @type {string}
     * @memberof Company
     */
    'cik'?: string;
    /**
     * The country in which the company is registered.
     * @type {string}
     * @memberof Company
     */
    'country'?: string;
    /**
     * A description of the company and what they do/offer.
     * @type {string}
     * @memberof Company
     */
    'description'?: string;
    /**
     * The approximate number of employees for the company.
     * @type {number}
     * @memberof Company
     */
    'employees'?: number;
    /**
     * The symbol\'s primary exchange.
     * @type {string}
     * @memberof Company
     */
    'exchange'?: string;
    /**
     * The exchange code (id) of the symbol\'s primary exchange.
     * @type {string}
     * @memberof Company
     */
    'exchangeSymbol'?: string;
    /**
     * The OpenFigi project guid for the symbol. (<a rel=\"nofollow\" target=\"_blank\" href=\"https://openfigi.com/\">https://openfigi.com/</a>)
     * @type {string}
     * @memberof Company
     */
    'figi'?: string;
    /**
     * The street address for the company\'s headquarters.
     * @type {string}
     * @memberof Company
     */
    'hq_address'?: string;
    /**
     * The country in which the company\'s headquarters is located.
     * @type {string}
     * @memberof Company
     */
    'hq_country'?: string;
    /**
     * The state in which the company\'s headquarters is located.
     * @type {string}
     * @memberof Company
     */
    'hq_state'?: string;
    /**
     * The industry in which the company operates.
     * @type {string}
     * @memberof Company
     */
    'industry'?: string;
    /**
     * The Legal Entity Identifier (LEI) guid for the symbol. (<a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Legal_Entity_Identifier\">https://en.wikipedia.org/wiki/Legal_Entity_Identifier</a>)
     * @type {string}
     * @memberof Company
     */
    'lei'?: string;
    /**
     * The date that the symbol was listed on the exchange.
     * @type {string}
     * @memberof Company
     */
    'listdate'?: string;
    /**
     * The URL of the entity\'s logo.
     * @type {string}
     * @memberof Company
     */
    'logo'?: string;
    /**
     * The current market cap for the company.
     * @type {number}
     * @memberof Company
     */
    'marketcap'?: number;
    /**
     * The name of the company/entity.
     * @type {string}
     * @memberof Company
     */
    'name'?: string;
    /**
     * The phone number for the company. This is usually a corporate contact number.
     * @type {string}
     * @memberof Company
     */
    'phone'?: string;
    /**
     * The sector of the indsutry in which the symbol operates.
     * @type {string}
     * @memberof Company
     */
    'sector'?: string;
    /**
     * Standard Industrial Classification (SIC) id for the symbol. (<a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Standard_Industrial_Classification\">https://en.wikipedia.org/wiki/Legal_Entity_Identifier</a>)
     * @type {number}
     * @memberof Company
     */
    'sic'?: number;
    /**
     * A list of ticker symbols for similar companies.
     * @type {Array<string>}
     * @memberof Company
     */
    'similar'?: Array<string>;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof Company
     */
    'symbol'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Company
     */
    'tags'?: Array<string>;
    /**
     * The type or class of the security.  (<a alt=\"Full List of Ticker Types\" href=\"https://massive.com/docs/rest/stocks/tickers/ticker-types\">Full List of Ticker Types</a>)
     * @type {string}
     * @memberof Company
     */
    'type'?: string;
    /**
     * The last time this company record was updated.
     * @type {string}
     * @memberof Company
     */
    'updated'?: string;
    /**
     * The URL of the company\'s website
     * @type {string}
     * @memberof Company
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ConditionTypeMap
 */
export interface ConditionTypeMap {
    /**
     * Massive.com\'s mapping for condition codes.  For more information, see our <a href=\"https://massive.com/glossary/trade-conditions\" alt=\"Trade Conditions Glossary\" target=\"_blank\">Trade Conditions Glossary</a>. 
     * @type {string}
     * @memberof ConditionTypeMap
     */
    'condition'?: string;
}
/**
 * 
 * @export
 * @interface CryptoExchangeInner
 */
export interface CryptoExchangeInner {
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof CryptoExchangeInner
     */
    'id': number;
    /**
     * Market data type this exchange contains ( crypto only currently )
     * @type {string}
     * @memberof CryptoExchangeInner
     */
    'market': string;
    /**
     * Name of the exchange
     * @type {string}
     * @memberof CryptoExchangeInner
     */
    'name': string;
    /**
     * Type of exchange feed
     * @type {string}
     * @memberof CryptoExchangeInner
     */
    'type': string;
    /**
     * URL of this exchange
     * @type {string}
     * @memberof CryptoExchangeInner
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface CryptoGroupedResults
 */
export interface CryptoGroupedResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>}
     * @memberof CryptoGroupedResults
     */
    'results'?: Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface CryptoHistoricTrades
 */
export interface CryptoHistoricTrades {
    /**
     * The date that was evaluated from the request.
     * @type {string}
     * @memberof CryptoHistoricTrades
     */
    'day': string;
    /**
     * A map for shortened result keys.
     * @type {object}
     * @memberof CryptoHistoricTrades
     */
    'map': object;
    /**
     * The milliseconds of latency for the query results.
     * @type {number}
     * @memberof CryptoHistoricTrades
     */
    'msLatency': number;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof CryptoHistoricTrades
     */
    'symbol': string;
    /**
     * 
     * @type {Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>}
     * @memberof CryptoHistoricTrades
     */
    'ticks': Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>;
}
/**
 * 
 * @export
 * @interface CryptoLastTrade
 */
export interface CryptoLastTrade {
    /**
     * 
     * @type {CryptoLastTradeLast}
     * @memberof CryptoLastTrade
     */
    'last'?: CryptoLastTradeLast;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof CryptoLastTrade
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface CryptoLastTradeLast
 */
export interface CryptoLastTradeLast {
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof CryptoLastTradeLast
     */
    'conditions': Array<number>;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://massive.com/docs/rest/crypto/market-operations/exchanges\">Exchanges</a> for a mapping of exchanges to IDs. 
     * @type {number}
     * @memberof CryptoLastTradeLast
     */
    'exchange': number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof CryptoLastTradeLast
     */
    'price': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof CryptoLastTradeLast
     */
    'size': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof CryptoLastTradeLast
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface CryptoOpenClose
 */
export interface CryptoOpenClose {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoOpenClose
     */
    'close': number;
    /**
     * An array of results containing the requested data.
     * @type {Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>}
     * @memberof CryptoOpenClose
     */
    'closingTrades': Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>;
    /**
     * The date requested.
     * @type {string}
     * @memberof CryptoOpenClose
     */
    'day': string;
    /**
     * Whether or not the timestamps are in UTC timezone.
     * @type {boolean}
     * @memberof CryptoOpenClose
     */
    'isUTC': boolean;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoOpenClose
     */
    'open': number;
    /**
     * An array of results containing the requested data.
     * @type {Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>}
     * @memberof CryptoOpenClose
     */
    'openTrades': Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof CryptoOpenClose
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface CryptoSnapshotMinute
 */
export interface CryptoSnapshotMinute {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof CryptoSnapshotMinute
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface CryptoSnapshotTicker
 */
export interface CryptoSnapshotTicker {
    /**
     * 
     * @type {GetCryptoSnapshotTicker200ResponseAllOfTicker}
     * @memberof CryptoSnapshotTicker
     */
    'ticker'?: GetCryptoSnapshotTicker200ResponseAllOfTicker;
}
/**
 * 
 * @export
 * @interface CryptoSnapshotTickerFullBook
 */
export interface CryptoSnapshotTickerFullBook {
    /**
     * 
     * @type {DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData}
     * @memberof CryptoSnapshotTickerFullBook
     */
    'data'?: DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData;
}
/**
 * 
 * @export
 * @interface CryptoSnapshotTickers
 */
export interface CryptoSnapshotTickers {
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetCryptoSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof CryptoSnapshotTickers
     */
    'tickers'?: Array<GetCryptoSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface CryptoTick
 */
export interface CryptoTick {
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof CryptoTick
     */
    'c': Array<number>;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof CryptoTick
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof CryptoTick
     */
    'p': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof CryptoTick
     */
    's': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof CryptoTick
     */
    't': number;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://massive.com/docs/rest/crypto/market-operations/exchanges\">Exchanges</a> for a mapping of exchanges to IDs. 
     * @type {number}
     * @memberof CryptoTick
     */
    'x': number;
}
/**
 * 
 * @export
 * @interface DeprecatedGetCryptoSnapshotTickerBook200Response
 */
export interface DeprecatedGetCryptoSnapshotTickerBook200Response {
    /**
     * 
     * @type {DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200Response
     */
    'data'?: DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData;
}
/**
 * 
 * @export
 * @interface DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
 */
export interface DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData {
    /**
     * The combined total number of asks in the book.
     * @type {number}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
     */
    'askCount': number;
    /**
     * 
     * @type {Array<DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner>}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
     */
    'asks': Array<DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner>;
    /**
     * The combined total number of bids in the book.
     * @type {number}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
     */
    'bidCount': number;
    /**
     * 
     * @type {Array<DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner>}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
     */
    'bids': Array<DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner>;
    /**
     * The difference between the best bid and the best ask price across exchanges.
     * @type {number}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
     */
    'spread': number;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
     */
    'ticker': string;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfData
     */
    'updated': number;
}
/**
 * 
 * @export
 * @interface DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner
 */
export interface DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner {
    /**
     * The price of this book level.
     * @type {number}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner
     */
    'p': number;
    /**
     * A map of the exchange ID to number of shares at this price level. <br /> <br /> **Example:** <br /> `{   \"p\": 16302.94,   \"x\": {     \"1\": 0.02859424,     \"6\": 0.023455   } }` <br /> <br /> In this example, exchange ID 1 has 0.02859424 shares available at $16,302.94, and exchange ID 6 has 0.023455 shares at the same price level. 
     * @type {object}
     * @memberof DeprecatedGetCryptoSnapshotTickerBook200ResponseAllOfDataAsksInner
     */
    'x': object;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricCryptoTrades200Response
 */
export interface DeprecatedGetHistoricCryptoTrades200Response {
    /**
     * The date that was evaluated from the request.
     * @type {string}
     * @memberof DeprecatedGetHistoricCryptoTrades200Response
     */
    'day': string;
    /**
     * A map for shortened result keys.
     * @type {object}
     * @memberof DeprecatedGetHistoricCryptoTrades200Response
     */
    'map': object;
    /**
     * The milliseconds of latency for the query results.
     * @type {number}
     * @memberof DeprecatedGetHistoricCryptoTrades200Response
     */
    'msLatency': number;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof DeprecatedGetHistoricCryptoTrades200Response
     */
    'symbol': string;
    /**
     * 
     * @type {Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>}
     * @memberof DeprecatedGetHistoricCryptoTrades200Response
     */
    'ticks': Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner
 */
export interface DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner {
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner
     */
    'c': Array<number>;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner
     */
    'p': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner
     */
    's': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner
     */
    't': number;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://massive.com/docs/rest/crypto/market-operations/exchanges\">Exchanges</a> for a mapping of exchanges to IDs. 
     * @type {number}
     * @memberof DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner
     */
    'x': number;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricForexQuotes200Response
 */
export interface DeprecatedGetHistoricForexQuotes200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof DeprecatedGetHistoricForexQuotes200Response
     */
    'status': string;
    /**
     * The date that was evaluated from the request.
     * @type {string}
     * @memberof DeprecatedGetHistoricForexQuotes200Response
     */
    'day': string;
    /**
     * A map for shortened result keys.
     * @type {object}
     * @memberof DeprecatedGetHistoricForexQuotes200Response
     */
    'map': object;
    /**
     * The milliseconds of latency for the query results.
     * @type {number}
     * @memberof DeprecatedGetHistoricForexQuotes200Response
     */
    'msLatency': number;
    /**
     * The currency pair that was evaluated from the request.
     * @type {string}
     * @memberof DeprecatedGetHistoricForexQuotes200Response
     */
    'pair': string;
    /**
     * 
     * @type {Array<DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner>}
     * @memberof DeprecatedGetHistoricForexQuotes200Response
     */
    'ticks': Array<DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner>;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner
 */
export interface DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner {
    /**
     * The ask price.
     * @type {number}
     * @memberof DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner
     */
    'a': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner
     */
    'b': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner
     */
    't': number;
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/forex/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner
     */
    'x': number;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricStocksQuotes200Response
 */
export interface DeprecatedGetHistoricStocksQuotes200Response {
    /**
     * Latency in milliseconds for the query results from the database.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200Response
     */
    'db_latency'?: number;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200Response
     */
    'results_count'?: number;
    /**
     * Whether or not this query was executed successfully.
     * @type {boolean}
     * @memberof DeprecatedGetHistoricStocksQuotes200Response
     */
    'success'?: boolean;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof DeprecatedGetHistoricStocksQuotes200Response
     */
    'ticker'?: string;
    /**
     * 
     * @type {Array<DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner>}
     * @memberof DeprecatedGetHistoricStocksQuotes200Response
     */
    'results'?: Array<DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
 */
export interface DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'y': number;
    /**
     * The ask price.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'P': number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'S': number;
    /**
     * The ask exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'X': number;
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'c': Array<number>;
    /**
     * The indicators. For more information, see our glossary of [Conditions and Indicators](https://massive.com/glossary/conditions-indicators). 
     * @type {Array<number>}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'i': Array<number>;
    /**
     * The bid price.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'p': number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    's': number;
    /**
     * The bid exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'x': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricStocksTrades200Response
 */
export interface DeprecatedGetHistoricStocksTrades200Response {
    /**
     * Latency in milliseconds for the query results from the database.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200Response
     */
    'db_latency'?: number;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200Response
     */
    'results_count'?: number;
    /**
     * Whether or not this query was executed successfully.
     * @type {boolean}
     * @memberof DeprecatedGetHistoricStocksTrades200Response
     */
    'success'?: boolean;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof DeprecatedGetHistoricStocksTrades200Response
     */
    'ticker'?: string;
    /**
     * 
     * @type {Array<DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner>}
     * @memberof DeprecatedGetHistoricStocksTrades200Response
     */
    'results'?: Array<DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
 */
export interface DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'y': number;
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'c': Array<number>;
    /**
     * The trade correction indicator. 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'e': number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'p': number;
    /**
     * The ID for the Trade Reporting Facility where the trade took place. 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'r': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    's': number;
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'x': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ 
     * @type {number}
     * @memberof DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface ExchangeInner
 */
export interface ExchangeInner {
    /**
     * A unique identifier for the exchange internal to Massive.com.  This is not an industry code or ISO standard.
     * @type {string}
     * @memberof ExchangeInner
     */
    'code'?: string;
    /**
     * The ID of the exchange.
     * @type {number}
     * @memberof ExchangeInner
     */
    'id'?: number;
    /**
     * The market data type that this exchange contains.
     * @type {string}
     * @memberof ExchangeInner
     */
    'market'?: string;
    /**
     * The Market Identification Code or MIC as defined in ISO 10383 (<a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Market_Identifier_Code\">https://en.wikipedia.org/wiki/Market_Identifier_Code</a>).
     * @type {string}
     * @memberof ExchangeInner
     */
    'mic'?: string;
    /**
     * The name of the exchange.
     * @type {string}
     * @memberof ExchangeInner
     */
    'name'?: string;
    /**
     * The tape id of the exchange.
     * @type {string}
     * @memberof ExchangeInner
     */
    'tape'?: string;
    /**
     * The type of exchange. - TRF = Trade Reporting Facility - exchange = Reporting exchange on the tape 
     * @type {string}
     * @memberof ExchangeInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface Financial
 */
export interface Financial {
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'cashChange'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'cashFlow'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'costOfRevenue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'currentAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'currentCash'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'currentDebt'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'grossProfit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'netIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'operatingExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'operatingGainsLosses'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'operatingIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'operatingRevenue'?: number;
    /**
     * Report Date
     * @type {string}
     * @memberof Financial
     */
    'reportDate': string;
    /**
     * Report date as non date format
     * @type {string}
     * @memberof Financial
     */
    'reportDateStr': string;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'researchAndDevelopment'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'shareholderEquity'?: number;
    /**
     * Stock Symbol
     * @type {string}
     * @memberof Financial
     */
    'symbol': string;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalCash'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalDebt'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalLiabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financial
     */
    'totalRevenue'?: number;
}
/**
 * Financials
 * @export
 * @interface Financials
 */
export interface Financials {
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'EBITDAMargin'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'accumulatedOtherComprehensiveIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'accumulatedRetainedEarningsDeficit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assetTurnover'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assetsAverage'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assetsCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'assetsNonCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'averageEquity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'bookValuePerShare'?: number;
    /**
     * 
     * @type {string}
     * @memberof Financials
     */
    'calendarDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'capitalExpenditure'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'cashAndEquivalents'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'cashAndEquivalentsUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'consolidatedIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'costOfRevenue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'currentLiabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'currentRatio'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debt'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debtCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debtNonCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debtToEquityRatio'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'debtUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'deferredRevenue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'deposits'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'depreciationAmortizationAndAccretion'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'dividendYield'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'dividendsPerBasicCommonShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningBeforeInterestTaxes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningBeforeInterestTaxesUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsBeforeInterestTaxesDepreciationAmortization'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsBeforeInterestTaxesDepreciationAmortizationUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsBeforeTax'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsPerBasicShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsPerBasicShareUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'earningsPerDilutedShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'effectOfExchangeRateChangesOnCash'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'enterpriseValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'enterpriseValueOverEBIT'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'enterpriseValueOverEBITDA'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'foreignCurrencyUSDExchangeRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'freeCashFlow'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'freeCashFlowPerShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'goodwillAndIntangibleAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'grossMargin'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'grossProfit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'incomeTaxExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'interestExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'inventory'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investedCapital'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investedCapitalAverage'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investments'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investmentsCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'investmentsNonCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'issuanceDebtSecurities'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'issuanceEquityShares'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'liabilitiesNonCurrent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'marketCapitalization'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlow'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowBusinessAcquisitionsDisposals'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowFromFinancing'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowFromInvesting'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowFromOperations'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netCashFlowInvestmentAcquisitionsDisposals'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netIncomeCommonStock'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netIncomeCommonStockUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netIncomeToNonControllingInterests'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'netLossIncomeFromDiscontinuedOperations'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'operatingExpenses'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'operatingIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'paymentDividendsOtherCashDistributions'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'payoutRatio'?: number;
    /**
     * Reporting period.
     * @type {string}
     * @memberof Financials
     */
    'period'?: FinancialsPeriodEnum;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'preferredDividendsIncomeStatementImpact'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceEarnings'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceSales'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceToBookValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceToEarningsRatio'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'priceToSalesRatio'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'profitMargin'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'propertyPlantEquipmentNet'?: number;
    /**
     * 
     * @type {string}
     * @memberof Financials
     */
    'reportPeriod'?: string;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'researchAndDevelopmentExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'returnOnAverageAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'returnOnAverageEquity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'returnOnInvestedCapital'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'returnOnSales'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'revenues'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'revenuesUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'salesPerShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'sellingGeneralAndAdministrativeExpense'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shareBasedCompensation'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shareFactor'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'sharePriceAdjustedClose'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shareholdersEquity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shareholdersEquityUSD'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'shares'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'tangibleAssetValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'tangibleAssetsBookValuePerShare'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'taxAssets'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'taxLiabilities'?: number;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof Financials
     */
    'ticker': string;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'totalLiabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'tradeAndNonTradePayables'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'tradeAndNonTradeReceivables'?: number;
    /**
     * 
     * @type {string}
     * @memberof Financials
     */
    'updated'?: string;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'weightedAverageShares'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'weightedAverageSharesDiluted'?: number;
    /**
     * 
     * @type {number}
     * @memberof Financials
     */
    'workingCapital'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum FinancialsPeriodEnum {
    Q = 'Q',
    T = 'T',
    Qa = 'QA',
    Ta = 'TA',
    Y = 'Y',
    Ya = 'YA'
}

/**
 * 
 * @export
 * @interface ForexConversion
 */
export interface ForexConversion {
    /**
     * The result of the conversion.
     * @type {number}
     * @memberof ForexConversion
     */
    'converted': number;
    /**
     * The \"from\" currency symbol.
     * @type {string}
     * @memberof ForexConversion
     */
    'from': string;
    /**
     * The amount to convert.
     * @type {number}
     * @memberof ForexConversion
     */
    'initialAmount': number;
    /**
     * 
     * @type {ForexConversionLast}
     * @memberof ForexConversion
     */
    'last'?: ForexConversionLast;
    /**
     * The \"to\" currency symbol.
     * @type {string}
     * @memberof ForexConversion
     */
    'to': string;
}
/**
 * 
 * @export
 * @interface ForexConversionLast
 */
export interface ForexConversionLast {
    /**
     * The ask price.
     * @type {number}
     * @memberof ForexConversionLast
     */
    'ask': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof ForexConversionLast
     */
    'bid': number;
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/forex/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof ForexConversionLast
     */
    'exchange': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof ForexConversionLast
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface ForexGroupedResults
 */
export interface ForexGroupedResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>}
     * @memberof ForexGroupedResults
     */
    'results'?: Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface ForexHistoricTrades
 */
export interface ForexHistoricTrades {
    /**
     * The date that was evaluated from the request.
     * @type {string}
     * @memberof ForexHistoricTrades
     */
    'day': string;
    /**
     * A map for shortened result keys.
     * @type {object}
     * @memberof ForexHistoricTrades
     */
    'map': object;
    /**
     * The milliseconds of latency for the query results.
     * @type {number}
     * @memberof ForexHistoricTrades
     */
    'msLatency': number;
    /**
     * The currency pair that was evaluated from the request.
     * @type {string}
     * @memberof ForexHistoricTrades
     */
    'pair': string;
    /**
     * 
     * @type {Array<DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner>}
     * @memberof ForexHistoricTrades
     */
    'ticks': Array<DeprecatedGetHistoricForexQuotes200ResponseAllOfTicksInner>;
}
/**
 * 
 * @export
 * @interface ForexPairLastQuote
 */
export interface ForexPairLastQuote {
    /**
     * 
     * @type {ForexConversionLast}
     * @memberof ForexPairLastQuote
     */
    'last'?: ForexConversionLast;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof ForexPairLastQuote
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface ForexPreviousClose
 */
export interface ForexPreviousClose {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetPreviousForexAggregates200ResponseAllOfResultsInner>}
     * @memberof ForexPreviousClose
     */
    'results'?: Array<GetPreviousForexAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface ForexSnapshotLastQuote
 */
export interface ForexSnapshotLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof ForexSnapshotLastQuote
     */
    'a': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof ForexSnapshotLastQuote
     */
    'b': number;
    /**
     * The millisecond accuracy timestamp of the quote.
     * @type {number}
     * @memberof ForexSnapshotLastQuote
     */
    't': number;
    /**
     * The exchange ID on which this quote happened.
     * @type {number}
     * @memberof ForexSnapshotLastQuote
     */
    'x': number;
}
/**
 * 
 * @export
 * @interface ForexSnapshotPrevDay
 */
export interface ForexSnapshotPrevDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof ForexSnapshotPrevDay
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface ForexSnapshotTicker
 */
export interface ForexSnapshotTicker {
    /**
     * 
     * @type {GetForexSnapshotTicker200ResponseAllOfTicker}
     * @memberof ForexSnapshotTicker
     */
    'ticker'?: GetForexSnapshotTicker200ResponseAllOfTicker;
}
/**
 * 
 * @export
 * @interface ForexSnapshotTickers
 */
export interface ForexSnapshotTickers {
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetForexSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof ForexSnapshotTickers
     */
    'tickers'?: Array<GetForexSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface ForexTickerResults
 */
export interface ForexTickerResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetCryptoAggregates200ResponseAllOfResultsInner>}
     * @memberof ForexTickerResults
     */
    'results'?: Array<GetCryptoAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1AnalystInsights200Response
 */
export interface GetBenzingaV1AnalystInsights200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1AnalystInsights200ResponseResultsInner>}
     * @memberof GetBenzingaV1AnalystInsights200Response
     */
    'results': Array<GetBenzingaV1AnalystInsights200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200Response
     */
    'status': GetBenzingaV1AnalystInsights200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1AnalystInsights200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1AnalystInsights200ResponseResultsInner
 */
export interface GetBenzingaV1AnalystInsights200ResponseResultsInner {
    /**
     * The identifer used by Benzinga for the firm record.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'benzinga_firm_id'?: string;
    /**
     * The identifer used by Benzinga for this record.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'benzinga_id'?: string;
    /**
     * The identifier used by Benzinga for the rating record.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'benzinga_rating_id'?: string;
    /**
     * The name of the company being rated.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'company_name'?: string;
    /**
     * The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'date'?: string;
    /**
     * The name of the research firm or investment bank issuing the rating.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'firm'?: string;
    /**
     * Narrative commentary or reasoning provided by the analyst or firm to explain the rating or price target.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'insight'?: string;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * The current price target set by the analyst.
     * @type {number}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'price_target'?: number;
    /**
     * The current rating set by the analyst.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'rating'?: string;
    /**
     * The description of the change in rating from the firm\'s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'rating_action'?: string;
    /**
     * The stock symbol of the company being rated.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights200ResponseResultsInner
     */
    'ticker'?: string;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1AnalystInsights400Response
 */
export interface GetBenzingaV1AnalystInsights400Response {
    /**
     * A message describing the source of the error.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights400Response
     */
    'error': string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights400Response
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1AnalystInsights400Response
     */
    'status': GetBenzingaV1AnalystInsights400ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1AnalystInsights400ResponseStatusEnum {
    Error = 'ERROR'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1Analysts200Response
 */
export interface GetBenzingaV1Analysts200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1Analysts200ResponseResultsInner>}
     * @memberof GetBenzingaV1Analysts200Response
     */
    'results': Array<GetBenzingaV1Analysts200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200Response
     */
    'status': GetBenzingaV1Analysts200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1Analysts200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1Analysts200ResponseResultsInner
 */
export interface GetBenzingaV1Analysts200ResponseResultsInner {
    /**
     * The unique identifier assigned by Benzinga to the research firm or investment bank.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'benzinga_firm_id'?: string;
    /**
     * The identifier used by Benzinga for this record.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'benzinga_id'?: string;
    /**
     * The name of the research firm or investment bank issuing the ratings.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'firm_name'?: string;
    /**
     * The full name of the analyst associated with the ratings.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'full_name'?: string;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the analyst record was last updated in the system.
     * @type {string}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * The average percent price difference per rating since the date of recommendation.
     * @type {number}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'overall_avg_return'?: number;
    /**
     * The analyst\'s percentile rank based on average return, relative to other analysts.
     * @type {number}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'overall_avg_return_percentile'?: number;
    /**
     * The percentage of gain/loss ratings that resulted in a gain overall.
     * @type {number}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'overall_success_rate'?: number;
    /**
     * A weighted average of the total_ratings_percentile, overall_avg_return_percentile, and overall_success_rate.
     * @type {number}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'smart_score'?: number;
    /**
     * The total number of ratings issued by the analyst included in the performance calculation.
     * @type {number}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'total_ratings'?: number;
    /**
     * The analyst\'s percentile rank based on the total number of ratings issued, relative to other analysts.
     * @type {number}
     * @memberof GetBenzingaV1Analysts200ResponseResultsInner
     */
    'total_ratings_percentile'?: number;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1ConsensusRatings200Response
 */
export interface GetBenzingaV1ConsensusRatings200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1ConsensusRatings200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1ConsensusRatings200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1ConsensusRatings200ResponseResultsInner>}
     * @memberof GetBenzingaV1ConsensusRatings200Response
     */
    'results': Array<GetBenzingaV1ConsensusRatings200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1ConsensusRatings200Response
     */
    'status': GetBenzingaV1ConsensusRatings200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1ConsensusRatings200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1ConsensusRatings200ResponseResultsInner
 */
export interface GetBenzingaV1ConsensusRatings200ResponseResultsInner {
    /**
     * The count of \'Buy\' ratings from contributing analysts.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'buy_ratings': number;
    /**
     * The average price target across all analysts, rounded to 2 decimal places.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'consensus_price_target'?: number;
    /**
     * The overall rating category determined by the average consensus weight. Possible values: \'strong_buy\', \'buy\', \'hold\', \'sell\', \'strong_sell\'.
     * @type {string}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'consensus_rating'?: string;
    /**
     * The numerical average of all consensus weights, rounded to 2 decimal places. Scale ranges from 1 (Strong Sell) to 5 (Strong Buy).
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'consensus_rating_value'?: number;
    /**
     * The highest price target among all contributing analysts.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'high_price_target'?: number;
    /**
     * The count of \'Hold\' ratings from contributing analysts.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'hold_ratings': number;
    /**
     * The lowest price target among all contributing analysts.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'low_price_target'?: number;
    /**
     * The number of unique analysts contributing price targets.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'price_target_contributors': number;
    /**
     * The number of unique analysts contributing to the overall ratings consensus.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'ratings_contributors': number;
    /**
     * The count of \'Sell\' ratings from contributing analysts.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'sell_ratings': number;
    /**
     * The count of \'Strong Buy\' ratings from contributing analysts.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'strong_buy_ratings': number;
    /**
     * The count of \'Strong Sell\' ratings from contributing analysts.
     * @type {number}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'strong_sell_ratings': number;
    /**
     * The requested ticker.
     * @type {string}
     * @memberof GetBenzingaV1ConsensusRatings200ResponseResultsInner
     */
    'ticker'?: string;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1Earnings200Response
 */
export interface GetBenzingaV1Earnings200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1Earnings200ResponseResultsInner>}
     * @memberof GetBenzingaV1Earnings200Response
     */
    'results': Array<GetBenzingaV1Earnings200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200Response
     */
    'status': GetBenzingaV1Earnings200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1Earnings200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1Earnings200ResponseResultsInner
 */
export interface GetBenzingaV1Earnings200ResponseResultsInner {
    /**
     * The actual earnings per share (EPS) reported by the company for the given period.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'actual_eps'?: number;
    /**
     * The actual revenue reported by the company for the given fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'actual_revenue'?: number;
    /**
     * The identifer used by Benzinga for this record.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'benzinga_id'?: string;
    /**
     * The name of the company releasing earnings.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'company_name'?: string;
    /**
     * The ISO 4217 currency code indicating the denomination in which the figures are reported.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'currency'?: string;
    /**
     * The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'date'?: string;
    /**
     * Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'date_status'?: string;
    /**
     * The methodology of the EPS figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles), ffo (Funds From Operations, a non-GAAP metric commonly used to assess the operating performance of REITs), and adj (adjusted, non-GAAP).
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'eps_method'?: string;
    /**
     * The difference between the actual and estimated EPS.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'eps_surprise'?: number;
    /**
     * The percentage difference between the actual and estimated EPS.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'eps_surprise_percent'?: number;
    /**
     * The analyst consensus estimate for earnings per share (EPS) for the given period.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'estimated_eps'?: number;
    /**
     * The analyst consensus estimate for the company\'s revenue in the given period.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'estimated_revenue'?: number;
    /**
     * The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'fiscal_period'?: string;
    /**
     * The fiscal year in which the earnings period falls.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'fiscal_year'?: number;
    /**
     * A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest).
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'importance'?: number;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * Additional context, commentary, or clarifying notes related to the earnings event.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'notes'?: string;
    /**
     * The company\'s reported earnings per share (EPS) for the previous comparable period.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'previous_eps'?: number;
    /**
     * The company\'s revenue for the previous comparable fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'previous_revenue'?: number;
    /**
     * The methodology of the revenue figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles), adj (adjusted, non-GAAP figures that exclude certain items like one-time charges or divestitures), and rental (revenue specifically derived from rental operations, typically used by REITs, leasing companies, or businesses with a rental-based model).
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'revenue_method'?: string;
    /**
     * The difference between the actual and estimated revenue.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'revenue_surprise'?: number;
    /**
     * The percentage difference between the actual and estimated revenue.
     * @type {number}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'revenue_surprise_percent'?: number;
    /**
     * The stock symbol of the company reporting earnings.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * The time (formatted as 24-hour HH:MM:SS UTC) when the earnings are scheduled or were reported.
     * @type {string}
     * @memberof GetBenzingaV1Earnings200ResponseResultsInner
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1Firms200Response
 */
export interface GetBenzingaV1Firms200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1Firms200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1Firms200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1Firms200ResponseResultsInner>}
     * @memberof GetBenzingaV1Firms200Response
     */
    'results': Array<GetBenzingaV1Firms200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1Firms200Response
     */
    'status': GetBenzingaV1Firms200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1Firms200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1Firms200ResponseResultsInner
 */
export interface GetBenzingaV1Firms200ResponseResultsInner {
    /**
     * The identifer used by Benzinga for this record.
     * @type {string}
     * @memberof GetBenzingaV1Firms200ResponseResultsInner
     */
    'benzinga_id'?: string;
    /**
     * Primary currency used by the financial firm, with some entries having null values.
     * @type {string}
     * @memberof GetBenzingaV1Firms200ResponseResultsInner
     */
    'currency'?: string;
    /**
     * Timestamp indicating when the firm\'s information was last modified or verified in the database.
     * @type {string}
     * @memberof GetBenzingaV1Firms200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * The name of a research firm or investment bank which issues ratings.
     * @type {string}
     * @memberof GetBenzingaV1Firms200ResponseResultsInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1Guidance200Response
 */
export interface GetBenzingaV1Guidance200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1Guidance200ResponseResultsInner>}
     * @memberof GetBenzingaV1Guidance200Response
     */
    'results': Array<GetBenzingaV1Guidance200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200Response
     */
    'status': GetBenzingaV1Guidance200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1Guidance200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1Guidance200ResponseResultsInner
 */
export interface GetBenzingaV1Guidance200ResponseResultsInner {
    /**
     * A unique identifier assigned by Benzinga to the guidance record.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'benzinga_id'?: string;
    /**
     * The name of the company issuing guidance.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'company_name'?: string;
    /**
     * The ISO 4217 code representing the currency in which the company issued its guidance figures.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'currency'?: string;
    /**
     * The calendar date (formatted as YYYY-MM-DD) when the guidance was issued.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'date'?: string;
    /**
     * The methodology of the EPS figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles), ffo (Funds From Operations, a non-GAAP metric commonly used to assess the operating performance of REITs), and adj (adjusted, non-GAAP).
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'eps_method'?: string;
    /**
     * The midpoint or central earnings per share (EPS) value the company expects for the given fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'estimated_eps_guidance'?: number;
    /**
     * The midpoint or central revenue figure the company expects for the given fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'estimated_revenue_guidance'?: number;
    /**
     * The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'fiscal_period'?: string;
    /**
     * The fiscal year corresponding to the period for which the guidance is issued.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'fiscal_year'?: number;
    /**
     * A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest).
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'importance'?: number;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * The highest EPS value the company expects for the fiscal period if a range was provided.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'max_eps_guidance'?: number;
    /**
     * The highest revenue figure the company expects for the fiscal period if a range was provided.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'max_revenue_guidance'?: number;
    /**
     * The lowest EPS value the company expects for the fiscal period if a range was provided.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'min_eps_guidance'?: number;
    /**
     * The lowest revenue figure the company expects for the fiscal period if a range was provided.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'min_revenue_guidance'?: number;
    /**
     * Additional descriptive text or commentary provided about the guidance record.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'notes'?: string;
    /**
     * Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are \'primary\' (the emphasized figure) and \'secondary\' (a supporting or alternate figure)
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'positioning'?: string;
    /**
     * The highest EPS value issued in a previous guidance record for the same fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'previous_max_eps_guidance'?: number;
    /**
     * The highest revenue value issued in a previous guidance record for the same fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'previous_max_revenue_guidance'?: number;
    /**
     * The lowest EPS value issued in a previous guidance record for the same fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'previous_min_eps_guidance'?: number;
    /**
     * The lowest revenue value issued in a previous guidance record for the same fiscal period.
     * @type {number}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'previous_min_revenue_guidance'?: number;
    /**
     * Indicates whether the guidance was issued as part of a scheduled earnings release (\'official\') or as an unscheduled update (\'preliminary\').
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'release_type'?: string;
    /**
     * The methodology of the revenue figure. Possible values are gaap (standardized financials under Generally Accepted Accounting Principles) and adj (adjusted, non-GAAP).
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'revenue_method'?: string;
    /**
     * The stock symbol of the company issuing guidance.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * The time of day the guidance was announced, in HH:mm:ss format.
     * @type {string}
     * @memberof GetBenzingaV1Guidance200ResponseResultsInner
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1News200Response
 */
export interface GetBenzingaV1News200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1News200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1News200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1News200ResponseResultsInner>}
     * @memberof GetBenzingaV1News200Response
     */
    'results': Array<GetBenzingaV1News200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1News200Response
     */
    'status': GetBenzingaV1News200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1News200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1News200ResponseResultsInner
 */
export interface GetBenzingaV1News200ResponseResultsInner {
    /**
     * The name of the journalist or entity that authored the news article.
     * @type {string}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'author'?: string;
    /**
     * The identifer used by Benzinga for this record.
     * @type {number}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'benzinga_id'?: number;
    /**
     * The full text content of the news article.
     * @type {string}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'body'?: string;
    /**
     * A list of categories or topics that the article belongs to (e.g., \'News\', \'Price Target\').
     * @type {Array<string>}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'channels'?: Array<string>;
    /**
     * A list of images associated with the article.
     * @type {Array<string>}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'images'?: Array<string>;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system.
     * @type {string}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
     * @type {string}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'published'?: string;
    /**
     * A list of tags that describe the themes or content of the article.
     * @type {Array<string>}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'tags'?: Array<string>;
    /**
     * A short summary or lead-in to the news article\'s content.
     * @type {string}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'teaser'?: string;
    /**
     * A list of stock or crypto tickers mentioned in the article.
     * @type {Array<string>}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'tickers'?: Array<string>;
    /**
     * The headline of the news article.
     * @type {string}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'title'?: string;
    /**
     * The direct link to the source of the news article.
     * @type {string}
     * @memberof GetBenzingaV1News200ResponseResultsInner
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface GetBenzingaV1Ratings200Response
 */
export interface GetBenzingaV1Ratings200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV1Ratings200ResponseResultsInner>}
     * @memberof GetBenzingaV1Ratings200Response
     */
    'results': Array<GetBenzingaV1Ratings200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200Response
     */
    'status': GetBenzingaV1Ratings200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV1Ratings200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV1Ratings200ResponseResultsInner
 */
export interface GetBenzingaV1Ratings200ResponseResultsInner {
    /**
     * The current price target adjusted for stock splits and dividends.
     * @type {number}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'adjusted_price_target'?: number;
    /**
     * The name of the individual analyst who issued the rating.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'analyst'?: string;
    /**
     * The identifer used by Benzinga for this analyst.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'benzinga_analyst_id'?: string;
    /**
     * A link to the Benzinga calendar page for this ticker
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'benzinga_calendar_url'?: string;
    /**
     * The identifer used by Benzinga for this firm.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'benzinga_firm_id'?: string;
    /**
     * The identifer used by Benzinga for this record.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'benzinga_id'?: string;
    /**
     * A link to the Benzinga articles page for this ticker
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'benzinga_news_url'?: string;
    /**
     * The name of the company being rated.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'company_name'?: string;
    /**
     * The ISO 4217 currency code in which the price target is denominated.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'currency'?: string;
    /**
     * The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'date'?: string;
    /**
     * The name of the research firm or investment bank issuing the rating.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'firm'?: string;
    /**
     * A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest).
     * @type {number}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'importance'?: number;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * Additional context or commentary.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'notes'?: string;
    /**
     * The previous price target adjusted for stock splits and dividends.
     * @type {number}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'previous_adjusted_price_target'?: number;
    /**
     * The previous price target set by the analyst.
     * @type {number}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'previous_price_target'?: number;
    /**
     * The previous rating set by the analyst.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'previous_rating'?: string;
    /**
     * The percentage change in price target if price target and previous price target exists
     * @type {number}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'price_percent_change'?: number;
    /**
     * The current price target set by the analyst.
     * @type {number}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'price_target'?: number;
    /**
     * The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'price_target_action'?: string;
    /**
     * The current rating set by the analyst.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'rating'?: string;
    /**
     * The description of the change in rating from the firm\'s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'rating_action'?: string;
    /**
     * The stock symbol of the company being rated.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * The time (formatted as 24-hour HH:MM:SS UTC) when the rating was issued.
     * @type {string}
     * @memberof GetBenzingaV1Ratings200ResponseResultsInner
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface GetBenzingaV2News200Response
 */
export interface GetBenzingaV2News200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetBenzingaV2News200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetBenzingaV2News200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetBenzingaV2News200ResponseResultsInner>}
     * @memberof GetBenzingaV2News200Response
     */
    'results': Array<GetBenzingaV2News200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetBenzingaV2News200Response
     */
    'status': GetBenzingaV2News200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetBenzingaV2News200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetBenzingaV2News200ResponseResultsInner
 */
export interface GetBenzingaV2News200ResponseResultsInner {
    /**
     * The name of the journalist or entity that authored the news article.
     * @type {string}
     * @memberof GetBenzingaV2News200ResponseResultsInner
     */
    'author': string;
    /**
     * The identifer used by Benzinga for this record.
     * @type {number}
     * @memberof GetBenzingaV2News200ResponseResultsInner
     */
    'benzinga_id': number;
    /**
     * The full text content of the news article.
     * @type {string}
     * @memberof GetBenzingaV2News200ResponseResultsInner
     */
    'body'?: string;
    /**
     * A list of categories or topics that the article belongs to (e.g., \'News\', \'Price Target\').
     * @type {Array<string>}
     * @memberof GetBenzingaV2News200ResponseResultsInner
     */
    'channels'?: Array<string>;
    /**
     * A list of images associated with the article.
     * @type {Array<string>}
     * @memberof GetBenzingaV2News200ResponseResultsInner
     */
    'images'?: Array<string>;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system.
     * @type {string}
     * @memberof GetBenzingaV2News200ResponseResultsInner
     */
    'last_updated': string;
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
     * @type {string}
     * @memberof GetBenzingaV2News200ResponseResultsInner
     */
    'published': string;
    /**
     * A list of tags that describe the themes or content of the article.
     * @type {Array<string>}
     * @memberof GetBenzingaV2News200ResponseResultsInner
     */
    'tags'?: Array<string>;
    /**
     * A short summary or lead-in to the news article\'s content.
     * @type {string}
     * @memberof GetBenzingaV2News200ResponseResultsInner
     */
    'teaser'?: string;
    /**
     * A list of stock or crypto tickers mentioned in the article.
     * @type {Array<string>}
     * @memberof GetBenzingaV2News200ResponseResultsInner
     */
    'tickers'?: Array<string>;
    /**
     * The headline of the news article.
     * @type {string}
     * @memberof GetBenzingaV2News200ResponseResultsInner
     */
    'title': string;
    /**
     * The direct link to the source of the news article.
     * @type {string}
     * @memberof GetBenzingaV2News200ResponseResultsInner
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface GetCryptoAggregates200Response
 */
export interface GetCryptoAggregates200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetCryptoAggregates200Response
     */
    'ticker': string;
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof GetCryptoAggregates200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof GetCryptoAggregates200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoAggregates200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetCryptoAggregates200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoAggregates200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetCryptoAggregates200ResponseAllOfResultsInner>}
     * @memberof GetCryptoAggregates200Response
     */
    'results'?: Array<GetCryptoAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetCryptoAggregates200ResponseAllOfResultsInner
 */
export interface GetCryptoAggregates200ResponseAllOfResultsInner {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetCryptoAggregates200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface GetCryptoEMA200Response
 */
export interface GetCryptoEMA200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetCryptoEMA200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoEMA200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetCryptoEMA200ResponseResults}
     * @memberof GetCryptoEMA200Response
     */
    'results': GetCryptoEMA200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoEMA200Response
     */
    'status': string;
}
/**
 * The results of the EMA indicator calculation.
 * @export
 * @interface GetCryptoEMA200ResponseResults
 */
export interface GetCryptoEMA200ResponseResults {
    /**
     * 
     * @type {GetCryptoEMA200ResponseResultsUnderlying}
     * @memberof GetCryptoEMA200ResponseResults
     */
    'underlying'?: GetCryptoEMA200ResponseResultsUnderlying;
    /**
     * Timestamp or indicator value.
     * @type {Array<GetCryptoEMA200ResponseResultsValuesInner>}
     * @memberof GetCryptoEMA200ResponseResults
     */
    'values'?: Array<GetCryptoEMA200ResponseResultsValuesInner>;
}
/**
 * The underlying aggregates used.
 * @export
 * @interface GetCryptoEMA200ResponseResultsUnderlying
 */
export interface GetCryptoEMA200ResponseResultsUnderlying {
    /**
     * The array of aggregates used in the calculation of this indicator.
     * @type {Array<GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner>}
     * @memberof GetCryptoEMA200ResponseResultsUnderlying
     */
    'aggregates'?: Array<GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner>;
    /**
     * The URL which can be used to request the underlying aggregates used in this request.
     * @type {string}
     * @memberof GetCryptoEMA200ResponseResultsUnderlying
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
 */
export interface GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'otc'?: boolean;
    /**
     * The Unix Msec timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsUnderlyingAggregatesInner
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface GetCryptoEMA200ResponseResultsValuesInner
 */
export interface GetCryptoEMA200ResponseResultsValuesInner {
    /**
     * The Unix Msec timestamp from the last aggregate used in this calculation.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsValuesInner
     */
    'timestamp'?: number;
    /**
     * The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
     * @type {number}
     * @memberof GetCryptoEMA200ResponseResultsValuesInner
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface GetCryptoMACD200Response
 */
export interface GetCryptoMACD200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetCryptoMACD200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoMACD200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetCryptoMACD200ResponseResults}
     * @memberof GetCryptoMACD200Response
     */
    'results': GetCryptoMACD200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoMACD200Response
     */
    'status': string;
}
/**
 * The results of the MACD indicator calculation.
 * @export
 * @interface GetCryptoMACD200ResponseResults
 */
export interface GetCryptoMACD200ResponseResults {
    /**
     * 
     * @type {GetCryptoEMA200ResponseResultsUnderlying}
     * @memberof GetCryptoMACD200ResponseResults
     */
    'underlying'?: GetCryptoEMA200ResponseResultsUnderlying;
    /**
     * Each entry in the values array represents MACD indicator data for a specific timestamp and includes:
     * @type {Array<GetCryptoMACD200ResponseResultsValuesInner>}
     * @memberof GetCryptoMACD200ResponseResults
     */
    'values'?: Array<GetCryptoMACD200ResponseResultsValuesInner>;
}
/**
 * 
 * @export
 * @interface GetCryptoMACD200ResponseResultsValuesInner
 */
export interface GetCryptoMACD200ResponseResultsValuesInner {
    /**
     * The difference between the MACD line (value) and the signal line (signal). Positive histogram values indicate upward (bullish) momentum, while negative histogram values indicate downward (bearish) momentum.
     * @type {number}
     * @memberof GetCryptoMACD200ResponseResultsValuesInner
     */
    'histogram'?: number;
    /**
     * The signal line value, calculated as the exponential moving average (EMA) of the MACD line (value) over the signal period defined in the request parameters. Traders typically use crossovers between the MACD and signal lines as trading signals.
     * @type {number}
     * @memberof GetCryptoMACD200ResponseResultsValuesInner
     */
    'signal'?: number;
    /**
     * The Unix Msec timestamp from the last aggregate used in this calculation.
     * @type {number}
     * @memberof GetCryptoMACD200ResponseResultsValuesInner
     */
    'timestamp'?: number;
    /**
     * The MACD line value, calculated as the difference between the short-term and long-term exponential moving averages (EMAs) based on the periods specified in the request parameters.
     * @type {number}
     * @memberof GetCryptoMACD200ResponseResultsValuesInner
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface GetCryptoOpenClose200Response
 */
export interface GetCryptoOpenClose200Response {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoOpenClose200Response
     */
    'close': number;
    /**
     * An array of results containing the requested data.
     * @type {Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>}
     * @memberof GetCryptoOpenClose200Response
     */
    'closingTrades': Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>;
    /**
     * The date requested.
     * @type {string}
     * @memberof GetCryptoOpenClose200Response
     */
    'day': string;
    /**
     * Whether or not the timestamps are in UTC timezone.
     * @type {boolean}
     * @memberof GetCryptoOpenClose200Response
     */
    'isUTC': boolean;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoOpenClose200Response
     */
    'open': number;
    /**
     * An array of results containing the requested data.
     * @type {Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>}
     * @memberof GetCryptoOpenClose200Response
     */
    'openTrades': Array<DeprecatedGetHistoricCryptoTrades200ResponseAllOfTicksInner>;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof GetCryptoOpenClose200Response
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface GetCryptoRSI200Response
 */
export interface GetCryptoRSI200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetCryptoRSI200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoRSI200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetCryptoRSI200ResponseResults}
     * @memberof GetCryptoRSI200Response
     */
    'results': GetCryptoRSI200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoRSI200Response
     */
    'status': string;
}
/**
 * The results of the RSI indicator calculation.
 * @export
 * @interface GetCryptoRSI200ResponseResults
 */
export interface GetCryptoRSI200ResponseResults {
    /**
     * 
     * @type {GetCryptoEMA200ResponseResultsUnderlying}
     * @memberof GetCryptoRSI200ResponseResults
     */
    'underlying'?: GetCryptoEMA200ResponseResultsUnderlying;
    /**
     * Timestamp or indicator value.
     * @type {Array<GetCryptoEMA200ResponseResultsValuesInner>}
     * @memberof GetCryptoRSI200ResponseResults
     */
    'values'?: Array<GetCryptoEMA200ResponseResultsValuesInner>;
}
/**
 * 
 * @export
 * @interface GetCryptoSMA200Response
 */
export interface GetCryptoSMA200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetCryptoSMA200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoSMA200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetCryptoSMA200ResponseResults}
     * @memberof GetCryptoSMA200Response
     */
    'results': GetCryptoSMA200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoSMA200Response
     */
    'status': string;
}
/**
 * The results of the SMA indicator calculation.
 * @export
 * @interface GetCryptoSMA200ResponseResults
 */
export interface GetCryptoSMA200ResponseResults {
    /**
     * 
     * @type {GetCryptoEMA200ResponseResultsUnderlying}
     * @memberof GetCryptoSMA200ResponseResults
     */
    'underlying'?: GetCryptoEMA200ResponseResultsUnderlying;
    /**
     * Timestamp or indicator value.
     * @type {Array<GetCryptoEMA200ResponseResultsValuesInner>}
     * @memberof GetCryptoSMA200ResponseResults
     */
    'values'?: Array<GetCryptoEMA200ResponseResultsValuesInner>;
}
/**
 * 
 * @export
 * @interface GetCryptoSnapshotDirection200Response
 */
export interface GetCryptoSnapshotDirection200Response {
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetCryptoSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof GetCryptoSnapshotDirection200Response
     */
    'tickers'?: Array<GetCryptoSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface GetCryptoSnapshotTicker200Response
 */
export interface GetCryptoSnapshotTicker200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoSnapshotTicker200Response
     */
    'status': string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoSnapshotTicker200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetCryptoSnapshotTicker200ResponseAllOfTicker}
     * @memberof GetCryptoSnapshotTicker200Response
     */
    'ticker'?: GetCryptoSnapshotTicker200ResponseAllOfTicker;
}
/**
 * Contains the requested snapshot data for the specified ticker.
 * @export
 * @interface GetCryptoSnapshotTicker200ResponseAllOfTicker
 */
export interface GetCryptoSnapshotTicker200ResponseAllOfTicker {
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'day': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://massive.com/contact\">contact us</a>.
     * @type {number}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'fmv'?: number;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'lastTrade': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'min': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'prevDay': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'ticker': string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'todaysChange': number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'todaysChangePerc': number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof GetCryptoSnapshotTicker200ResponseAllOfTicker
     */
    'updated': number;
}
/**
 * 
 * @export
 * @interface GetCryptoSnapshotTickers200Response
 */
export interface GetCryptoSnapshotTickers200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoSnapshotTickers200Response
     */
    'status': string;
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetCryptoSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof GetCryptoSnapshotTickers200Response
     */
    'tickers'?: Array<GetCryptoSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface GetCryptoSnapshotTickers200ResponseAllOfTickersInner
 */
export interface GetCryptoSnapshotTickers200ResponseAllOfTickersInner {
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'day': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://massive.com/contact\">contact us</a>.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'fmv'?: number;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'lastTrade': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'min': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'prevDay': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'ticker': string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'todaysChange': number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'todaysChangePerc': number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInner
     */
    'updated': number;
}
/**
 * The most recent daily bar for this ticker.
 * @export
 * @interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay
 */
export interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'vw': number;
}
/**
 * The most recent trade for this ticker.
 * @export
 * @interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade
 */
export interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade {
    /**
     * The trade conditions.
     * @type {Array<number>}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'c': Array<number>;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'p': number;
    /**
     * The size (volume) of the trade.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    's': number;
    /**
     * The millisecond accuracy timestamp. This is the timestamp of when the trade was generated at the exchange.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    't': number;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://massive.com/docs/rest/crypto/market-operations/exchanges\">Exchanges</a> for a mapping of exchanges to IDs. 
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'x': number;
}
/**
 * The most recent minute bar for this ticker.
 * @export
 * @interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
 */
export interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'vw': number;
}
/**
 * The previous day\'s bar for this ticker.
 * @export
 * @interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay
 */
export interface GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface GetCryptoTrades200Response
 */
export interface GetCryptoTrades200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetCryptoTrades200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoTrades200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetCryptoTrades200ResponseResultsInner>}
     * @memberof GetCryptoTrades200Response
     */
    'results'?: Array<GetCryptoTrades200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoTrades200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetCryptoTrades200ResponseResultsInner
 */
export interface GetCryptoTrades200ResponseResultsInner {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetCryptoTrades200ResponseResultsInner
     */
    'conditions'?: Array<number>;
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/crypto/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetCryptoTrades200ResponseResultsInner
     */
    'exchange': number;
    /**
     * The Trade ID which uniquely identifies a trade on the exchange that the trade happened on.
     * @type {string}
     * @memberof GetCryptoTrades200ResponseResultsInner
     */
    'id'?: string;
    /**
     * The nanosecond Exchange Unix Timestamp. This is the timestamp of when the trade was generated at the exchange.
     * @type {number}
     * @memberof GetCryptoTrades200ResponseResultsInner
     */
    'participant_timestamp'?: number;
    /**
     * The price of the trade in the base currency of the crypto pair.
     * @type {number}
     * @memberof GetCryptoTrades200ResponseResultsInner
     */
    'price': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof GetCryptoTrades200ResponseResultsInner
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface GetCryptoV1Exchanges200Response
 */
export interface GetCryptoV1Exchanges200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetCryptoV1Exchanges200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCryptoV1Exchanges200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetCryptoV1Exchanges200ResponseResultsInner>}
     * @memberof GetCryptoV1Exchanges200Response
     */
    'results': Array<GetCryptoV1Exchanges200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCryptoV1Exchanges200Response
     */
    'status': GetCryptoV1Exchanges200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetCryptoV1Exchanges200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetCryptoV1Exchanges200ResponseResultsInner
 */
export interface GetCryptoV1Exchanges200ResponseResultsInner {
    /**
     * Numeric identifier for the cryptocurrency exchange or trading platform.
     * @type {string}
     * @memberof GetCryptoV1Exchanges200ResponseResultsInner
     */
    'id': string;
    /**
     * Full official name of the cryptocurrency exchange or digital asset trading platform.
     * @type {string}
     * @memberof GetCryptoV1Exchanges200ResponseResultsInner
     */
    'name': string;
    /**
     * Type of crypto venue - \'exchange\' for cryptocurrency exchanges and digital asset trading platforms.
     * @type {string}
     * @memberof GetCryptoV1Exchanges200ResponseResultsInner
     */
    'type': string;
    /**
     * Official website URL of the cryptocurrency exchange.
     * @type {string}
     * @memberof GetCryptoV1Exchanges200ResponseResultsInner
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface GetCurrencyConversion200Response
 */
export interface GetCurrencyConversion200Response {
    /**
     * The result of the conversion.
     * @type {number}
     * @memberof GetCurrencyConversion200Response
     */
    'converted': number;
    /**
     * The \"from\" currency symbol.
     * @type {string}
     * @memberof GetCurrencyConversion200Response
     */
    'from': string;
    /**
     * The amount to convert.
     * @type {number}
     * @memberof GetCurrencyConversion200Response
     */
    'initialAmount': number;
    /**
     * 
     * @type {GetCurrencyConversion200ResponseLast}
     * @memberof GetCurrencyConversion200Response
     */
    'last'?: GetCurrencyConversion200ResponseLast;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetCurrencyConversion200Response
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetCurrencyConversion200Response
     */
    'status': string;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof GetCurrencyConversion200Response
     */
    'symbol': string;
    /**
     * The \"to\" currency symbol.
     * @type {string}
     * @memberof GetCurrencyConversion200Response
     */
    'to': string;
}
/**
 * Contains the requested quote data for the specified forex currency pair.
 * @export
 * @interface GetCurrencyConversion200ResponseLast
 */
export interface GetCurrencyConversion200ResponseLast {
    /**
     * The ask price.
     * @type {number}
     * @memberof GetCurrencyConversion200ResponseLast
     */
    'ask': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetCurrencyConversion200ResponseLast
     */
    'bid': number;
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/forex/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetCurrencyConversion200ResponseLast
     */
    'exchange': number;
    /**
     * The Unix millisecond timestamp.
     * @type {number}
     * @memberof GetCurrencyConversion200ResponseLast
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface GetEtfGlobalV1Analytics200Response
 */
export interface GetEtfGlobalV1Analytics200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetEtfGlobalV1Analytics200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetEtfGlobalV1Analytics200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetEtfGlobalV1Analytics200ResponseResultsInner>}
     * @memberof GetEtfGlobalV1Analytics200Response
     */
    'results': Array<GetEtfGlobalV1Analytics200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetEtfGlobalV1Analytics200Response
     */
    'status': GetEtfGlobalV1Analytics200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetEtfGlobalV1Analytics200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetEtfGlobalV1Analytics200ResponseResultsInner
 */
export interface GetEtfGlobalV1Analytics200ResponseResultsInner {
    /**
     * The stock ticker symbol used to identify this ETF product on exchanges.
     * @type {string}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'composite_ticker'?: string;
    /**
     * The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
     * @type {string}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'effective_date'?: string;
    /**
     * The date showing when ETF Global received and processed the data.
     * @type {string}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'processed_date'?: string;
    /**
     * Behavioral analysis score measuring investor psychology and market behavior patterns.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_composite_behavioral'?: number;
    /**
     * Overall fundamental analysis score combining P/E, P/CF, P/B, and dividend yield metrics.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_composite_fundamental'?: number;
    /**
     * Overall global theme score combining sector and country analysis for macro investment views.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_composite_global'?: number;
    /**
     * Overall quality assessment score combining liquidity, diversification, and issuing firm factors.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_composite_quality'?: number;
    /**
     * Overall market sentiment score combining put/call ratios, short interest, and implied volatility.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_composite_sentiment'?: number;
    /**
     * Combined technical analysis score aggregating short, intermediate, and long-term technical factors.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_composite_technical'?: number;
    /**
     * Fundamental analysis score based on dividend yields of the ETF\'s underlying securities.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_fundamental_div'?: number;
    /**
     * Fundamental analysis score based on price-to-book value ratios of the ETF\'s holdings.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_fundamental_pb'?: number;
    /**
     * Fundamental analysis score based on price-to-cash-flow ratios of the ETF\'s underlying assets.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_fundamental_pcf'?: number;
    /**
     * Fundamental analysis score based on price-to-earnings ratios of the ETF\'s underlying holdings.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_fundamental_pe'?: number;
    /**
     * Quantitative score analyzing global country themes and country-specific market factors.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_global_country'?: number;
    /**
     * Quantitative score analyzing global sector themes and sector-specific performance factors.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_global_sector'?: number;
    /**
     * Letter grade summarizing the ETF\'s overall quantitative assessment, where A = 71-100, B = 56-70, etc.
     * @type {string}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_grade'?: string;
    /**
     * Quality assessment score evaluating the diversification benefits and risk distribution of the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_quality_diversification'?: number;
    /**
     * Quality assessment score evaluating the reputation and capabilities of the ETF\'s issuing firm.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_quality_firm'?: number;
    /**
     * Quality assessment score measuring the liquidity characteristics and trading ease of the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_quality_liquidity'?: number;
    /**
     * Market sentiment score derived from implied volatility levels in options markets.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_sentiment_iv'?: number;
    /**
     * Market sentiment score derived from put/call option ratios and options activity.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_sentiment_pc'?: number;
    /**
     * Market sentiment score based on short interest levels and short selling activity.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_sentiment_si'?: number;
    /**
     * Intermediate-term technical analysis score evaluating medium-term price trends.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_technical_it'?: number;
    /**
     * Long-term technical analysis score assessing extended price trend patterns.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_technical_lt'?: number;
    /**
     * Short-term technical analysis score based on recent price movements and trading patterns.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_technical_st'?: number;
    /**
     * ETF Global\'s comprehensive quantitative analysis score combining all quantitative factors.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'quant_total_score'?: number;
    /**
     * ETF Global\'s proprietary Green Diamond score measuring the potential reward and return prospects of the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'reward_score'?: number;
    /**
     * A component score assessing country-specific risks based on the ETF\'s geographic exposure.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'risk_country'?: number;
    /**
     * A component score measuring how much the ETF deviates from expected performance.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'risk_deviation'?: number;
    /**
     * A component score assessing the operational efficiency and cost-effectiveness of the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'risk_efficiency'?: number;
    /**
     * A component score measuring the liquidity risk and ease of trading the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'risk_liquidity'?: number;
    /**
     * A component score evaluating risks related to the ETF\'s structural design and mechanics.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'risk_structure'?: number;
    /**
     * ETF Global\'s proprietary Red Diamond overall risk assessment score for the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'risk_total_score'?: number;
    /**
     * A component score measuring the volatility risk of the ETF\'s price movements.
     * @type {number}
     * @memberof GetEtfGlobalV1Analytics200ResponseResultsInner
     */
    'risk_volatility'?: number;
}
/**
 * 
 * @export
 * @interface GetEtfGlobalV1Constituents200Response
 */
export interface GetEtfGlobalV1Constituents200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetEtfGlobalV1Constituents200ResponseResultsInner>}
     * @memberof GetEtfGlobalV1Constituents200Response
     */
    'results': Array<GetEtfGlobalV1Constituents200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200Response
     */
    'status': GetEtfGlobalV1Constituents200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetEtfGlobalV1Constituents200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetEtfGlobalV1Constituents200ResponseResultsInner
 */
export interface GetEtfGlobalV1Constituents200ResponseResultsInner {
    /**
     * The broad category of asset type, such as Equity, Corporate Bond, Municipal Bond, etc.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'asset_class'?: string;
    /**
     * The stock ticker symbol of the ETF that holds these constituent securities.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'composite_ticker'?: string;
    /**
     * The full company or security name of the constituent holding.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'constituent_name'?: string;
    /**
     * The stock ticker symbol of the individual security held within the ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'constituent_ticker'?: string;
    /**
     * The country where the exchange that lists this constituent security is located.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'country_of_exchange'?: string;
    /**
     * The local currency in which this constituent security is denominated and traded.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'currency_traded'?: string;
    /**
     * The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'effective_date'?: string;
    /**
     * The name of the stock exchange where this constituent security is primarily traded.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'exchange'?: string;
    /**
     * The Financial Instrument Global Identifier, an open standard for uniquely identifying financial instruments.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'figi'?: string;
    /**
     * The International Securities Identification Number, a global standard for identifying securities.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'isin'?: string;
    /**
     * The total market value of this constituent position held by the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'market_value'?: number;
    /**
     * The date showing when ETF Global received and processed the data.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'processed_date'?: string;
    /**
     * The specific classification of security type using ETF Global\'s taxonomy, such as Common Equity, Domestic, Global, etc.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'security_type'?: string;
    /**
     * The Stock Exchange Daily Official List code, primarily used for securities trading in the UK.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'sedol'?: string;
    /**
     * The number of shares of this constituent security that the ETF currently owns.
     * @type {number}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'shares_held'?: number;
    /**
     * A unique identifier code for the constituent security in US markets.
     * @type {string}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'us_code'?: string;
    /**
     * The percentage weight of this constituent security within the ETF\'s total portfolio.
     * @type {number}
     * @memberof GetEtfGlobalV1Constituents200ResponseResultsInner
     */
    'weight'?: number;
}
/**
 * 
 * @export
 * @interface GetEtfGlobalV1FundFlows200Response
 */
export interface GetEtfGlobalV1FundFlows200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetEtfGlobalV1FundFlows200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetEtfGlobalV1FundFlows200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetEtfGlobalV1FundFlows200ResponseResultsInner>}
     * @memberof GetEtfGlobalV1FundFlows200Response
     */
    'results': Array<GetEtfGlobalV1FundFlows200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetEtfGlobalV1FundFlows200Response
     */
    'status': GetEtfGlobalV1FundFlows200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetEtfGlobalV1FundFlows200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetEtfGlobalV1FundFlows200ResponseResultsInner
 */
export interface GetEtfGlobalV1FundFlows200ResponseResultsInner {
    /**
     * The stock ticker symbol used to identify this ETF on exchanges.
     * @type {string}
     * @memberof GetEtfGlobalV1FundFlows200ResponseResultsInner
     */
    'composite_ticker'?: string;
    /**
     * The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
     * @type {string}
     * @memberof GetEtfGlobalV1FundFlows200ResponseResultsInner
     */
    'effective_date'?: string;
    /**
     * The net daily capital flow into or out of the ETF through the creation and redemption process, where positive values indicate inflows and negative values indicate outflows.
     * @type {number}
     * @memberof GetEtfGlobalV1FundFlows200ResponseResultsInner
     */
    'fund_flow'?: number;
    /**
     * The net asset value per share, representing the per-share value of the ETF\'s underlying holdings.
     * @type {number}
     * @memberof GetEtfGlobalV1FundFlows200ResponseResultsInner
     */
    'nav'?: number;
    /**
     * The date showing when ETF Global received and processed the data.
     * @type {string}
     * @memberof GetEtfGlobalV1FundFlows200ResponseResultsInner
     */
    'processed_date'?: string;
    /**
     * The total number of ETF shares currently issued and outstanding in the market.
     * @type {number}
     * @memberof GetEtfGlobalV1FundFlows200ResponseResultsInner
     */
    'shares_outstanding'?: number;
}
/**
 * 
 * @export
 * @interface GetEtfGlobalV1Profiles200Response
 */
export interface GetEtfGlobalV1Profiles200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetEtfGlobalV1Profiles200ResponseResultsInner>}
     * @memberof GetEtfGlobalV1Profiles200Response
     */
    'results': Array<GetEtfGlobalV1Profiles200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200Response
     */
    'status': GetEtfGlobalV1Profiles200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetEtfGlobalV1Profiles200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetEtfGlobalV1Profiles200ResponseResultsInner
 */
export interface GetEtfGlobalV1Profiles200ResponseResultsInner {
    /**
     * The administrator of the ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'administrator'?: string;
    /**
     * The investment advisor of the ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'advisor'?: string;
    /**
     * The primary type of assets held by the ETF, such as equities, bonds, commodities, or other securities.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'asset_class'?: string;
    /**
     * The total assets under management, representing the current market value of all assets held by the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'aum'?: number;
    /**
     * The average number of shares traded daily over the past month, indicating liquidity and investor interest.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'avg_daily_trading_volume'?: number;
    /**
     * The average intraday bid-ask spread as a percentage, calculated by dividing the spread by the lowest ask price sampled during the day.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'bid_ask_spread'?: number;
    /**
     * Call options volume.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'call_volume'?: number;
    /**
     * The broad investment category that describes the ETF\'s investment focus and strategy.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'category'?: string;
    /**
     * The stock ticker symbol used to identify this ETF product on exchanges.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'composite_ticker'?: string;
    /**
     * Coupon exposure breakdown for fixed income ETFs.
     * @type {Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'coupon_exposure'?: Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>;
    /**
     * The fee for creating new shares of the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'creation_fee'?: number;
    /**
     * The size of creation units for the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'creation_unit_size'?: number;
    /**
     * Currency exposure breakdown of the ETF.
     * @type {Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'currency_exposure'?: Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>;
    /**
     * The custodian of the ETF assets.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'custodian'?: string;
    /**
     * The official name and description of the ETF product.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'description'?: string;
    /**
     * The economic development classification of the markets the ETF invests in, such as developed, emerging, or frontier markets.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'development_class'?: string;
    /**
     * Discount or premium to net asset value.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'discount_premium'?: number;
    /**
     * How frequently the ETF makes distributions.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'distribution_frequency'?: string;
    /**
     * The distributor of the ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'distributor'?: string;
    /**
     * The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'effective_date'?: string;
    /**
     * Any fee waivers applied to the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'fee_waivers'?: number;
    /**
     * The fiscal year end date for the ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'fiscal_year_end'?: string;
    /**
     * The specific investment focus or exposure that the ETF provides, such as sector, geography, or investment style.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'focus'?: string;
    /**
     * The futures commission merchant, if applicable.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'futures_commission_merchant'?: string;
    /**
     * Geographic exposure breakdown of the ETF.
     * @type {Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'geographic_exposure'?: Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>;
    /**
     * The date when this ETF was first launched and became available for trading.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'inception_date'?: string;
    /**
     * Industry exposure breakdown of the ETF.
     * @type {Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'industry_exposure'?: Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>;
    /**
     * Industry group exposure breakdown of the ETF.
     * @type {Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'industry_group_exposure'?: Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>;
    /**
     * The financial institution or fund company that created and sponsors this ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'issuer'?: string;
    /**
     * The lead market maker for the ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'lead_market_maker'?: string;
    /**
     * Indicates whether the ETF uses leverage to amplify returns (\'leveraged\'), or does not use leverage (\'unleveraged\').
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'leverage_style': string;
    /**
     * The leverage multiplier applied by the ETF, where positive numbers indicate leveraged exposure and negative numbers indicate inverse exposure.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'levered_amount'?: number;
    /**
     * The primary exchange where the ETF is listed.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'listing_exchange'?: string;
    /**
     * Defines whether an ETF is considered active under SEC rules, with managers making investment decisions, or passive, tracking an index.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'management_classification': string;
    /**
     * The annual fee charged by the fund manager for managing the ETF\'s portfolio and operations.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'management_fee'?: number;
    /**
     * Maturity exposure breakdown for fixed income ETFs.
     * @type {Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'maturity_exposure'?: Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>;
    /**
     * Net expenses after waivers.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'net_expenses'?: number;
    /**
     * Number of holdings in the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'num_holdings'?: number;
    /**
     * Availability of options on the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'options_available'?: number;
    /**
     * Options trading volume for the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'options_volume'?: number;
    /**
     * Other expenses charged by the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'other_expenses'?: number;
    /**
     * The portfolio manager of the ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'portfolio_manager'?: string;
    /**
     * The main index or benchmark that this ETF is designed to track or replicate.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'primary_benchmark'?: string;
    /**
     * The date showing when ETF Global received and processed the data.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'processed_date'?: string;
    /**
     * Indicates whether the product is an Exchange-Traded Note (\'etn\') or an Exchange-Traded Fund (\'etf\').
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'product_type': string;
    /**
     * Put/call ratio for options on the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'put_call_ratio'?: number;
    /**
     * Put options volume.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'put_volume'?: number;
    /**
     * The geographic region or area of the world where the ETF concentrates its investments.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'region'?: string;
    /**
     * Sector exposure breakdown of the ETF.
     * @type {Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'sector_exposure'?: Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>;
    /**
     * Short interest in the ETF.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'short_interest'?: number;
    /**
     * The subadvisor of the ETF, if applicable.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'subadvisor'?: string;
    /**
     * Sub-industry exposure breakdown of the ETF.
     * @type {Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'subindustry_exposure'?: Array<GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner>;
    /**
     * The tax structure of the ETF, determining whether investors receive 1099 or K1 tax forms (RIC, Partnership, or UIT).
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'tax_classification'?: string;
    /**
     * The total annual expense ratio of the ETF, including all fees and costs passed on to investors.
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'total_expenses'?: number;
    /**
     * The transfer agent for the ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'transfer_agent'?: string;
    /**
     * The trustee of the ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInner
     */
    'trustee'?: string;
}
/**
 * 
 * @export
 * @interface GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner
 */
export interface GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner {
    /**
     * 
     * @type {string}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner
     */
    'key': string;
    /**
     * 
     * @type {number}
     * @memberof GetEtfGlobalV1Profiles200ResponseResultsInnerCouponExposureInner
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface GetEtfGlobalV1Taxonomies200Response
 */
export interface GetEtfGlobalV1Taxonomies200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetEtfGlobalV1Taxonomies200ResponseResultsInner>}
     * @memberof GetEtfGlobalV1Taxonomies200Response
     */
    'results': Array<GetEtfGlobalV1Taxonomies200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200Response
     */
    'status': GetEtfGlobalV1Taxonomies200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetEtfGlobalV1Taxonomies200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetEtfGlobalV1Taxonomies200ResponseResultsInner
 */
export interface GetEtfGlobalV1Taxonomies200ResponseResultsInner {
    /**
     * The primary type of assets held by the ETF, such as equities, bonds, commodities, or other securities.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'asset_class'?: string;
    /**
     * The broad investment category that describes the ETF\'s investment focus and strategy.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'category'?: string;
    /**
     * The stock ticker symbol used to identify this ETF product on exchanges.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'composite_ticker'?: string;
    /**
     * The specific country focus of the ETF, if applicable.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'country'?: string;
    /**
     * Credit quality rating for fixed income ETFs.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'credit_quality_rating'?: string;
    /**
     * The official name and description of the ETF product.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'description'?: string;
    /**
     * The economic development classification of the markets the ETF invests in, such as developed, emerging, or frontier markets.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'development_class'?: string;
    /**
     * The duration characteristics for fixed income ETFs.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'duration'?: string;
    /**
     * The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'effective_date'?: string;
    /**
     * Environmental, Social, and Governance characteristics.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'esg'?: string;
    /**
     * The mechanism used to achieve exposure.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'exposure_mechanism'?: string;
    /**
     * Factor exposure characteristics of the ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'factor'?: string;
    /**
     * The specific investment focus or exposure that the ETF provides, such as sector, geography, or investment style.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'focus'?: string;
    /**
     * The frequency of hedge reset, if applicable.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'hedge_reset'?: string;
    /**
     * How frequently holdings are disclosed.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'holdings_disclosure_frequency'?: string;
    /**
     * The date when this ETF was first launched and became available for trading.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'inception_date'?: string;
    /**
     * The International Securities Identification Number, a global standard code for uniquely identifying this ETF worldwide.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'isin'?: string;
    /**
     * The financial institution or fund company that created and sponsors this ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'issuer'?: string;
    /**
     * The frequency of leverage reset, if applicable.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'leverage_reset'?: string;
    /**
     * Indicates whether the ETF uses leverage to amplify returns (\'leveraged\'), or does not use leverage (\'unleveraged\').
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'leverage_style': string;
    /**
     * The leverage multiplier applied by the ETF, where positive numbers indicate leveraged exposure and negative numbers indicate inverse exposure.
     * @type {number}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'levered_amount'?: number;
    /**
     * Defines whether an ETF is considered active under SEC rules, with managers making investment decisions, or passive, tracking an index.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'management_classification': string;
    /**
     * Indicates whether an ETF is managed actively or passively, and the level of transparency or replication method used.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'management_style'?: string;
    /**
     * The maturity profile for fixed income ETFs.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'maturity'?: string;
    /**
     * The primary investment objective of the ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'objective'?: string;
    /**
     * The main index or benchmark that this ETF is designed to track or replicate.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'primary_benchmark'?: string;
    /**
     * The date showing when ETF Global received and processed the data.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'processed_date'?: string;
    /**
     * Indicates whether the product is an Exchange-Traded Note (\'etn\') or an Exchange-Traded Fund (\'etf\').
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'product_type': string;
    /**
     * How frequently the ETF rebalances its holdings.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'rebalance_frequency'?: string;
    /**
     * How frequently the index is reconstituted.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'reconstitution_frequency'?: string;
    /**
     * The geographic region or area of the world where the ETF concentrates its investments.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'region'?: string;
    /**
     * The secondary investment objective, if applicable.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'secondary_objective'?: string;
    /**
     * The methodology used to select securities.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'selection_methodology'?: string;
    /**
     * The universe from which securities are selected.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'selection_universe'?: string;
    /**
     * The strategic investment focus of the ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'strategic_focus'?: string;
    /**
     * The targeted investment focus of the ETF.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'targeted_focus'?: string;
    /**
     * The tax structure of the ETF, determining whether investors receive 1099 or K1 tax forms (RIC, Partnership, or UIT).
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'tax_classification'?: string;
    /**
     * A unique identifier code that identifies this ETF in US markets.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'us_code'?: string;
    /**
     * The methodology used to weight holdings.
     * @type {string}
     * @memberof GetEtfGlobalV1Taxonomies200ResponseResultsInner
     */
    'weighting_methodology'?: string;
}
/**
 * 
 * @export
 * @interface GetEvents200Response
 */
export interface GetEvents200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetEvents200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {GetEvents200ResponseResults}
     * @memberof GetEvents200Response
     */
    'results'?: GetEvents200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetEvents200Response
     */
    'status'?: string;
}
/**
 * Contains the requested event data for the specified ticker.
 * @export
 * @interface GetEvents200ResponseResults
 */
export interface GetEvents200ResponseResults {
    /**
     * An array of event containing the requested data.
     * @type {Array<GetEvents200ResponseResultsEventsInner>}
     * @memberof GetEvents200ResponseResults
     */
    'events'?: Array<GetEvents200ResponseResultsEventsInner>;
    /**
     * The name of the asset.
     * @type {string}
     * @memberof GetEvents200ResponseResults
     */
    'name'?: string;
}
/**
 * @type GetEvents200ResponseResultsEventsInner
 * @export
 */
export type GetEvents200ResponseResultsEventsInner = GetEvents200ResponseResultsEventsInnerOneOf;

/**
 * 
 * @export
 * @interface GetEvents200ResponseResultsEventsInnerOneOf
 */
export interface GetEvents200ResponseResultsEventsInnerOneOf {
    /**
     * The date the event took place
     * @type {string}
     * @memberof GetEvents200ResponseResultsEventsInnerOneOf
     */
    'date': string;
    /**
     * The type of historical event for the asset
     * @type {string}
     * @memberof GetEvents200ResponseResultsEventsInnerOneOf
     */
    'event_type': string;
    /**
     * 
     * @type {GetEvents200ResponseResultsEventsInnerOneOfTickerChange}
     * @memberof GetEvents200ResponseResultsEventsInnerOneOf
     */
    'ticker_change'?: GetEvents200ResponseResultsEventsInnerOneOfTickerChange;
}
/**
 * Details about a ticker change
 * @export
 * @interface GetEvents200ResponseResultsEventsInnerOneOfTickerChange
 */
export interface GetEvents200ResponseResultsEventsInnerOneOfTickerChange {
    /**
     * A ticker symbol
     * @type {string}
     * @memberof GetEvents200ResponseResultsEventsInnerOneOfTickerChange
     */
    'ticker'?: string;
}
/**
 * 
 * @export
 * @interface GetFedV1Inflation200Response
 */
export interface GetFedV1Inflation200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetFedV1Inflation200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetFedV1Inflation200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetFedV1Inflation200ResponseResultsInner>}
     * @memberof GetFedV1Inflation200Response
     */
    'results': Array<GetFedV1Inflation200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFedV1Inflation200Response
     */
    'status': GetFedV1Inflation200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetFedV1Inflation200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetFedV1Inflation200ResponseResultsInner
 */
export interface GetFedV1Inflation200ResponseResultsInner {
    /**
     * Consumer Price Index (CPI) for All Urban Consumers  a standard measure of headline inflation based on a fixed basket of goods and services, not seasonally adjusted.
     * @type {number}
     * @memberof GetFedV1Inflation200ResponseResultsInner
     */
    'cpi'?: number;
    /**
     * Core Consumer Price Index  the CPI excluding food and energy, used to understand underlying inflation trends without short-term volatility.
     * @type {number}
     * @memberof GetFedV1Inflation200ResponseResultsInner
     */
    'cpi_core'?: number;
    /**
     * Year-over-year percentage change in the headline CPI  the most commonly cited inflation rate in public discourse and economic policy.
     * @type {number}
     * @memberof GetFedV1Inflation200ResponseResultsInner
     */
    'cpi_year_over_year'?: number;
    /**
     * Calendar date of the observation (YYYYMMDD).
     * @type {string}
     * @memberof GetFedV1Inflation200ResponseResultsInner
     */
    'date'?: string;
    /**
     * Personal Consumption Expenditures (PCE) Price Index  a broader measure of inflation used by the Federal Reserve, reflecting actual consumer spending patterns and updated basket weights.
     * @type {number}
     * @memberof GetFedV1Inflation200ResponseResultsInner
     */
    'pce'?: number;
    /**
     * Core PCE Price Index  excludes food and energy prices from the PCE index, and is the Fed\'s preferred measure of underlying inflation.
     * @type {number}
     * @memberof GetFedV1Inflation200ResponseResultsInner
     */
    'pce_core'?: number;
    /**
     * Nominal Personal Consumption Expenditures  total dollar value of consumer spending in the U.S. economy, reported in billions of dollars and not adjusted for inflation.
     * @type {number}
     * @memberof GetFedV1Inflation200ResponseResultsInner
     */
    'pce_spending'?: number;
}
/**
 * 
 * @export
 * @interface GetFedV1InflationExpectations200Response
 */
export interface GetFedV1InflationExpectations200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetFedV1InflationExpectations200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetFedV1InflationExpectations200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetFedV1InflationExpectations200ResponseResultsInner>}
     * @memberof GetFedV1InflationExpectations200Response
     */
    'results': Array<GetFedV1InflationExpectations200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFedV1InflationExpectations200Response
     */
    'status': GetFedV1InflationExpectations200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetFedV1InflationExpectations200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetFedV1InflationExpectations200ResponseResultsInner
 */
export interface GetFedV1InflationExpectations200ResponseResultsInner {
    /**
     * Calendar date of the observation (YYYYMMDD).
     * @type {string}
     * @memberof GetFedV1InflationExpectations200ResponseResultsInner
     */
    'date'?: string;
    /**
     * 5-Year, 5-Year Forward Inflation Expectation Rate  the market\'s expectation of average annual inflation for the 5-year period beginning 5 years from now, based on the spread between forward nominal and real yields.
     * @type {number}
     * @memberof GetFedV1InflationExpectations200ResponseResultsInner
     */
    'forward_years_5_to_10'?: number;
    /**
     * 10-Year Breakeven Inflation Rate  the market\'s expectation of average annual inflation over the next 10 years, based on the spread between 10-year nominal Treasury yields and 10-year TIPS yields.
     * @type {number}
     * @memberof GetFedV1InflationExpectations200ResponseResultsInner
     */
    'market_10_year'?: number;
    /**
     * 5-Year Breakeven Inflation Rate  the market\'s expectation of average annual inflation over the next 5 years, based on the spread between 5-year nominal Treasury yields and 5-year TIPS yields.
     * @type {number}
     * @memberof GetFedV1InflationExpectations200ResponseResultsInner
     */
    'market_5_year'?: number;
    /**
     * The Cleveland Feds 10-year inflation expectations data estimated expected inflation, risk premiums, and the real interest rate using a model based on Treasury yields, inflation data, swaps, and surveys.
     * @type {number}
     * @memberof GetFedV1InflationExpectations200ResponseResultsInner
     */
    'model_10_year'?: number;
    /**
     * The Cleveland Feds 1-year inflation expectations data estimated expected inflation, risk premiums, and the real interest rate using a model based on Treasury yields, inflation data, swaps, and surveys.
     * @type {number}
     * @memberof GetFedV1InflationExpectations200ResponseResultsInner
     */
    'model_1_year'?: number;
    /**
     * The Cleveland Feds 30-year inflation expectations data estimated expected inflation, risk premiums, and the real interest rate using a model based on Treasury yields, inflation data, swaps, and surveys.
     * @type {number}
     * @memberof GetFedV1InflationExpectations200ResponseResultsInner
     */
    'model_30_year'?: number;
    /**
     * The Cleveland Feds 5-year inflation expectations data estimated expected inflation, risk premiums, and the real interest rate using a model based on Treasury yields, inflation data, swaps, and surveys.
     * @type {number}
     * @memberof GetFedV1InflationExpectations200ResponseResultsInner
     */
    'model_5_year'?: number;
}
/**
 * 
 * @export
 * @interface GetFedV1TreasuryYields200Response
 */
export interface GetFedV1TreasuryYields200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetFedV1TreasuryYields200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetFedV1TreasuryYields200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetFedV1TreasuryYields200ResponseResultsInner>}
     * @memberof GetFedV1TreasuryYields200Response
     */
    'results': Array<GetFedV1TreasuryYields200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFedV1TreasuryYields200Response
     */
    'status': GetFedV1TreasuryYields200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetFedV1TreasuryYields200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetFedV1TreasuryYields200ResponseResultsInner
 */
export interface GetFedV1TreasuryYields200ResponseResultsInner {
    /**
     * Calendar date of the yield observation (YYYY-MM-DD).
     * @type {string}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'date'?: string;
    /**
     * Market Yield on U.S. Treasury Securities at 10-Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_10_year'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 1-Month Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_1_month'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 1-Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_1_year'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 20-Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_20_year'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 2-Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_2_year'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 30-Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_30_year'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 3-Month Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_3_month'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 3-Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_3_year'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 5-Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_5_year'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 6-Month Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_6_month'?: number;
    /**
     * Market Yield on U.S. Treasury Securities at 7-Year Constant Maturity, Quoted on an Investment Basis
     * @type {number}
     * @memberof GetFedV1TreasuryYields200ResponseResultsInner
     */
    'yield_7_year'?: number;
}
/**
 * 
 * @export
 * @interface GetForexQuotes200Response
 */
export interface GetForexQuotes200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetForexQuotes200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetForexQuotes200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetForexQuotes200ResponseResultsInner>}
     * @memberof GetForexQuotes200Response
     */
    'results'?: Array<GetForexQuotes200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetForexQuotes200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetForexQuotes200ResponseResultsInner
 */
export interface GetForexQuotes200ResponseResultsInner {
    /**
     * The ask exchange ID
     * @type {number}
     * @memberof GetForexQuotes200ResponseResultsInner
     */
    'ask_exchange'?: number;
    /**
     * The ask price.
     * @type {number}
     * @memberof GetForexQuotes200ResponseResultsInner
     */
    'ask_price'?: number;
    /**
     * The bid exchange ID
     * @type {number}
     * @memberof GetForexQuotes200ResponseResultsInner
     */
    'bid_exchange'?: number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetForexQuotes200ResponseResultsInner
     */
    'bid_price'?: number;
    /**
     * The nanosecond Exchange Unix Timestamp. This is the timestamp of when the quote was generated at the exchange.
     * @type {number}
     * @memberof GetForexQuotes200ResponseResultsInner
     */
    'participant_timestamp': number;
}
/**
 * 
 * @export
 * @interface GetForexSnapshotTicker200Response
 */
export interface GetForexSnapshotTicker200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetForexSnapshotTicker200Response
     */
    'status': string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetForexSnapshotTicker200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetForexSnapshotTicker200ResponseAllOfTicker}
     * @memberof GetForexSnapshotTicker200Response
     */
    'ticker'?: GetForexSnapshotTicker200ResponseAllOfTicker;
}
/**
 * Contains the requested snapshot data for the specified ticker.
 * @export
 * @interface GetForexSnapshotTicker200ResponseAllOfTicker
 */
export interface GetForexSnapshotTicker200ResponseAllOfTicker {
    /**
     * 
     * @type {GetForexSnapshotTickers200ResponseAllOfTickersInnerDay}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'day': GetForexSnapshotTickers200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://massive.com/contact\">contact us</a>.
     * @type {number}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'fmv'?: number;
    /**
     * 
     * @type {GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'lastQuote': GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote;
    /**
     * 
     * @type {GetForexSnapshotTickers200ResponseAllOfTickersInnerMin}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'min': GetForexSnapshotTickers200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'prevDay': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'ticker': string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'todaysChange': number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'todaysChangePerc': number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof GetForexSnapshotTicker200ResponseAllOfTicker
     */
    'updated': number;
}
/**
 * 
 * @export
 * @interface GetForexSnapshotTickers200Response
 */
export interface GetForexSnapshotTickers200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetForexSnapshotTickers200Response
     */
    'status': string;
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetForexSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof GetForexSnapshotTickers200Response
     */
    'tickers'?: Array<GetForexSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface GetForexSnapshotTickers200ResponseAllOfTickersInner
 */
export interface GetForexSnapshotTickers200ResponseAllOfTickersInner {
    /**
     * 
     * @type {GetForexSnapshotTickers200ResponseAllOfTickersInnerDay}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'day': GetForexSnapshotTickers200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://massive.com/contact\">contact us</a>.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'fmv'?: number;
    /**
     * 
     * @type {GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'lastQuote': GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote;
    /**
     * 
     * @type {GetForexSnapshotTickers200ResponseAllOfTickersInnerMin}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'min': GetForexSnapshotTickers200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'prevDay': GetCryptoSnapshotTickers200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'ticker': string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'todaysChange': number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'todaysChangePerc': number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInner
     */
    'updated': number;
}
/**
 * The most recent daily bar for this ticker.
 * @export
 * @interface GetForexSnapshotTickers200ResponseAllOfTickersInnerDay
 */
export interface GetForexSnapshotTickers200ResponseAllOfTickersInnerDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'v': number;
}
/**
 * The most recent quote for this ticker.
 * @export
 * @interface GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote
 */
export interface GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    'a': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    'b': number;
    /**
     * The millisecond accuracy timestamp of the quote.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    't': number;
    /**
     * The exchange ID on which this quote happened.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    'x': number;
}
/**
 * The most recent minute bar for this ticker.
 * @export
 * @interface GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
 */
export interface GetForexSnapshotTickers200ResponseAllOfTickersInnerMin {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'c'?: number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'h'?: number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'l'?: number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'o'?: number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    't'?: number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetForexSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'v'?: number;
}
/**
 * 
 * @export
 * @interface GetForexV1Exchanges200Response
 */
export interface GetForexV1Exchanges200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetForexV1Exchanges200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetForexV1Exchanges200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetForexV1Exchanges200ResponseResultsInner>}
     * @memberof GetForexV1Exchanges200Response
     */
    'results': Array<GetForexV1Exchanges200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetForexV1Exchanges200Response
     */
    'status': GetForexV1Exchanges200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetForexV1Exchanges200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetForexV1Exchanges200ResponseResultsInner
 */
export interface GetForexV1Exchanges200ResponseResultsInner {
    /**
     * Numeric identifier for the forex trading venue or institution.
     * @type {string}
     * @memberof GetForexV1Exchanges200ResponseResultsInner
     */
    'id': string;
    /**
     * Full name of the foreign exchange trading venue, platform, or financial institution.
     * @type {string}
     * @memberof GetForexV1Exchanges200ResponseResultsInner
     */
    'name': string;
    /**
     * Type of forex venue - \'exchange\' for electronic trading platforms and institutional trading venues.
     * @type {string}
     * @memberof GetForexV1Exchanges200ResponseResultsInner
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface GetFuturesAggregates200Response
 */
export interface GetFuturesAggregates200Response {
    /**
     * If present, the URL to the next page of results.
     * @type {string}
     * @memberof GetFuturesAggregates200Response
     */
    'next_url'?: string;
    /**
     * 
     * @type {Array<GetFuturesAggregates200ResponseResultsInner>}
     * @memberof GetFuturesAggregates200Response
     */
    'results': Array<GetFuturesAggregates200ResponseResultsInner>;
    /**
     * The status of the response.
     * @type {string}
     * @memberof GetFuturesAggregates200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetFuturesAggregates200ResponseResultsInner
 */
export interface GetFuturesAggregates200ResponseResultsInner {
    /**
     * The last price within the timeframe.
     * @type {number}
     * @memberof GetFuturesAggregates200ResponseResultsInner
     */
    'close': number;
    /**
     * The total dollar volume of the transactions that occurred within the timeframe.
     * @type {number}
     * @memberof GetFuturesAggregates200ResponseResultsInner
     */
    'dollar_volume': number;
    /**
     * The highest price within the timeframe.
     * @type {number}
     * @memberof GetFuturesAggregates200ResponseResultsInner
     */
    'high': number;
    /**
     * The lowest price within the timeframe.
     * @type {number}
     * @memberof GetFuturesAggregates200ResponseResultsInner
     */
    'low': number;
    /**
     * The opening price within the timeframe.
     * @type {number}
     * @memberof GetFuturesAggregates200ResponseResultsInner
     */
    'open': number;
    /**
     * Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
     * @type {string}
     * @memberof GetFuturesAggregates200ResponseResultsInner
     */
    'session_end_date': string;
    /**
     * The price the contract would have cost to settle for this session.
     * @type {number}
     * @memberof GetFuturesAggregates200ResponseResultsInner
     */
    'settlement_price'?: number;
    /**
     * The ticker for the contract.
     * @type {string}
     * @memberof GetFuturesAggregates200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The number of transactions that occurred within the timeframe.
     * @type {number}
     * @memberof GetFuturesAggregates200ResponseResultsInner
     */
    'transactions': number;
    /**
     * The number of contracts that traded within the timeframe.
     * @type {number}
     * @memberof GetFuturesAggregates200ResponseResultsInner
     */
    'volume': number;
    /**
     * The timestamp of the beginning of the candlesticks aggregation window.
     * @type {number}
     * @memberof GetFuturesAggregates200ResponseResultsInner
     */
    'window_start': number;
}
/**
 * 
 * @export
 * @interface GetFuturesContractDetails200Response
 */
export interface GetFuturesContractDetails200Response {
    /**
     * A unique identifier for this request.
     * @type {string}
     * @memberof GetFuturesContractDetails200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetFuturesContracts200ResponseResultsInner}
     * @memberof GetFuturesContractDetails200Response
     */
    'results'?: GetFuturesContracts200ResponseResultsInner;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFuturesContractDetails200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetFuturesContracts200Response
 */
export interface GetFuturesContracts200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetFuturesContracts200Response
     */
    'next_url'?: string;
    /**
     * A unique identifier for this request.
     * @type {string}
     * @memberof GetFuturesContracts200Response
     */
    'request_id': string;
    /**
     * 
     * @type {Array<GetFuturesContracts200ResponseResultsInner>}
     * @memberof GetFuturesContracts200Response
     */
    'results'?: Array<GetFuturesContracts200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFuturesContracts200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetFuturesContracts200ResponseResultsInner
 */
export interface GetFuturesContracts200ResponseResultsInner {
    /**
     * Whether or not this contract was tradeable at the given point-in-time specified in the \'as_of\' attribute (a contract was active if the given day was after the \'first_trade_date\' and before the \'last_trade_date\').
     * @type {boolean}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'active': boolean;
    /**
     * The point-in-time date for the given contract - e.g. if \'as_of\' is set to 2021-04-25, then the data retrieved describes the contract(s) as of 2021-04-25.
     * @type {string}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'as_of'?: string;
    /**
     * The number of days until this contract matures (since the point-in-time date). Note that the absence of this field means there are 0 days until maturity.
     * @type {number}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'days_to_maturity'?: number;
    /**
     * The date on which this contract first became tradeable.
     * @type {string}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'first_trade_date': string;
    /**
     * The date on which this contract last became tradeable.
     * @type {string}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'last_trade_date': string;
    /**
     * This field provides the calendar month reflected in the instrument symbol. For futures spreads and options spreads, this field contains the first leg\'s calendar month reflected in the instrument symbol. For daily products, this tag contains the full calendar date (YYYYMMDD) as reflected in the instrument symbol.
     * @type {string}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'maturity'?: string;
    /**
     * The maximum order quantity for this contract.
     * @type {number}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'max_order_quantity'?: number;
    /**
     * The minimum order quantity for this contract.
     * @type {number}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'min_order_quantity'?: number;
    /**
     * The name of the contract.
     * @type {string}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'name'?: string;
    /**
     * The unique identifier for the product to which this contract belongs.
     * @type {string}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'product_code': string;
    /**
     * The final settlement date for the contract.
     * @type {string}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'settlement_date'?: string;
    /**
     * The settlement tick size for this contract.
     * @type {number}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'settlement_tick_size'?: number;
    /**
     * The spread tick size for this contract.
     * @type {number}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'spread_tick_size'?: number;
    /**
     * The unique identifier for the contract, typically consisting of the product code and expiration date.
     * @type {string}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The tick size for this contract.
     * @type {number}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'trade_tick_size'?: number;
    /**
     * The trading venue (MIC) for the exchange on which this contract trades.
     * @type {string}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'trading_venue': string;
    /**
     * The type of contract, one of \"single\" or \"combo\".
     * @type {string}
     * @memberof GetFuturesContracts200ResponseResultsInner
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface GetFuturesDailySchedules200Response
 */
export interface GetFuturesDailySchedules200Response {
    /**
     * The URL for the next page of results.
     * @type {string}
     * @memberof GetFuturesDailySchedules200Response
     */
    'next_url'?: string;
    /**
     * The unique identifier for this request.
     * @type {string}
     * @memberof GetFuturesDailySchedules200Response
     */
    'request_id': string;
    /**
     * A list of schedules for each product.
     * @type {Array<GetFuturesProductSchedules200ResponseResultsInner>}
     * @memberof GetFuturesDailySchedules200Response
     */
    'results'?: Array<GetFuturesProductSchedules200ResponseResultsInner>;
    /**
     * The status of the response.
     * @type {string}
     * @memberof GetFuturesDailySchedules200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetFuturesMarketStatuses200Response
 */
export interface GetFuturesMarketStatuses200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetFuturesMarketStatuses200Response
     */
    'next_url'?: string;
    /**
     * A unique identifier for this request.
     * @type {string}
     * @memberof GetFuturesMarketStatuses200Response
     */
    'request_id': string;
    /**
     * 
     * @type {Array<GetFuturesMarketStatuses200ResponseResultsInner>}
     * @memberof GetFuturesMarketStatuses200Response
     */
    'results'?: Array<GetFuturesMarketStatuses200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFuturesMarketStatuses200Response
     */
    'status': string;
    /**
     * An RFC3339 timestamp representing the moment at which the market statuses were evaluated.
     * @type {string}
     * @memberof GetFuturesMarketStatuses200Response
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface GetFuturesMarketStatuses200ResponseResultsInner
 */
export interface GetFuturesMarketStatuses200ResponseResultsInner {
    /**
     * The current status of the market.
     * @type {string}
     * @memberof GetFuturesMarketStatuses200ResponseResultsInner
     */
    'market_status': GetFuturesMarketStatuses200ResponseResultsInnerMarketStatusEnum;
    /**
     * The product code for the product.
     * @type {string}
     * @memberof GetFuturesMarketStatuses200ResponseResultsInner
     */
    'product_code': string;
    /**
     * The trading venue (MIC) for the exchange on which the corresponding product trades.
     * @type {string}
     * @memberof GetFuturesMarketStatuses200ResponseResultsInner
     */
    'trading_venue'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum GetFuturesMarketStatuses200ResponseResultsInnerMarketStatusEnum {
    PreOpen = 'pre_open',
    Open = 'open',
    Close = 'close',
    Pause = 'pause',
    PostClosePreOpen = 'post_close_pre_open'
}

/**
 * 
 * @export
 * @interface GetFuturesProductDetails200Response
 */
export interface GetFuturesProductDetails200Response {
    /**
     * A unique identifier for this request.
     * @type {string}
     * @memberof GetFuturesProductDetails200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetFuturesProducts200ResponseResultsInner}
     * @memberof GetFuturesProductDetails200Response
     */
    'results'?: GetFuturesProducts200ResponseResultsInner;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFuturesProductDetails200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetFuturesProductSchedules200Response
 */
export interface GetFuturesProductSchedules200Response {
    /**
     * An optional error message for failed requests when available.
     * @type {string}
     * @memberof GetFuturesProductSchedules200Response
     */
    'error'?: string;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetFuturesProductSchedules200Response
     */
    'next_url'?: string;
    /**
     * The unique identifier for the request.
     * @type {string}
     * @memberof GetFuturesProductSchedules200Response
     */
    'request_id': string;
    /**
     * The list of schedules for the specified product.
     * @type {Array<GetFuturesProductSchedules200ResponseResultsInner>}
     * @memberof GetFuturesProductSchedules200Response
     */
    'results'?: Array<GetFuturesProductSchedules200ResponseResultsInner>;
    /**
     * The status of the response.
     * @type {string}
     * @memberof GetFuturesProductSchedules200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetFuturesProductSchedules200ResponseResultsInner
 */
export interface GetFuturesProductSchedules200ResponseResultsInner {
    /**
     * The product code for the futures product to which this schedule applies.
     * @type {string}
     * @memberof GetFuturesProductSchedules200ResponseResultsInner
     */
    'product_code': string;
    /**
     * The name of the futures product to which this schedule applies.
     * @type {string}
     * @memberof GetFuturesProductSchedules200ResponseResultsInner
     */
    'product_name'?: string;
    /**
     * 
     * @type {Array<GetFuturesProductSchedules200ResponseResultsInnerScheduleInner>}
     * @memberof GetFuturesProductSchedules200ResponseResultsInner
     */
    'schedule': Array<GetFuturesProductSchedules200ResponseResultsInnerScheduleInner>;
    /**
     * The date on which the schedule\'s trading day ended (sometimes referred to as trading date) formatted as `YYYY-MM-DD`. Note that although there is no time component on this attribute, the day refers to Central Time.
     * @type {string}
     * @memberof GetFuturesProductSchedules200ResponseResultsInner
     */
    'session_end_date': string;
    /**
     * The trading venue (MIC) for the exchange on which this schedule\'s product trades.
     * @type {string}
     * @memberof GetFuturesProductSchedules200ResponseResultsInner
     */
    'trading_venue'?: string;
}
/**
 * 
 * @export
 * @interface GetFuturesProductSchedules200ResponseResultsInnerScheduleInner
 */
export interface GetFuturesProductSchedules200ResponseResultsInnerScheduleInner {
    /**
     * The market event for this schedule.
     * @type {string}
     * @memberof GetFuturesProductSchedules200ResponseResultsInnerScheduleInner
     */
    'event': GetFuturesProductSchedules200ResponseResultsInnerScheduleInnerEventEnum;
    /**
     * The timestamp for this market event in Central Time.
     * @type {string}
     * @memberof GetFuturesProductSchedules200ResponseResultsInnerScheduleInner
     */
    'timestamp': string;
}

/**
    * @export
    * @enum {string}
    */
export enum GetFuturesProductSchedules200ResponseResultsInnerScheduleInnerEventEnum {
    PreOpen = 'pre_open',
    Open = 'open',
    Close = 'close',
    Pause = 'pause',
    PostClosePreOpen = 'post_close_pre_open'
}

/**
 * 
 * @export
 * @interface GetFuturesProducts200Response
 */
export interface GetFuturesProducts200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetFuturesProducts200Response
     */
    'next_url'?: string;
    /**
     * A unique identifier for this request.
     * @type {string}
     * @memberof GetFuturesProducts200Response
     */
    'request_id': string;
    /**
     * 
     * @type {Array<GetFuturesProducts200ResponseResultsInner>}
     * @memberof GetFuturesProducts200Response
     */
    'results'?: Array<GetFuturesProducts200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFuturesProducts200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetFuturesProducts200ResponseResultsInner
 */
export interface GetFuturesProducts200ResponseResultsInner {
    /**
     * The point-in-time date for the given product - e.g. if \'as_of\' is set to 2024-11-05, then these were the details for this product on that day.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'as_of'?: string;
    /**
     * The asset class to which the product belongs.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'asset_class'?: string;
    /**
     * The asset sub-class to which the product belongs.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'asset_sub_class'?: string;
    /**
     * The clearing channel for this product. Indicates whether the product can be cleared only through exchanges or through both exchanges and over-the-counter.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'clearing_channel'?: GetFuturesProducts200ResponseResultsInnerClearingChannelEnum;
    /**
     * The date and time at which this product was last updated.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * The full name of the product.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'name'?: string;
    /**
     * The quoted price for this product.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'price_quotation'?: string;
    /**
     * The unique identifier for the product.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'product_code': string;
    /**
     * The sector to which the product belongs.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'sector'?: string;
    /**
     * The currency in which this product settles.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'settlement_currency_code'?: string;
    /**
     * The method of settlement for this product (Financially Settled or Deliverable).
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'settlement_method'?: string;
    /**
     * The type of settlement for this product.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'settlement_type'?: string;
    /**
     * The sub-sector to which the product belongs.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'sub_sector'?: string;
    /**
     * The currency in which this product trades.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'trade_currency_code'?: string;
    /**
     * The trading venue (MIC) for the exchange on which this contract trades.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'trading_venue'?: string;
    /**
     * The type of product, one of \"single\" or \"combo\".
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'type'?: string;
    /**
     * The unit of measure for this product.
     * @type {string}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'unit_of_measure'?: string;
    /**
     * The quantity of the unit of measure for this product.
     * @type {number}
     * @memberof GetFuturesProducts200ResponseResultsInner
     */
    'unit_of_measure_quantity'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum GetFuturesProducts200ResponseResultsInnerClearingChannelEnum {
    ExchangeOnly = 'exchange_only',
    ExchangeAndOtc = 'exchange_and_otc'
}

/**
 * 
 * @export
 * @interface GetFuturesQuotes200Response
 */
export interface GetFuturesQuotes200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetFuturesQuotes200Response
     */
    'next_url'?: string;
    /**
     * 
     * @type {Array<GetFuturesQuotes200ResponseResultsInner>}
     * @memberof GetFuturesQuotes200Response
     */
    'results'?: Array<GetFuturesQuotes200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFuturesQuotes200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetFuturesQuotes200ResponseResultsInner
 */
export interface GetFuturesQuotes200ResponseResultsInner {
    /**
     * The ask price is expressed per unit of the underlying asset, and you apply the contract multiplier to get the full contract value.
     * @type {number}
     * @memberof GetFuturesQuotes200ResponseResultsInner
     */
    'ask_price'?: number;
    /**
     * The quote size represents the number of futures contracts available at the given ask price.
     * @type {number}
     * @memberof GetFuturesQuotes200ResponseResultsInner
     */
    'ask_size'?: number;
    /**
     * The time when the ask price was submitted to the exchange.
     * @type {number}
     * @memberof GetFuturesQuotes200ResponseResultsInner
     */
    'ask_timestamp'?: number;
    /**
     * The bid price is expressed per unit of the underlying asset, and you apply the contract multiplier to get the full contract value.
     * @type {number}
     * @memberof GetFuturesQuotes200ResponseResultsInner
     */
    'bid_price'?: number;
    /**
     * The quote size represents the number of futures contracts available at the given bid price.
     * @type {number}
     * @memberof GetFuturesQuotes200ResponseResultsInner
     */
    'bid_size'?: number;
    /**
     * The time when the bid price was submitted to the exchange.
     * @type {number}
     * @memberof GetFuturesQuotes200ResponseResultsInner
     */
    'bid_timestamp'?: number;
    /**
     * Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
     * @type {string}
     * @memberof GetFuturesQuotes200ResponseResultsInner
     */
    'session_end_date': string;
    /**
     * The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
     * @type {string}
     * @memberof GetFuturesQuotes200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The time when the quote was generated at the exchange to nanosecond precision.
     * @type {number}
     * @memberof GetFuturesQuotes200ResponseResultsInner
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface GetFuturesTrades200Response
 */
export interface GetFuturesTrades200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetFuturesTrades200Response
     */
    'next_url'?: string;
    /**
     * 
     * @type {Array<GetFuturesTrades200ResponseResultsInner>}
     * @memberof GetFuturesTrades200Response
     */
    'results'?: Array<GetFuturesTrades200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFuturesTrades200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetFuturesTrades200ResponseResultsInner
 */
export interface GetFuturesTrades200ResponseResultsInner {
    /**
     * The price of the trade. This is the actual dollar value per whole contract of this trade. A trade of 100 contracts with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetFuturesTrades200ResponseResultsInner
     */
    'price': number;
    /**
     * Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
     * @type {string}
     * @memberof GetFuturesTrades200ResponseResultsInner
     */
    'session_end_date': string;
    /**
     * The total number of contracts exchanged between buyers and sellers on a given trade.
     * @type {number}
     * @memberof GetFuturesTrades200ResponseResultsInner
     */
    'size': number;
    /**
     * ticker of the trade
     * @type {string}
     * @memberof GetFuturesTrades200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The time when the trade was generated at the exchange to nanosecond precision.
     * @type {number}
     * @memberof GetFuturesTrades200ResponseResultsInner
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface GetFuturesVXContractsNew200Response
 */
export interface GetFuturesVXContractsNew200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetFuturesVXContractsNew200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetFuturesVXContractsNew200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetFuturesVXContractsNew200ResponseResultsInner>}
     * @memberof GetFuturesVXContractsNew200Response
     */
    'results': Array<GetFuturesVXContractsNew200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFuturesVXContractsNew200Response
     */
    'status': GetFuturesVXContractsNew200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetFuturesVXContractsNew200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetFuturesVXContractsNew200ResponseResultsInner
 */
export interface GetFuturesVXContractsNew200ResponseResultsInner {
    /**
     * The contract is still trading.
     * @type {boolean}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'active': boolean;
    /**
     * A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day (default=today).
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'days_to_maturity'?: number;
    /**
     * The first date the contract trades.
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'first_trade_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'group_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'guid'?: string;
    /**
     * The last date the contract trades.
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'last_trade_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'maturity_month'?: string;
    /**
     * The maximum order quantity.
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'max_order_quantity'?: string;
    /**
     * The minimum order quantity.
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'min_order_quantity'?: string;
    /**
     * The full name of the product.
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'name'?: string;
    /**
     * The unique identifier for the product.
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'product_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'security_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'settlement_date'?: string;
    /**
     * The tick size for settlement.
     * @type {number}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'settlement_tick_size'?: number;
    /**
     * The tick size for spreads.
     * @type {number}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'spread_tick_size'?: number;
    /**
     * The ticker for the contract.
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * The tick size for trades.
     * @type {number}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'trade_tick_size'?: number;
    /**
     * The trading venue (MIC) for the exchange on which this contract trades.
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'trading_venue'?: string;
    /**
     * The type of product, one of \'single\' or \'combo\'.
     * @type {string}
     * @memberof GetFuturesVXContractsNew200ResponseResultsInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface GetFuturesVXExchanges200Response
 */
export interface GetFuturesVXExchanges200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetFuturesVXExchanges200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetFuturesVXExchanges200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetFuturesVXExchanges200ResponseResultsInner>}
     * @memberof GetFuturesVXExchanges200Response
     */
    'results': Array<GetFuturesVXExchanges200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFuturesVXExchanges200Response
     */
    'status': GetFuturesVXExchanges200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetFuturesVXExchanges200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetFuturesVXExchanges200ResponseResultsInner
 */
export interface GetFuturesVXExchanges200ResponseResultsInner {
    /**
     * Well-known acronym for the exchange (e.g., \'CME\', \'NYMEX\', \'CBOT\', \'COMEX\').
     * @type {string}
     * @memberof GetFuturesVXExchanges200ResponseResultsInner
     */
    'acronym'?: string;
    /**
     * Numeric identifier for the futures exchange or trading venue.
     * @type {string}
     * @memberof GetFuturesVXExchanges200ResponseResultsInner
     */
    'id': string;
    /**
     * Geographic location code where the exchange operates.
     * @type {string}
     * @memberof GetFuturesVXExchanges200ResponseResultsInner
     */
    'locale'?: string;
    /**
     * Market Identifier Code (MIC) - ISO 10383 standard four-character code for the futures market.
     * @type {string}
     * @memberof GetFuturesVXExchanges200ResponseResultsInner
     */
    'mic'?: string;
    /**
     * Full official name of the futures exchange (e.g., \'Chicago Mercantile Exchange\', \'New York Mercantile Exchange\').
     * @type {string}
     * @memberof GetFuturesVXExchanges200ResponseResultsInner
     */
    'name': string;
    /**
     * Operating Market Identifier Code for the futures exchange.
     * @type {string}
     * @memberof GetFuturesVXExchanges200ResponseResultsInner
     */
    'operating_mic'?: string;
    /**
     * Type of venue - \'exchange\' for futures exchanges and derivatives trading platforms.
     * @type {string}
     * @memberof GetFuturesVXExchanges200ResponseResultsInner
     */
    'type': string;
    /**
     * Official website URL of the futures exchange organization.
     * @type {string}
     * @memberof GetFuturesVXExchanges200ResponseResultsInner
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface GetFuturesVXProductsNew200Response
 */
export interface GetFuturesVXProductsNew200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetFuturesVXProductsNew200ResponseResultsInner>}
     * @memberof GetFuturesVXProductsNew200Response
     */
    'results': Array<GetFuturesVXProductsNew200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200Response
     */
    'status': GetFuturesVXProductsNew200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetFuturesVXProductsNew200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetFuturesVXProductsNew200ResponseResultsInner
 */
export interface GetFuturesVXProductsNew200ResponseResultsInner {
    /**
     * The asset class to which the product belongs.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'asset_class'?: string;
    /**
     * The asset sub-class to which the product belongs.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'asset_sub_class'?: string;
    /**
     * A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day (default=today).
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'display_factor'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'group_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'last_updated'?: string;
    /**
     * The full name of the product.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'name'?: string;
    /**
     * The quoted price for this product.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'price_quotation'?: string;
    /**
     * The unique identifier for the product.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'product_code'?: string;
    /**
     * The sector to which the product belongs.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'sector'?: string;
    /**
     * The currency in which this product settles.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'settlement_currency_code'?: string;
    /**
     * The method of settlement for this product (Financially Settled or Deliverable).
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'settlement_method'?: string;
    /**
     * The type of settlement for this product.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'settlement_type'?: string;
    /**
     * The sub-sector to which the product belongs.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'sub_sector'?: string;
    /**
     * The currency in which this product trades.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'trade_currency_code'?: string;
    /**
     * The trading venue (MIC) for the exchange on which this contract trades.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'trading_venue'?: string;
    /**
     * The type of product, one of \'single\' or \'combo\'.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'type'?: string;
    /**
     * The unit of measure for this product.
     * @type {string}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'unit_of_measure'?: string;
    /**
     * The quantity of the unit of measure for this product.
     * @type {number}
     * @memberof GetFuturesVXProductsNew200ResponseResultsInner
     */
    'unit_of_measure_qty'?: number;
}
/**
 * 
 * @export
 * @interface GetFuturesVXSnapshot200Response
 */
export interface GetFuturesVXSnapshot200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetFuturesVXSnapshot200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetFuturesVXSnapshot200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetFuturesVXSnapshot200ResponseResultsInner>}
     * @memberof GetFuturesVXSnapshot200Response
     */
    'results': Array<GetFuturesVXSnapshot200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetFuturesVXSnapshot200Response
     */
    'status': GetFuturesVXSnapshot200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetFuturesVXSnapshot200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetFuturesVXSnapshot200ResponseResultsInner
 */
export interface GetFuturesVXSnapshot200ResponseResultsInner {
    /**
     * 
     * @type {GetFuturesVXSnapshot200ResponseResultsInnerDetails}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInner
     */
    'details'?: GetFuturesVXSnapshot200ResponseResultsInnerDetails;
    /**
     * 
     * @type {GetFuturesVXSnapshot200ResponseResultsInnerLastMinute}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInner
     */
    'last_minute'?: GetFuturesVXSnapshot200ResponseResultsInnerLastMinute;
    /**
     * 
     * @type {GetFuturesVXSnapshot200ResponseResultsInnerLastQuote}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInner
     */
    'last_quote'?: GetFuturesVXSnapshot200ResponseResultsInnerLastQuote;
    /**
     * 
     * @type {GetFuturesVXSnapshot200ResponseResultsInnerLastTrade}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInner
     */
    'last_trade'?: GetFuturesVXSnapshot200ResponseResultsInnerLastTrade;
    /**
     * 
     * @type {GetFuturesVXSnapshot200ResponseResultsInnerSession}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInner
     */
    'session'?: GetFuturesVXSnapshot200ResponseResultsInnerSession;
}
/**
 * 
 * @export
 * @interface GetFuturesVXSnapshot200ResponseResultsInnerDetails
 */
export interface GetFuturesVXSnapshot200ResponseResultsInnerDetails {
    /**
     * 
     * @type {string}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerDetails
     */
    'product_code'?: string;
    /**
     * The day that this contract is settled.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerDetails
     */
    'settlement_date'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerDetails
     */
    'ticker'?: string;
}
/**
 * 
 * @export
 * @interface GetFuturesVXSnapshot200ResponseResultsInnerLastMinute
 */
export interface GetFuturesVXSnapshot200ResponseResultsInnerLastMinute {
    /**
     * The price at the end of the minute bar.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastMinute
     */
    'close'?: number;
    /**
     * The highest price reached in the minute bar.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastMinute
     */
    'high'?: number;
    /**
     * The timestamp indicating the most recent update to the minute bar.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastMinute
     */
    'last_updated'?: number;
    /**
     * The lowest price reached in the minute bar.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastMinute
     */
    'low'?: number;
    /**
     * The opening price at the start of the minute bar.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastMinute
     */
    'open'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastMinute
     */
    'timeframe'?: string;
    /**
     * The number of contracts traded in the minute bar.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastMinute
     */
    'volume'?: number;
}
/**
 * 
 * @export
 * @interface GetFuturesVXSnapshot200ResponseResultsInnerLastQuote
 */
export interface GetFuturesVXSnapshot200ResponseResultsInnerLastQuote {
    /**
     * The lowest price a seller is willing to accept.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastQuote
     */
    'ask'?: number;
    /**
     * The number of contracts available at the ask price.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastQuote
     */
    'ask_size'?: number;
    /**
     * The time when the best ask price was last updated.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastQuote
     */
    'ask_timestamp'?: number;
    /**
     * The highest price a buyer is willing to pay.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastQuote
     */
    'bid'?: number;
    /**
     * The number of contracts available at the bid price.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastQuote
     */
    'bid_size'?: number;
    /**
     * The time when the best bid price was last updated.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastQuote
     */
    'bid_timestamp'?: number;
    /**
     * The time when the quote was generated at the exchange to nanosecond precision.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastQuote
     */
    'last_updated'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastQuote
     */
    'timeframe'?: string;
}
/**
 * 
 * @export
 * @interface GetFuturesVXSnapshot200ResponseResultsInnerLastTrade
 */
export interface GetFuturesVXSnapshot200ResponseResultsInnerLastTrade {
    /**
     * The time when the trade was generated at the exchange to nanosecond precision.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastTrade
     */
    'last_updated'?: number;
    /**
     * The price of the trade. This is the actual dollar value per whole contract of this trade. A trade of 100 contracts with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastTrade
     */
    'price'?: number;
    /**
     * The total number of contracts exchanged between buyers and sellers on a given trade.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastTrade
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerLastTrade
     */
    'timeframe'?: string;
}
/**
 * 
 * @export
 * @interface GetFuturesVXSnapshot200ResponseResultsInnerSession
 */
export interface GetFuturesVXSnapshot200ResponseResultsInnerSession {
    /**
     * The change in price during this session.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerSession
     */
    'change'?: number;
    /**
     * The percentage change in price during this session.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerSession
     */
    'change_percent'?: number;
    /**
     * The price at the end of the session.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerSession
     */
    'close'?: number;
    /**
     * The highest price reached in the session.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerSession
     */
    'high'?: number;
    /**
     * The lowest price reached in the session.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerSession
     */
    'low'?: number;
    /**
     * The opening price at the start of the session.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerSession
     */
    'open'?: number;
    /**
     * The settlement price of the previous session.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerSession
     */
    'previous_settlement'?: number;
    /**
     * The final settlement price at the end of the session.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerSession
     */
    'settlement_price'?: number;
    /**
     * The number of contracts traded in the session.
     * @type {number}
     * @memberof GetFuturesVXSnapshot200ResponseResultsInnerSession
     */
    'volume'?: number;
}
/**
 * 
 * @export
 * @interface GetGroupedCryptoAggregates200Response
 */
export interface GetGroupedCryptoAggregates200Response {
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof GetGroupedCryptoAggregates200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetGroupedCryptoAggregates200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetGroupedCryptoAggregates200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>}
     * @memberof GetGroupedCryptoAggregates200Response
     */
    'results'?: Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetGroupedCryptoAggregates200ResponseAllOfResultsInner
 */
export interface GetGroupedCryptoAggregates200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the end of the aggregate window.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetGroupedCryptoAggregates200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface GetGroupedStocksAggregates200Response
 */
export interface GetGroupedStocksAggregates200Response {
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof GetGroupedStocksAggregates200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetGroupedStocksAggregates200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetGroupedStocksAggregates200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetGroupedStocksAggregates200ResponseAllOfResultsInner>}
     * @memberof GetGroupedStocksAggregates200Response
     */
    'results'?: Array<GetGroupedStocksAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetGroupedStocksAggregates200ResponseAllOfResultsInner
 */
export interface GetGroupedStocksAggregates200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'otc'?: boolean;
    /**
     * The Unix millisecond timestamp for the end of the aggregate window.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetGroupedStocksAggregates200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface GetIndicesOpenClose200Response
 */
export interface GetIndicesOpenClose200Response {
    /**
     * The close value of the ticker symbol in after hours trading.
     * @type {number}
     * @memberof GetIndicesOpenClose200Response
     */
    'afterHours'?: number;
    /**
     * The close value for the symbol in the given time period.
     * @type {number}
     * @memberof GetIndicesOpenClose200Response
     */
    'close': number;
    /**
     * The requested date.
     * @type {string}
     * @memberof GetIndicesOpenClose200Response
     */
    'from': string;
    /**
     * The highest value for the symbol in the given time period.
     * @type {number}
     * @memberof GetIndicesOpenClose200Response
     */
    'high': number;
    /**
     * The lowest value for the symbol in the given time period.
     * @type {number}
     * @memberof GetIndicesOpenClose200Response
     */
    'low': number;
    /**
     * The open value for the symbol in the given time period.
     * @type {number}
     * @memberof GetIndicesOpenClose200Response
     */
    'open': number;
    /**
     * The open value of the ticker symbol in pre-market trading.
     * @type {number}
     * @memberof GetIndicesOpenClose200Response
     */
    'preMarket'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetIndicesOpenClose200Response
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetIndicesOpenClose200Response
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface GetIndicesSnapshot200Response
 */
export interface GetIndicesSnapshot200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetIndicesSnapshot200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetIndicesSnapshot200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetIndicesSnapshot200ResponseResultsInner>}
     * @memberof GetIndicesSnapshot200Response
     */
    'results'?: Array<GetIndicesSnapshot200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetIndicesSnapshot200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetIndicesSnapshot200ResponseResultsInner
 */
export interface GetIndicesSnapshot200ResponseResultsInner {
    /**
     * The error while looking for this ticker.
     * @type {string}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'error'?: string;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'last_updated'?: number;
    /**
     * The market status for the market that trades this ticker.
     * @type {string}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'market_status'?: string;
    /**
     * The error message while looking for this ticker.
     * @type {string}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'message'?: string;
    /**
     * Name of Index.
     * @type {string}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'name'?: string;
    /**
     * 
     * @type {GetIndicesSnapshot200ResponseResultsInnerSession}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'session'?: GetIndicesSnapshot200ResponseResultsInnerSession;
    /**
     * Ticker of asset queried.
     * @type {string}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'timeframe'?: GetIndicesSnapshot200ResponseResultsInnerTimeframeEnum;
    /**
     * The indices market.
     * @type {string}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'type'?: GetIndicesSnapshot200ResponseResultsInnerTypeEnum;
    /**
     * Value of Index.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInner
     */
    'value'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum GetIndicesSnapshot200ResponseResultsInnerTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}
/**
    * @export
    * @enum {string}
    */
export enum GetIndicesSnapshot200ResponseResultsInnerTypeEnum {
    Indices = 'indices'
}

/**
 * Trading session metrics, detailing change percentages and key price points (open, close, high, low) for the asset within the current trading day.
 * @export
 * @interface GetIndicesSnapshot200ResponseResultsInnerSession
 */
export interface GetIndicesSnapshot200ResponseResultsInnerSession {
    /**
     * The value of the change for the index from the previous trading day.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInnerSession
     */
    'change'?: number;
    /**
     * The percent of the change for the index from the previous trading day.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInnerSession
     */
    'change_percent'?: number;
    /**
     * The closing value for the index of the day.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInnerSession
     */
    'close'?: number;
    /**
     * The highest value for the index of the day.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInnerSession
     */
    'high'?: number;
    /**
     * The lowest value for the index of the day.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInnerSession
     */
    'low'?: number;
    /**
     * The open value for the index of the day.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInnerSession
     */
    'open'?: number;
    /**
     * The closing value for the index of previous trading day.
     * @type {number}
     * @memberof GetIndicesSnapshot200ResponseResultsInnerSession
     */
    'previous_close'?: number;
}
/**
 * 
 * @export
 * @interface GetLastCryptoTrade200Response
 */
export interface GetLastCryptoTrade200Response {
    /**
     * 
     * @type {GetLastCryptoTrade200ResponseLast}
     * @memberof GetLastCryptoTrade200Response
     */
    'last'?: GetLastCryptoTrade200ResponseLast;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetLastCryptoTrade200Response
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetLastCryptoTrade200Response
     */
    'status': string;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof GetLastCryptoTrade200Response
     */
    'symbol': string;
}
/**
 * Contains the requested trade data for the specified cryptocurrency pair.
 * @export
 * @interface GetLastCryptoTrade200ResponseLast
 */
export interface GetLastCryptoTrade200ResponseLast {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetLastCryptoTrade200ResponseLast
     */
    'conditions'?: Array<number>;
    /**
     * The exchange that this crypto trade happened on.   See <a href=\"https://massive.com/docs/rest/crypto/market-operations/exchanges\">Exchanges</a> for a mapping of exchanges to IDs.
     * @type {number}
     * @memberof GetLastCryptoTrade200ResponseLast
     */
    'exchange': number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetLastCryptoTrade200ResponseLast
     */
    'price': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof GetLastCryptoTrade200ResponseLast
     */
    'size': number;
    /**
     * The Unix millisecond timestamp.
     * @type {number}
     * @memberof GetLastCryptoTrade200ResponseLast
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface GetLastCurrencyQuote200Response
 */
export interface GetLastCurrencyQuote200Response {
    /**
     * 
     * @type {GetCurrencyConversion200ResponseLast}
     * @memberof GetLastCurrencyQuote200Response
     */
    'last'?: GetCurrencyConversion200ResponseLast;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetLastCurrencyQuote200Response
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetLastCurrencyQuote200Response
     */
    'status': string;
    /**
     * The symbol pair that was evaluated from the request.
     * @type {string}
     * @memberof GetLastCurrencyQuote200Response
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface GetLastOptionsTrade200Response
 */
export interface GetLastOptionsTrade200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetLastOptionsTrade200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetLastOptionsTrade200ResponseResults}
     * @memberof GetLastOptionsTrade200Response
     */
    'results'?: GetLastOptionsTrade200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetLastOptionsTrade200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetLastOptionsTrade200ResponseResults
 */
export interface GetLastOptionsTrade200ResponseResults {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'T': string;
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'c'?: Array<number>;
    /**
     * The trade correction indicator.
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'e'?: number;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'f'?: number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
     * @type {string}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'p': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'q': number;
    /**
     * The ID for the Trade Reporting Facility where the trade took place.
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'r'?: number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    's'?: number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    't': number;
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'x': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'y': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ
     * @type {number}
     * @memberof GetLastOptionsTrade200ResponseResults
     */
    'z'?: number;
}
/**
 * 
 * @export
 * @interface GetLastStocksQuote200Response
 */
export interface GetLastStocksQuote200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetLastStocksQuote200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetLastStocksQuote200ResponseResults}
     * @memberof GetLastStocksQuote200Response
     */
    'results'?: GetLastStocksQuote200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetLastStocksQuote200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetLastStocksQuote200ResponseResults
 */
export interface GetLastStocksQuote200ResponseResults {
    /**
     * The ask price.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'P'?: number;
    /**
     * The total number of shares available for sale at the current ask price.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'S'?: number;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'T': string;
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'X'?: number;
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'c'?: Array<number>;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'f'?: number;
    /**
     * A list of indicator codes.
     * @type {Array<number>}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'i'?: Array<number>;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'p'?: number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'q': number;
    /**
     * The total number of shares that buyers want to purchase at the current bid price.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    's'?: number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    't': number;
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'x'?: number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'y': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ
     * @type {number}
     * @memberof GetLastStocksQuote200ResponseResults
     */
    'z'?: number;
}
/**
 * 
 * @export
 * @interface GetMarketHolidays200ResponseInner
 */
export interface GetMarketHolidays200ResponseInner {
    /**
     * The market close time on the holiday (if it\'s not closed).
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'close'?: string;
    /**
     * The date of the holiday.
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'date'?: string;
    /**
     * Which market the record is for.
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'exchange'?: string;
    /**
     * The name of the holiday.
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'name'?: string;
    /**
     * The market open time on the holiday (if it\'s not closed).
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'open'?: string;
    /**
     * The status of the market on the holiday.
     * @type {string}
     * @memberof GetMarketHolidays200ResponseInner
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetMarketStatus200Response
 */
export interface GetMarketStatus200Response {
    /**
     * Whether or not the market is in post-market hours.
     * @type {boolean}
     * @memberof GetMarketStatus200Response
     */
    'afterHours'?: boolean;
    /**
     * 
     * @type {GetMarketStatus200ResponseCurrencies}
     * @memberof GetMarketStatus200Response
     */
    'currencies'?: GetMarketStatus200ResponseCurrencies;
    /**
     * Whether or not the market is in pre-market hours.
     * @type {boolean}
     * @memberof GetMarketStatus200Response
     */
    'earlyHours'?: boolean;
    /**
     * 
     * @type {GetMarketStatus200ResponseExchanges}
     * @memberof GetMarketStatus200Response
     */
    'exchanges'?: GetMarketStatus200ResponseExchanges;
    /**
     * 
     * @type {GetMarketStatus200ResponseIndicesGroups}
     * @memberof GetMarketStatus200Response
     */
    'indicesGroups'?: GetMarketStatus200ResponseIndicesGroups;
    /**
     * The status of the market as a whole.
     * @type {string}
     * @memberof GetMarketStatus200Response
     */
    'market'?: string;
    /**
     * The current time of the server, returned as a date-time in RFC3339 format.
     * @type {string}
     * @memberof GetMarketStatus200Response
     */
    'serverTime'?: string;
}
/**
 * Contains the status of various currency markets.
 * @export
 * @interface GetMarketStatus200ResponseCurrencies
 */
export interface GetMarketStatus200ResponseCurrencies {
    /**
     * The status of the crypto market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseCurrencies
     */
    'crypto'?: string;
    /**
     * The status of the forex market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseCurrencies
     */
    'fx'?: string;
}
/**
 * Contains the status of different US stock exchanges (e.g., Nasdaq, NYSE).
 * @export
 * @interface GetMarketStatus200ResponseExchanges
 */
export interface GetMarketStatus200ResponseExchanges {
    /**
     * The status of the Nasdaq market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseExchanges
     */
    'nasdaq'?: string;
    /**
     * The status of the NYSE market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseExchanges
     */
    'nyse'?: string;
    /**
     * The status of the OTC market.
     * @type {string}
     * @memberof GetMarketStatus200ResponseExchanges
     */
    'otc'?: string;
}
/**
 * Contains the status of various index groups (e.g., MSCI, FTSE Russell).
 * @export
 * @interface GetMarketStatus200ResponseIndicesGroups
 */
export interface GetMarketStatus200ResponseIndicesGroups {
    /**
     * The status of Cboe Streaming Market Indices Cryptocurrency (\"CCCY\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'cccy'?: string;
    /**
     * The status of Cboe Global Indices (\"CGI\") trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'cgi'?: string;
    /**
     * The status of Dow Jones indices trading hours
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'dow_jones'?: string;
    /**
     * The status of Financial Times Stock Exchange Group (\"FTSE\") Russell indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'ftse_russell'?: string;
    /**
     * The status of Morgan Stanley Capital International (\"MSCI\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'msci'?: string;
    /**
     * The status of Morningstar (\"MSTAR\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'mstar'?: string;
    /**
     * The status of Morningstar Customer (\"MSTARC\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'mstarc'?: string;
    /**
     * The status of National Association of Securities Dealers Automated Quotations (\"Nasdaq\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'nasdaq'?: string;
    /**
     * The status of Standard & Poor\'s (\"S&P\") indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    's_and_p'?: string;
    /**
     * The status of Societe Generale indices trading hours.
     * @type {string}
     * @memberof GetMarketStatus200ResponseIndicesGroups
     */
    'societe_generale'?: string;
}
/**
 * 
 * @export
 * @interface GetOptionContract200Response
 */
export interface GetOptionContract200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetOptionContract200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetOptionContract200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetOptionsChain200ResponseResultsInner}
     * @memberof GetOptionContract200Response
     */
    'results'?: GetOptionsChain200ResponseResultsInner;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetOptionContract200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetOptionsChain200Response
 */
export interface GetOptionsChain200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetOptionsChain200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetOptionsChain200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetOptionsChain200ResponseResultsInner>}
     * @memberof GetOptionsChain200Response
     */
    'results'?: Array<GetOptionsChain200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetOptionsChain200Response
     */
    'status': string;
}
/**
 * Contains the requested snapshot data for the specified contract.
 * @export
 * @interface GetOptionsChain200ResponseResultsInner
 */
export interface GetOptionsChain200ResponseResultsInner {
    /**
     * The price of the underlying asset for the contract to break even. For a call, this value is (strike price + premium paid). For a put, this value is (strike price - premium paid).
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'break_even_price': number;
    /**
     * 
     * @type {GetOptionsChain200ResponseResultsInnerDay}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'day': GetOptionsChain200ResponseResultsInnerDay;
    /**
     * 
     * @type {GetOptionsChain200ResponseResultsInnerDetails}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'details': GetOptionsChain200ResponseResultsInnerDetails;
    /**
     * Fair Market Value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://massive.com/contact\">contact us</a>.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'fmv'?: number;
    /**
     * If Fair Market Value (FMV) is available, this field is the nanosecond timestamp of the last FMV calculation.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'fmv_last_updated'?: number;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerGreeks}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'greeks'?: GetSnapshots200ResponseResultsInnerGreeks;
    /**
     * The market\'s forecast for the volatility of the underlying asset, based on this option\'s current price.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'implied_volatility'?: number;
    /**
     * 
     * @type {GetOptionsChain200ResponseResultsInnerLastQuote}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'last_quote': GetOptionsChain200ResponseResultsInnerLastQuote;
    /**
     * 
     * @type {GetOptionsChain200ResponseResultsInnerLastTrade}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'last_trade'?: GetOptionsChain200ResponseResultsInnerLastTrade;
    /**
     * The quantity of this contract held at the end of the last trading day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'open_interest': number;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerUnderlyingAsset}
     * @memberof GetOptionsChain200ResponseResultsInner
     */
    'underlying_asset': GetSnapshots200ResponseResultsInnerUnderlyingAsset;
}
/**
 * The most recent daily bar for this contract.
 * @export
 * @interface GetOptionsChain200ResponseResultsInnerDay
 */
export interface GetOptionsChain200ResponseResultsInnerDay {
    /**
     * The value of the price change for the contract from the previous trading day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'change': number;
    /**
     * The percent of the price change for the contract from the previous trading day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'change_percent': number;
    /**
     * The closing price for the contract of the day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'close': number;
    /**
     * The highest price for the contract of the day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'high': number;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'last_updated'?: number;
    /**
     * The lowest price for the contract of the day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'low': number;
    /**
     * The open price for the contract of the day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'open': number;
    /**
     * The closing price for the contract of previous trading day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'previous_close': number;
    /**
     * The trading volume for the contract of the day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'volume': number;
    /**
     * The trading volume weighted average price for the contract of the day.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDay
     */
    'vwap': number;
}
/**
 * The details for this contract.
 * @export
 * @interface GetOptionsChain200ResponseResultsInnerDetails
 */
export interface GetOptionsChain200ResponseResultsInnerDetails {
    /**
     * The type of contract. Can be \"put\", \"call\", or in some rare cases, \"other\".
     * @type {string}
     * @memberof GetOptionsChain200ResponseResultsInnerDetails
     */
    'contract_type': GetOptionsChain200ResponseResultsInnerDetailsContractTypeEnum;
    /**
     * The exercise style of this contract. See <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Option_style\">this link</a> for more details on exercise styles.
     * @type {string}
     * @memberof GetOptionsChain200ResponseResultsInnerDetails
     */
    'exercise_style': GetOptionsChain200ResponseResultsInnerDetailsExerciseStyleEnum;
    /**
     * The contract\'s expiration date in YYYY-MM-DD format.
     * @type {string}
     * @memberof GetOptionsChain200ResponseResultsInnerDetails
     */
    'expiration_date': string;
    /**
     * The number of shares per contract for this contract.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDetails
     */
    'shares_per_contract': number;
    /**
     * The strike price of the option contract.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerDetails
     */
    'strike_price': number;
    /**
     * The ticker symbol for the asset.
     * @type {string}
     * @memberof GetOptionsChain200ResponseResultsInnerDetails
     */
    'ticker': string;
}

/**
    * @export
    * @enum {string}
    */
export enum GetOptionsChain200ResponseResultsInnerDetailsContractTypeEnum {
    Put = 'put',
    Call = 'call',
    Other = 'other'
}
/**
    * @export
    * @enum {string}
    */
export enum GetOptionsChain200ResponseResultsInnerDetailsExerciseStyleEnum {
    American = 'american',
    European = 'european',
    Bermudan = 'bermudan'
}

/**
 * The most recent quote for this contract. This is only returned if your current plan includes quotes.
 * @export
 * @interface GetOptionsChain200ResponseResultsInnerLastQuote
 */
export interface GetOptionsChain200ResponseResultsInnerLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'ask': number;
    /**
     * The ask side exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'ask_exchange'?: number;
    /**
     * The ask size.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'ask_size': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'bid': number;
    /**
     * The bid side exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'bid_exchange'?: number;
    /**
     * The bid size.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'bid_size': number;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'last_updated'?: number;
    /**
     * The average of the bid and ask price.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'midpoint': number;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof GetOptionsChain200ResponseResultsInnerLastQuote
     */
    'timeframe'?: GetOptionsChain200ResponseResultsInnerLastQuoteTimeframeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetOptionsChain200ResponseResultsInnerLastQuoteTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * The most recent trade for this contract. This is only returned if your current plan includes trades.
 * @export
 * @interface GetOptionsChain200ResponseResultsInnerLastTrade
 */
export interface GetOptionsChain200ResponseResultsInnerLastTrade {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetOptionsChain200ResponseResultsInnerLastTrade
     */
    'conditions'?: Array<number>;
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/options/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastTrade
     */
    'exchange': number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastTrade
     */
    'price': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastTrade
     */
    'sip_timestamp': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof GetOptionsChain200ResponseResultsInnerLastTrade
     */
    'size': number;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof GetOptionsChain200ResponseResultsInnerLastTrade
     */
    'timeframe'?: GetOptionsChain200ResponseResultsInnerLastTradeTimeframeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetOptionsChain200ResponseResultsInnerLastTradeTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * 
 * @export
 * @interface GetOptionsContract200Response
 */
export interface GetOptionsContract200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetOptionsContract200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {ListOptionsContracts200ResponseResultsInner}
     * @memberof GetOptionsContract200Response
     */
    'results'?: ListOptionsContracts200ResponseResultsInner;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetOptionsContract200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetOptionsOpenClose200Response
 */
export interface GetOptionsOpenClose200Response {
    /**
     * The close price of the ticker symbol in after hours trading.
     * @type {number}
     * @memberof GetOptionsOpenClose200Response
     */
    'afterHours'?: number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetOptionsOpenClose200Response
     */
    'close': number;
    /**
     * The requested date.
     * @type {string}
     * @memberof GetOptionsOpenClose200Response
     */
    'from': string;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetOptionsOpenClose200Response
     */
    'high': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetOptionsOpenClose200Response
     */
    'low': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetOptionsOpenClose200Response
     */
    'open': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof GetOptionsOpenClose200Response
     */
    'otc'?: boolean;
    /**
     * The open price of the ticker symbol in pre-market trading.
     * @type {number}
     * @memberof GetOptionsOpenClose200Response
     */
    'preMarket'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetOptionsOpenClose200Response
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetOptionsOpenClose200Response
     */
    'symbol': string;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetOptionsOpenClose200Response
     */
    'volume': number;
}
/**
 * 
 * @export
 * @interface GetOptionsQuotes200Response
 */
export interface GetOptionsQuotes200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetOptionsQuotes200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetOptionsQuotes200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetOptionsQuotes200ResponseResultsInner>}
     * @memberof GetOptionsQuotes200Response
     */
    'results'?: Array<GetOptionsQuotes200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetOptionsQuotes200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetOptionsQuotes200ResponseResultsInner
 */
export interface GetOptionsQuotes200ResponseResultsInner {
    /**
     * The ask exchange ID
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'ask_exchange'?: number;
    /**
     * The ask price.
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'ask_price'?: number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'ask_size'?: number;
    /**
     * The bid exchange ID
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'bid_exchange'?: number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'bid_price'?: number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'bid_size'?: number;
    /**
     * The sequence number represents the sequence in which quote events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'sequence_number': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this quote from the exchange which produced it.
     * @type {number}
     * @memberof GetOptionsQuotes200ResponseResultsInner
     */
    'sip_timestamp': number;
}
/**
 * 
 * @export
 * @interface GetOptionsTrades200Response
 */
export interface GetOptionsTrades200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetOptionsTrades200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetOptionsTrades200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetOptionsTrades200ResponseResultsInner>}
     * @memberof GetOptionsTrades200Response
     */
    'results'?: Array<GetOptionsTrades200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetOptionsTrades200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetOptionsTrades200ResponseResultsInner
 */
export interface GetOptionsTrades200ResponseResultsInner {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetOptionsTrades200ResponseResultsInner
     */
    'conditions'?: Array<number>;
    /**
     * The trade correction indicator.
     * @type {number}
     * @memberof GetOptionsTrades200ResponseResultsInner
     */
    'correction'?: number;
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/options/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetOptionsTrades200ResponseResultsInner
     */
    'exchange': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the trade was actually generated at the exchange.
     * @type {number}
     * @memberof GetOptionsTrades200ResponseResultsInner
     */
    'participant_timestamp'?: number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetOptionsTrades200ResponseResultsInner
     */
    'price': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
     * @type {number}
     * @memberof GetOptionsTrades200ResponseResultsInner
     */
    'sip_timestamp': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof GetOptionsTrades200ResponseResultsInner
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface GetOptionsV1Exchanges200Response
 */
export interface GetOptionsV1Exchanges200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetOptionsV1Exchanges200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetOptionsV1Exchanges200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetOptionsV1Exchanges200ResponseResultsInner>}
     * @memberof GetOptionsV1Exchanges200Response
     */
    'results': Array<GetOptionsV1Exchanges200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetOptionsV1Exchanges200Response
     */
    'status': GetOptionsV1Exchanges200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetOptionsV1Exchanges200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetOptionsV1Exchanges200ResponseResultsInner
 */
export interface GetOptionsV1Exchanges200ResponseResultsInner {
    /**
     * Exchange acronym or short name (e.g., \'ISE\', \'GEMX\') - may be null for some venues.
     * @type {string}
     * @memberof GetOptionsV1Exchanges200ResponseResultsInner
     */
    'acronym'?: string;
    /**
     * Numeric identifier for the options trading venue or exchange.
     * @type {string}
     * @memberof GetOptionsV1Exchanges200ResponseResultsInner
     */
    'id': string;
    /**
     * Geographic location code.
     * @type {string}
     * @memberof GetOptionsV1Exchanges200ResponseResultsInner
     */
    'locale'?: string;
    /**
     * Market Identifier Code (MIC) - ISO 10383 standard four-character code identifying the specific options market.
     * @type {string}
     * @memberof GetOptionsV1Exchanges200ResponseResultsInner
     */
    'mic'?: string;
    /**
     * Full official name of the options exchange or trading venue.
     * @type {string}
     * @memberof GetOptionsV1Exchanges200ResponseResultsInner
     */
    'name': string;
    /**
     * Operating Market Identifier Code - identifies the parent organization or operating entity.
     * @type {string}
     * @memberof GetOptionsV1Exchanges200ResponseResultsInner
     */
    'operating_mic'?: string;
    /**
     * Single-character participant identifier used in consolidator market data feeds and options trade reporting.
     * @type {string}
     * @memberof GetOptionsV1Exchanges200ResponseResultsInner
     */
    'participant_id'?: string;
    /**
     * Type of venue: \'exchange\' for options exchanges, \'SIP\' for Securities Information Processors like OPRA (Options Price Reporting Authority).
     * @type {string}
     * @memberof GetOptionsV1Exchanges200ResponseResultsInner
     */
    'type': string;
    /**
     * Official website URL of the organization operating the options exchange.
     * @type {string}
     * @memberof GetOptionsV1Exchanges200ResponseResultsInner
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface GetPreviousCryptoAggregates200Response
 */
export interface GetPreviousCryptoAggregates200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetPreviousCryptoAggregates200Response
     */
    'ticker': string;
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof GetPreviousCryptoAggregates200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof GetPreviousCryptoAggregates200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetPreviousCryptoAggregates200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetPreviousCryptoAggregates200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetPreviousCryptoAggregates200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>}
     * @memberof GetPreviousCryptoAggregates200Response
     */
    'results'?: Array<GetGroupedCryptoAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetPreviousForexAggregates200Response
 */
export interface GetPreviousForexAggregates200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetPreviousForexAggregates200Response
     */
    'ticker': string;
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof GetPreviousForexAggregates200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof GetPreviousForexAggregates200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetPreviousForexAggregates200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetPreviousForexAggregates200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetPreviousForexAggregates200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetPreviousForexAggregates200ResponseAllOfResultsInner>}
     * @memberof GetPreviousForexAggregates200Response
     */
    'results'?: Array<GetPreviousForexAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetPreviousForexAggregates200ResponseAllOfResultsInner
 */
export interface GetPreviousForexAggregates200ResponseAllOfResultsInner {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'T': string;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetPreviousForexAggregates200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface GetPreviousIndicesAggregates200Response
 */
export interface GetPreviousIndicesAggregates200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetPreviousIndicesAggregates200Response
     */
    'ticker': string;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof GetPreviousIndicesAggregates200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetPreviousIndicesAggregates200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetPreviousIndicesAggregates200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetPreviousIndicesAggregates200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetPreviousIndicesAggregates200ResponseAllOfResultsInner>}
     * @memberof GetPreviousIndicesAggregates200Response
     */
    'results'?: Array<GetPreviousIndicesAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface GetPreviousIndicesAggregates200ResponseAllOfResultsInner
 */
export interface GetPreviousIndicesAggregates200ResponseAllOfResultsInner {
    /**
     * The close value for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousIndicesAggregates200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest value for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousIndicesAggregates200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest value for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousIndicesAggregates200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The open value for the symbol in the given time period.
     * @type {number}
     * @memberof GetPreviousIndicesAggregates200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetPreviousIndicesAggregates200ResponseAllOfResultsInner
     */
    't': number;
}
/**
 * 
 * @export
 * @interface GetRelatedCompanies200Response
 */
export interface GetRelatedCompanies200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetRelatedCompanies200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetRelatedCompanies200ResponseResultsInner>}
     * @memberof GetRelatedCompanies200Response
     */
    'results'?: Array<GetRelatedCompanies200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetRelatedCompanies200Response
     */
    'status'?: string;
    /**
     * The ticker being queried.
     * @type {string}
     * @memberof GetRelatedCompanies200Response
     */
    'ticker'?: string;
}
/**
 * The tickers related to the requested ticker.
 * @export
 * @interface GetRelatedCompanies200ResponseResultsInner
 */
export interface GetRelatedCompanies200ResponseResultsInner {
    /**
     * A ticker related to the requested ticker.
     * @type {string}
     * @memberof GetRelatedCompanies200ResponseResultsInner
     */
    'ticker': string;
}
/**
 * 
 * @export
 * @interface GetSnapshotSummary200Response
 */
export interface GetSnapshotSummary200Response {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetSnapshotSummary200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetSnapshotSummary200ResponseResultsInner>}
     * @memberof GetSnapshotSummary200Response
     */
    'results'?: Array<GetSnapshotSummary200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetSnapshotSummary200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetSnapshotSummary200ResponseResultsInner
 */
export interface GetSnapshotSummary200ResponseResultsInner {
    /**
     * 
     * @type {GetSnapshotSummary200ResponseResultsInnerBranding}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'branding'?: GetSnapshotSummary200ResponseResultsInnerBranding;
    /**
     * The error while looking for this ticker.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'error'?: string;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'last_updated'?: number;
    /**
     * The market status for the market that trades this ticker.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'market_status'?: string;
    /**
     * The error message while looking for this ticker.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'message'?: string;
    /**
     * Name of ticker, forex, or crypto asset.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'name'?: string;
    /**
     * 
     * @type {GetSnapshotSummary200ResponseResultsInnerOptions}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'options'?: GetSnapshotSummary200ResponseResultsInnerOptions;
    /**
     * The most up to date ticker price.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'price'?: number;
    /**
     * 
     * @type {GetSnapshotSummary200ResponseResultsInnerSession}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'session'?: GetSnapshotSummary200ResponseResultsInnerSession;
    /**
     * Ticker of asset queried.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The market for this ticker of stock, crypto, fx, option.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInner
     */
    'type'?: GetSnapshotSummary200ResponseResultsInnerTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetSnapshotSummary200ResponseResultsInnerTypeEnum {
    Stocks = 'stocks',
    Crypto = 'crypto',
    Options = 'options',
    Fx = 'fx'
}

/**
 * 
 * @export
 * @interface GetSnapshotSummary200ResponseResultsInnerBranding
 */
export interface GetSnapshotSummary200ResponseResultsInnerBranding {
    /**
     * A link to this ticker\'s company\'s icon. Icon\'s are generally smaller, square images that represent the company at a glance. Note that you must provide an API key when accessing this URL. See the \"Authentication\" section at the top of this page for more details.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInnerBranding
     */
    'icon_url'?: string;
    /**
     * A link to this ticker\'s company\'s logo. Note that you must provide an API key when accessing this URL. See the \"Authentication\" section at the top of this page for more details.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInnerBranding
     */
    'logo_url'?: string;
}
/**
 * 
 * @export
 * @interface GetSnapshotSummary200ResponseResultsInnerOptions
 */
export interface GetSnapshotSummary200ResponseResultsInnerOptions {
    /**
     * The type of contract. Can be \"put\", \"call\", or in some rare cases, \"other\".
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInnerOptions
     */
    'contract_type': GetSnapshotSummary200ResponseResultsInnerOptionsContractTypeEnum;
    /**
     * The exercise style of this contract. See <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Option_style\">this link</a> for more details on exercise styles.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInnerOptions
     */
    'exercise_style': GetSnapshotSummary200ResponseResultsInnerOptionsExerciseStyleEnum;
    /**
     * The contract\'s expiration date in YYYY-MM-DD format.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInnerOptions
     */
    'expiration_date': string;
    /**
     * The number of shares per contract for this contract.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerOptions
     */
    'shares_per_contract': number;
    /**
     * The strike price of the option contract.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerOptions
     */
    'strike_price': number;
    /**
     * The ticker for the option contract.
     * @type {string}
     * @memberof GetSnapshotSummary200ResponseResultsInnerOptions
     */
    'underlying_ticker': string;
}

/**
    * @export
    * @enum {string}
    */
export enum GetSnapshotSummary200ResponseResultsInnerOptionsContractTypeEnum {
    Put = 'put',
    Call = 'call',
    Other = 'other'
}
/**
    * @export
    * @enum {string}
    */
export enum GetSnapshotSummary200ResponseResultsInnerOptionsExerciseStyleEnum {
    American = 'american',
    European = 'european',
    Bermudan = 'bermudan'
}

/**
 * Comprehensive trading session metrics, detailing price changes, trading volume, and key price points (open, close, high, low) for the asset within the current trading day. Includes specific changes during early, regular, and late trading periods to enable detailed performance analysis and trend tracking.
 * @export
 * @interface GetSnapshotSummary200ResponseResultsInnerSession
 */
export interface GetSnapshotSummary200ResponseResultsInnerSession {
    /**
     * The value of the price change for the asset from the previous trading day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'change': number;
    /**
     * The percent of the price change for the asset from the previous trading day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'change_percent': number;
    /**
     * The closing price of the asset for the day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'close': number;
    /**
     * Today\'s early trading change amount, difference between price and previous close if in early trading hours, otherwise difference between last price during early trading and previous close.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'early_trading_change'?: number;
    /**
     * Today\'s early trading change as a percentage.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'early_trading_change_percent'?: number;
    /**
     * The highest price of the asset for the day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'high': number;
    /**
     * Today\'s late trading change amount, difference between price and today\'s close if in late trading hours, otherwise difference between last price during late trading and today\'s close.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'late_trading_change'?: number;
    /**
     * Today\'s late trading change as a percentage.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'late_trading_change_percent'?: number;
    /**
     * The lowest price of the asset for the day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'low': number;
    /**
     * The open price of the asset for the day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'open': number;
    /**
     * The closing price of the asset for the previous trading day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'previous_close': number;
    /**
     * The price of the most recent trade or bid price for this asset.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'price'?: number;
    /**
     * Today\'s change in regular trading hours, difference between current price and previous trading day\'s close, otherwise difference between today\'s close and previous day\'s close.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'regular_trading_change'?: number;
    /**
     * Today\'s regular trading change as a percentage.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'regular_trading_change_percent'?: number;
    /**
     * The trading volume for the asset for the day.
     * @type {number}
     * @memberof GetSnapshotSummary200ResponseResultsInnerSession
     */
    'volume'?: number;
}
/**
 * 
 * @export
 * @interface GetSnapshots200Response
 */
export interface GetSnapshots200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetSnapshots200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetSnapshots200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetSnapshots200ResponseResultsInner>}
     * @memberof GetSnapshots200Response
     */
    'results'?: Array<GetSnapshots200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetSnapshots200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetSnapshots200ResponseResultsInner
 */
export interface GetSnapshots200ResponseResultsInner {
    /**
     * The price of the underlying asset for the contract to break even. For a call, this value is (strike price + premium paid). For a put, this value is (strike price - premium paid).
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'break_even_price'?: number;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerDetails}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'details'?: GetSnapshots200ResponseResultsInnerDetails;
    /**
     * The error while looking for this ticker.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'error'?: string;
    /**
     * Fair Market Value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://massive.com/contact\">contact us</a>.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'fmv'?: number;
    /**
     * If Fair Market Value (FMV) is available, this field is the nanosecond timestamp of the last FMV calculation.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'fmv_last_updated'?: number;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerGreeks}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'greeks'?: GetSnapshots200ResponseResultsInnerGreeks;
    /**
     * The market\'s forecast for the volatility of the underlying asset, based on this option\'s current price.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'implied_volatility'?: number;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerLastMinute}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'last_minute'?: GetSnapshots200ResponseResultsInnerLastMinute;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerLastQuote}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'last_quote'?: GetSnapshots200ResponseResultsInnerLastQuote;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerLastTrade}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'last_trade'?: GetSnapshots200ResponseResultsInnerLastTrade;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'last_updated'?: number;
    /**
     * The market status for the market that trades this ticker. Possible values for stocks, options, crypto, and forex snapshots are open, closed, early_trading, or late_trading. Possible values for indices snapshots are regular_trading, closed, early_trading, and late_trading.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'market_status'?: string;
    /**
     * The error message while looking for this ticker.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'message'?: string;
    /**
     * The name of this contract.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'name'?: string;
    /**
     * The quantity of this contract held at the end of the last trading day.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'open_interest'?: number;
    /**
     * 
     * @type {GetSnapshotSummary200ResponseResultsInnerSession}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'session'?: GetSnapshotSummary200ResponseResultsInnerSession;
    /**
     * The ticker symbol for the asset.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'timeframe'?: GetSnapshots200ResponseResultsInnerTimeframeEnum;
    /**
     * The asset class for this ticker.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'type'?: GetSnapshots200ResponseResultsInnerTypeEnum;
    /**
     * 
     * @type {GetSnapshots200ResponseResultsInnerUnderlyingAsset}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'underlying_asset'?: GetSnapshots200ResponseResultsInnerUnderlyingAsset;
    /**
     * Value of Index.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInner
     */
    'value'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum GetSnapshots200ResponseResultsInnerTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}
/**
    * @export
    * @enum {string}
    */
export enum GetSnapshots200ResponseResultsInnerTypeEnum {
    Stocks = 'stocks',
    Options = 'options',
    Fx = 'fx',
    Crypto = 'crypto',
    Indices = 'indices'
}

/**
 * The details for this contract.
 * @export
 * @interface GetSnapshots200ResponseResultsInnerDetails
 */
export interface GetSnapshots200ResponseResultsInnerDetails {
    /**
     * The type of contract. Can be \"put\", \"call\", or in some rare cases, \"other\".
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerDetails
     */
    'contract_type': GetSnapshots200ResponseResultsInnerDetailsContractTypeEnum;
    /**
     * The exercise style of this contract. See <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Option_style\">this link</a> for more details on exercise styles.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerDetails
     */
    'exercise_style': GetSnapshots200ResponseResultsInnerDetailsExerciseStyleEnum;
    /**
     * The contract\'s expiration date in YYYY-MM-DD format.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerDetails
     */
    'expiration_date': string;
    /**
     * The number of shares per contract for this contract.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerDetails
     */
    'shares_per_contract': number;
    /**
     * The strike price of the option contract.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerDetails
     */
    'strike_price': number;
}

/**
    * @export
    * @enum {string}
    */
export enum GetSnapshots200ResponseResultsInnerDetailsContractTypeEnum {
    Put = 'put',
    Call = 'call',
    Other = 'other'
}
/**
    * @export
    * @enum {string}
    */
export enum GetSnapshots200ResponseResultsInnerDetailsExerciseStyleEnum {
    American = 'american',
    European = 'european',
    Bermudan = 'bermudan'
}

/**
 * The greeks for this contract. There are certain circumstances where greeks will not be returned, such as options contracts that are deep in the money. See this <a href=\"https://massive.com/blog/greeks-and-implied-volatility/#testing\" alt=\"link\">article</a> for more information.
 * @export
 * @interface GetSnapshots200ResponseResultsInnerGreeks
 */
export interface GetSnapshots200ResponseResultsInnerGreeks {
    /**
     * The change in the option\'s price per $0.01 increment in the price of the underlying asset.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerGreeks
     */
    'delta': number;
    /**
     * The change in delta per $0.01 change in the price of the underlying asset.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerGreeks
     */
    'gamma': number;
    /**
     * The change in the option\'s price per day.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerGreeks
     */
    'theta': number;
    /**
     * The change in the option\'s price per 1% increment in volatility.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerGreeks
     */
    'vega': number;
}
/**
 * The most recent minute aggregate for this stock.
 * @export
 * @interface GetSnapshots200ResponseResultsInnerLastMinute
 */
export interface GetSnapshots200ResponseResultsInnerLastMinute {
    /**
     * The closing value for the minute aggreate.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastMinute
     */
    'close': number;
    /**
     * The highest value for the minute aggregate.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastMinute
     */
    'high': number;
    /**
     * The lowest value for the minute aggregate.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastMinute
     */
    'low': number;
    /**
     * The open value for the minute aggregate.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastMinute
     */
    'open': number;
    /**
     * The number of transactions that took place within the minute aggregate.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastMinute
     */
    'transactions': number;
    /**
     * The trading volume for the minute aggregate.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastMinute
     */
    'volume': number;
    /**
     * The trading volume weighted average price for the minute aggregate.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastMinute
     */
    'vwap': number;
}
/**
 * The most recent quote for this contract. This is only returned if your current plan includes quotes.
 * @export
 * @interface GetSnapshots200ResponseResultsInnerLastQuote
 */
export interface GetSnapshots200ResponseResultsInnerLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'ask': number;
    /**
     * The ask side exchange ID. See <a href=\"https://massive.com/docs/rest/options/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'ask_exchange'?: number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'ask_size'?: number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'bid': number;
    /**
     * The bid side exchange ID. See <a href=\"https://massive.com/docs/rest/options/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'bid_exchange'?: number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'bid_size'?: number;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'last_updated': number;
    /**
     * The average of the bid and ask price.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'midpoint'?: number;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerLastQuote
     */
    'timeframe': GetSnapshots200ResponseResultsInnerLastQuoteTimeframeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetSnapshots200ResponseResultsInnerLastQuoteTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * The most recent quote for this contract. This is only returned if your current plan includes trades.
 * @export
 * @interface GetSnapshots200ResponseResultsInnerLastTrade
 */
export interface GetSnapshots200ResponseResultsInnerLastTrade {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'conditions'?: Array<number>;
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'exchange'?: number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'id'?: string;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'last_updated'?: number;
    /**
     * The nanosecond Exchange Unix Timestamp. This is the timestamp of when the trade was generated at the exchange.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'participant_timestamp'?: number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'price': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'sip_timestamp'?: number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'size': number;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerLastTrade
     */
    'timeframe'?: GetSnapshots200ResponseResultsInnerLastTradeTimeframeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetSnapshots200ResponseResultsInnerLastTradeTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * Information on the underlying stock for this options contract.  The market data returned depends on your current stocks plan.
 * @export
 * @interface GetSnapshots200ResponseResultsInnerUnderlyingAsset
 */
export interface GetSnapshots200ResponseResultsInnerUnderlyingAsset {
    /**
     * The change in price for the contract to break even.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerUnderlyingAsset
     */
    'change_to_break_even': number;
    /**
     * The nanosecond timestamp of when this information was updated.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerUnderlyingAsset
     */
    'last_updated'?: number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerUnderlyingAsset
     */
    'price'?: number;
    /**
     * The ticker symbol for the contract\'s underlying asset.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerUnderlyingAsset
     */
    'ticker': string;
    /**
     * The time relevance of the data.
     * @type {string}
     * @memberof GetSnapshots200ResponseResultsInnerUnderlyingAsset
     */
    'timeframe'?: GetSnapshots200ResponseResultsInnerUnderlyingAssetTimeframeEnum;
    /**
     * The value of the underlying index.
     * @type {number}
     * @memberof GetSnapshots200ResponseResultsInnerUnderlyingAsset
     */
    'value'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum GetSnapshots200ResponseResultsInnerUnderlyingAssetTimeframeEnum {
    Delayed = 'DELAYED',
    RealTime = 'REAL-TIME'
}

/**
 * 
 * @export
 * @interface GetStocksAggregates200Response
 */
export interface GetStocksAggregates200Response {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetStocksAggregates200Response
     */
    'ticker': string;
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof GetStocksAggregates200Response
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof GetStocksAggregates200Response
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksAggregates200Response
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetStocksAggregates200Response
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksAggregates200Response
     */
    'status': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetStocksAggregates200ResponseAllOfResultsInner>}
     * @memberof GetStocksAggregates200Response
     */
    'results'?: Array<GetStocksAggregates200ResponseAllOfResultsInner>;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetStocksAggregates200Response
     */
    'next_url'?: string;
}
/**
 * 
 * @export
 * @interface GetStocksAggregates200ResponseAllOfResultsInner
 */
export interface GetStocksAggregates200ResponseAllOfResultsInner {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'otc'?: boolean;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetStocksAggregates200ResponseAllOfResultsInner
     */
    'vw'?: number;
}
/**
 * 
 * @export
 * @interface GetStocksFinancialsV1BalanceSheets200Response
 */
export interface GetStocksFinancialsV1BalanceSheets200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetStocksFinancialsV1BalanceSheets200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksFinancialsV1BalanceSheets200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetStocksFinancialsV1BalanceSheets200ResponseResultsInner>}
     * @memberof GetStocksFinancialsV1BalanceSheets200Response
     */
    'results': Array<GetStocksFinancialsV1BalanceSheets200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksFinancialsV1BalanceSheets200Response
     */
    'status': GetStocksFinancialsV1BalanceSheets200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetStocksFinancialsV1BalanceSheets200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
 */
export interface GetStocksFinancialsV1BalanceSheets200ResponseResultsInner {
    /**
     * Amounts owed to suppliers and vendors for goods and services purchased on credit.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'accounts_payable'?: number;
    /**
     * Current liabilities not classified elsewhere, including accrued expenses, taxes payable, and other obligations due within one year.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'accrued_and_other_current_liabilities'?: number;
    /**
     * Cumulative gains and losses that bypass the income statement, including foreign currency translation adjustments and unrealized gains/losses on securities.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'accumulated_other_comprehensive_income'?: number;
    /**
     * Amount received from shareholders in excess of the par or stated value of shares issued.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'additional_paid_in_capital'?: number;
    /**
     * Cash on hand and short-term, highly liquid investments that are readily convertible to known amounts of cash.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'cash_and_equivalents'?: number;
    /**
     * The company\'s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a company\'s CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
     * @type {string}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'cik'?: string;
    /**
     * Disclosed amount related to contractual commitments and potential liabilities that may arise from uncertain future events.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'commitments_and_contingencies'?: number;
    /**
     * Par or stated value of common shares outstanding representing basic ownership in the company.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'common_stock'?: number;
    /**
     * Short-term borrowings and the current portion of long-term debt due within one year.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'debt_current'?: number;
    /**
     * Customer payments received in advance for goods or services to be delivered within one year.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'deferred_revenue_current'?: number;
    /**
     * The date when the financial statement was filed with the SEC.
     * @type {string}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'filing_date'?: string;
    /**
     * The fiscal quarter number (1, 2, 3, or 4) for the reporting period.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'fiscal_quarter'?: number;
    /**
     * The fiscal year for the reporting period.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'fiscal_year'?: number;
    /**
     * Intangible asset representing the excess of purchase price over fair value of net assets acquired in business combinations.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'goodwill'?: number;
    /**
     * Intangible assets other than goodwill, including patents, trademarks, and customer relationships, net of accumulated amortization.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'intangible_assets_net'?: number;
    /**
     * Raw materials, work-in-process, and finished goods held for sale in the ordinary course of business.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'inventories'?: number;
    /**
     * Long-term borrowings and capital lease obligations with maturities greater than one year.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'long_term_debt_and_capital_lease_obligations'?: number;
    /**
     * Equity in consolidated subsidiaries not owned by the parent company, representing minority shareholders\' ownership.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'noncontrolling_interest'?: number;
    /**
     * Non-current assets not classified elsewhere, including long-term investments, deferred tax assets, and other long-term assets.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'other_assets'?: number;
    /**
     * Current assets not classified elsewhere, including prepaid expenses, taxes receivable, and other assets expected to be converted to cash within one year.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'other_current_assets'?: number;
    /**
     * Equity components not classified elsewhere in shareholders\' equity.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'other_equity'?: number;
    /**
     * Non-current liabilities not classified elsewhere, including deferred tax liabilities, pension obligations, and other long-term liabilities.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'other_noncurrent_liabilities'?: number;
    /**
     * The last date of the reporting period, representing the specific point in time when the balance sheet snapshot was taken.
     * @type {string}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'period_end'?: string;
    /**
     * Par or stated value of preferred shares outstanding with preferential rights over common stock.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'preferred_stock'?: number;
    /**
     * Tangible fixed assets used in operations, reported net of accumulated depreciation.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'property_plant_equipment_net'?: number;
    /**
     * Amounts owed to the company by customers and other parties, primarily accounts receivable, net of allowances for doubtful accounts.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'receivables'?: number;
    /**
     * Cumulative net income earned by the company less dividends paid to shareholders since inception.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'retained_earnings_deficit'?: number;
    /**
     * Marketable securities and other investments with maturities of one year or less that are not classified as cash equivalents.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'short_term_investments'?: number;
    /**
     * A list of ticker symbols under which the company is listed. Multiple symbols may indicate different share classes for the same company.
     * @type {Array<string>}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'tickers'?: Array<string>;
    /**
     * The reporting period type. Possible values include: quarterly, annual.
     * @type {string}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'timeframe': string;
    /**
     * Sum of all current and non-current assets representing everything the company owns or controls.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'total_assets'?: number;
    /**
     * Sum of all current assets expected to be converted to cash, sold, or consumed within one year.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'total_current_assets'?: number;
    /**
     * Sum of all liabilities expected to be settled within one year.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'total_current_liabilities'?: number;
    /**
     * Sum of all equity components representing shareholders\' total ownership interest in the company.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'total_equity'?: number;
    /**
     * Total shareholders\' equity attributable to the parent company, excluding noncontrolling interests.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'total_equity_attributable_to_parent'?: number;
    /**
     * Sum of all current and non-current liabilities representing everything the company owes.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'total_liabilities'?: number;
    /**
     * Sum of total liabilities and total equity, which should equal total assets per the fundamental accounting equation.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'total_liabilities_and_equity'?: number;
    /**
     * Cost of the company\'s own shares that have been repurchased and are held in treasury, typically reported as a negative value.
     * @type {number}
     * @memberof GetStocksFinancialsV1BalanceSheets200ResponseResultsInner
     */
    'treasury_stock'?: number;
}
/**
 * 
 * @export
 * @interface GetStocksFinancialsV1CashFlowStatements200Response
 */
export interface GetStocksFinancialsV1CashFlowStatements200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetStocksFinancialsV1CashFlowStatements200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksFinancialsV1CashFlowStatements200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner>}
     * @memberof GetStocksFinancialsV1CashFlowStatements200Response
     */
    'results': Array<GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksFinancialsV1CashFlowStatements200Response
     */
    'status': GetStocksFinancialsV1CashFlowStatements200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetStocksFinancialsV1CashFlowStatements200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
 */
export interface GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner {
    /**
     * Cash generated from continuing business operations before discontinued operations.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'cash_from_operating_activities_continuing_operations'?: number;
    /**
     * Net change in cash and cash equivalents during the period, representing the sum of operating, investing, and financing cash flows plus currency effects.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'change_in_cash_and_equivalents'?: number;
    /**
     * Net change in working capital components including accounts receivable, inventory, accounts payable, and other operating items.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'change_in_other_operating_assets_and_liabilities_net'?: number;
    /**
     * The company\'s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
     * @type {string}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'cik'?: string;
    /**
     * Non-cash charges for the reduction in value of tangible and intangible assets over time.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'depreciation_depletion_and_amortization'?: number;
    /**
     * Cash payments to shareholders in the form of dividends, typically reported as negative values.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'dividends'?: number;
    /**
     * Impact of foreign exchange rate changes on cash and cash equivalents denominated in foreign currencies.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'effect_of_currency_exchange_rate'?: number;
    /**
     * The date when the financial statement was filed with the SEC.
     * @type {string}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'filing_date'?: string;
    /**
     * The fiscal quarter number (1, 2, 3, or 4) for the reporting period.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'fiscal_quarter'?: number;
    /**
     * The fiscal year for the reporting period.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'fiscal_year'?: number;
    /**
     * After-tax income or loss from business operations that have been discontinued.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'income_loss_from_discontinued_operations'?: number;
    /**
     * Net cash flows from issuing or repaying long-term debt obligations.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'long_term_debt_issuances_repayments'?: number;
    /**
     * Total cash generated or used by financing activities, including debt issuance, debt repayment, dividends, and share transactions.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'net_cash_from_financing_activities'?: number;
    /**
     * Cash flows from financing activities of continuing operations before discontinued operations.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'net_cash_from_financing_activities_continuing_operations'?: number;
    /**
     * Cash flows from financing activities of discontinued business segments.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'net_cash_from_financing_activities_discontinued_operations'?: number;
    /**
     * Total cash generated or used by investing activities, including capital expenditures, acquisitions, and asset sales.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'net_cash_from_investing_activities'?: number;
    /**
     * Cash flows from investing activities of continuing operations before discontinued operations.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'net_cash_from_investing_activities_continuing_operations'?: number;
    /**
     * Cash flows from investing activities of discontinued business segments.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'net_cash_from_investing_activities_discontinued_operations'?: number;
    /**
     * Total cash generated or used by operating activities, representing cash flow from core business operations.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'net_cash_from_operating_activities'?: number;
    /**
     * Cash flows from operating activities of discontinued business segments.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'net_cash_from_operating_activities_discontinued_operations'?: number;
    /**
     * Net income used as the starting point for operating cash flow calculations.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'net_income'?: number;
    /**
     * Cash flows related to minority shareholders in consolidated subsidiaries.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'noncontrolling_interests'?: number;
    /**
     * Other miscellaneous adjustments to cash flows not classified elsewhere.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'other_cash_adjustments'?: number;
    /**
     * Cash flows from financing activities not classified elsewhere, including share repurchases and other equity transactions.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'other_financing_activities'?: number;
    /**
     * Cash flows from investing activities not classified elsewhere, including acquisitions, divestitures, and investments.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'other_investing_activities'?: number;
    /**
     * Other adjustments to reconcile net income to operating cash flow not classified elsewhere.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'other_operating_activities'?: number;
    /**
     * The last date of the reporting period (formatted as YYYY-MM-DD).
     * @type {string}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'period_end'?: string;
    /**
     * Cash outflows for capital expenditures on fixed assets, typically reported as negative values.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'purchase_of_property_plant_and_equipment'?: number;
    /**
     * Cash inflows from disposing of fixed assets, typically reported as positive values.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'sale_of_property_plant_and_equipment'?: number;
    /**
     * Net cash flows from issuing or repaying short-term debt obligations.
     * @type {number}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'short_term_debt_issuances_repayments'?: number;
    /**
     * A list of ticker symbols under which the company is listed. Multiple symbols may indicate different share classes for the same company.
     * @type {Array<string>}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'tickers'?: Array<string>;
    /**
     * The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months.
     * @type {string}
     * @memberof GetStocksFinancialsV1CashFlowStatements200ResponseResultsInner
     */
    'timeframe'?: string;
}
/**
 * 
 * @export
 * @interface GetStocksFinancialsV1IncomeStatements200Response
 */
export interface GetStocksFinancialsV1IncomeStatements200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetStocksFinancialsV1IncomeStatements200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksFinancialsV1IncomeStatements200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetStocksFinancialsV1IncomeStatements200ResponseResultsInner>}
     * @memberof GetStocksFinancialsV1IncomeStatements200Response
     */
    'results': Array<GetStocksFinancialsV1IncomeStatements200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksFinancialsV1IncomeStatements200Response
     */
    'status': GetStocksFinancialsV1IncomeStatements200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetStocksFinancialsV1IncomeStatements200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
 */
export interface GetStocksFinancialsV1IncomeStatements200ResponseResultsInner {
    /**
     * Earnings per share calculated using the weighted average number of basic shares outstanding. For TTM records, recalculated as TTM net income divided by average basic shares outstanding over the four quarters.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'basic_earnings_per_share'?: number;
    /**
     * Weighted average number of common shares outstanding during the period, used in basic EPS calculation. For TTM records, represents the average over the four most recent quarters.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'basic_shares_outstanding'?: number;
    /**
     * The company\'s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
     * @type {string}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'cik'?: string;
    /**
     * Total net income or loss for the consolidated entity including all subsidiaries.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'consolidated_net_income_loss'?: number;
    /**
     * Direct costs attributable to the production of goods or services sold, also known as cost of goods sold (COGS).
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'cost_of_revenue'?: number;
    /**
     * Non-cash expenses representing the allocation of asset costs over their useful lives.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'depreciation_depletion_amortization'?: number;
    /**
     * Earnings per share calculated using diluted shares outstanding, including the effect of potentially dilutive securities. For TTM records, recalculated as TTM net income divided by average diluted shares outstanding over the four quarters.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'diluted_earnings_per_share'?: number;
    /**
     * Weighted average number of shares outstanding including the dilutive effect of stock options, warrants, and convertible securities. For TTM records, represents the average over the four most recent quarters.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'diluted_shares_outstanding'?: number;
    /**
     * After-tax results from business segments that have been or will be disposed of.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'discontinued_operations'?: number;
    /**
     * Earnings before interest, taxes, depreciation, and amortization, a measure of operating performance.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'ebitda'?: number;
    /**
     * The company\'s share of income or losses from equity method investments in affiliated companies.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'equity_in_affiliates'?: number;
    /**
     * Unusual and infrequent gains or losses that are both unusual in nature and infrequent in occurrence.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'extraordinary_items'?: number;
    /**
     * The date when the financial statement was filed with the SEC.
     * @type {string}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'filing_date'?: string;
    /**
     * The fiscal quarter number (1, 2, 3, or 4) for the reporting period.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'fiscal_quarter'?: number;
    /**
     * The fiscal year for the reporting period.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'fiscal_year'?: number;
    /**
     * Revenue minus cost of revenue, representing profit before operating expenses.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'gross_profit'?: number;
    /**
     * Pre-tax income calculated as operating income plus total other income/expense.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'income_before_income_taxes'?: number;
    /**
     * Income tax expense or benefit for the period.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'income_taxes'?: number;
    /**
     * Cost of borrowed funds, including interest on debt and other financing obligations.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'interest_expense'?: number;
    /**
     * Income earned from interest-bearing investments and cash equivalents.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'interest_income'?: number;
    /**
     * Net income or loss available to common shareholders after preferred dividends and noncontrolling interests.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'net_income_loss_attributable_common_shareholders'?: number;
    /**
     * The portion of net income attributable to minority shareholders in consolidated subsidiaries.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'noncontrolling_interest'?: number;
    /**
     * Income from operations calculated as gross profit minus total operating expenses, excluding non-operating items.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'operating_income'?: number;
    /**
     * Non-operating income and expenses not related to the company\'s core business operations.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'other_income_expense'?: number;
    /**
     * Operating expenses not classified in the main expense categories.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'other_operating_expenses'?: number;
    /**
     * The last date of the reporting period (formatted as YYYY-MM-DD).
     * @type {string}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'period_end'?: string;
    /**
     * Dividends declared on preferred stock during the period.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'preferred_stock_dividends_declared'?: number;
    /**
     * Expenses incurred for research and development activities to create new products or improve existing ones.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'research_development'?: number;
    /**
     * Total revenue or net sales for the period, representing the company\'s gross income from operations.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'revenue'?: number;
    /**
     * Expenses related to selling products and general administrative costs not directly tied to production.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'selling_general_administrative'?: number;
    /**
     * A list of ticker symbols under which the company is listed. Multiple symbols may indicate different share classes for the same company.
     * @type {Array<string>}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'tickers'?: Array<string>;
    /**
     * The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months.
     * @type {string}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'timeframe'?: string;
    /**
     * Sum of all operating expenses including cost of revenue, SG&A, R&D, depreciation, and other operating expenses.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'total_operating_expenses'?: number;
    /**
     * Net total of all non-operating income and expenses including interest income, interest expense, and other items.
     * @type {number}
     * @memberof GetStocksFinancialsV1IncomeStatements200ResponseResultsInner
     */
    'total_other_income_expense'?: number;
}
/**
 * 
 * @export
 * @interface GetStocksFinancialsV1Ratios200Response
 */
export interface GetStocksFinancialsV1Ratios200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetStocksFinancialsV1Ratios200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksFinancialsV1Ratios200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetStocksFinancialsV1Ratios200ResponseResultsInner>}
     * @memberof GetStocksFinancialsV1Ratios200Response
     */
    'results': Array<GetStocksFinancialsV1Ratios200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksFinancialsV1Ratios200Response
     */
    'status': GetStocksFinancialsV1Ratios200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetStocksFinancialsV1Ratios200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetStocksFinancialsV1Ratios200ResponseResultsInner
 */
export interface GetStocksFinancialsV1Ratios200ResponseResultsInner {
    /**
     * Average trading volume over the last 30 trading days, providing context for liquidity.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'average_volume'?: number;
    /**
     * Cash ratio, calculated as cash and cash equivalents divided by current liabilities, measuring the most liquid form of liquidity coverage.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'cash'?: number;
    /**
     * Central Index Key (CIK) number assigned by the SEC to identify the company.
     * @type {string}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'cik'?: string;
    /**
     * Current ratio, calculated as total current assets divided by total current liabilities, measuring short-term liquidity.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'current'?: number;
    /**
     * Date for which the ratios are calculated, representing the trading date with available price data.
     * @type {string}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'date': string;
    /**
     * Debt-to-equity ratio, calculated as total debt (current debt plus long-term debt) divided by total shareholders\' equity, measuring financial leverage.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'debt_to_equity'?: number;
    /**
     * Dividend yield, calculated as annual dividends per share divided by stock price, measuring the income return on investment.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'dividend_yield'?: number;
    /**
     * Earnings per share, calculated as net income available to common shareholders divided by weighted shares outstanding.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'earnings_per_share'?: number;
    /**
     * Enterprise value, calculated as market capitalization plus total debt minus cash and cash equivalents, representing total company value.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'enterprise_value'?: number;
    /**
     * Enterprise value to EBITDA ratio, calculated as enterprise value divided by EBITDA, measuring company valuation relative to earnings before interest, taxes, depreciation, and amortization.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'ev_to_ebitda'?: number;
    /**
     * Enterprise value to sales ratio, calculated as enterprise value divided by revenue, measuring company valuation relative to sales.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'ev_to_sales'?: number;
    /**
     * Free cash flow, calculated as operating cash flow minus capital expenditures (purchase of property, plant, and equipment).
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'free_cash_flow'?: number;
    /**
     * Market capitalization, calculated as stock price multiplied by total shares outstanding.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'market_cap'?: number;
    /**
     * Stock price used in ratio calculations, typically the closing price for the given date.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'price': number;
    /**
     * Price-to-book ratio, calculated as stock price divided by book value per share, comparing market value to book value.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'price_to_book'?: number;
    /**
     * Price-to-cash-flow ratio, calculated as stock price divided by operating cash flow per share. Only calculated when operating cash flow per share is positive.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'price_to_cash_flow'?: number;
    /**
     * Price-to-earnings ratio, calculated as stock price divided by earnings per share. Only calculated when earnings per share is positive.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'price_to_earnings'?: number;
    /**
     * Price-to-free-cash-flow ratio, calculated as stock price divided by free cash flow per share. Only calculated when free cash flow per share is positive.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'price_to_free_cash_flow'?: number;
    /**
     * Price-to-sales ratio, calculated as stock price divided by revenue per share, measuring valuation relative to sales.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'price_to_sales'?: number;
    /**
     * Quick ratio (acid-test ratio), calculated as (current assets minus inventories) divided by current liabilities, measuring immediate liquidity.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'quick'?: number;
    /**
     * Return on assets ratio, calculated as net income divided by total assets, measuring how efficiently a company uses its assets to generate profit.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'return_on_assets'?: number;
    /**
     * Return on equity ratio, calculated as net income divided by total shareholders\' equity, measuring profitability relative to shareholders\' equity.
     * @type {number}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'return_on_equity'?: number;
    /**
     * Stock ticker symbol for the company.
     * @type {string}
     * @memberof GetStocksFinancialsV1Ratios200ResponseResultsInner
     */
    'ticker': string;
}
/**
 * 
 * @export
 * @interface GetStocksQuotes200Response
 */
export interface GetStocksQuotes200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetStocksQuotes200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksQuotes200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetStocksQuotes200ResponseResultsInner>}
     * @memberof GetStocksQuotes200Response
     */
    'results'?: Array<GetStocksQuotes200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksQuotes200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetStocksQuotes200ResponseResultsInner
 */
export interface GetStocksQuotes200ResponseResultsInner {
    /**
     * The ask exchange ID
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'ask_exchange'?: number;
    /**
     * The ask price.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'ask_price'?: number;
    /**
     * The total number of shares available for sale at the current ask price.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'ask_size'?: number;
    /**
     * The bid exchange ID
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'bid_exchange'?: number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'bid_price'?: number;
    /**
     * The total number of shares that buyers want to purchase at the current bid price.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'bid_size'?: number;
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'conditions'?: Array<number>;
    /**
     * A list of indicator codes.
     * @type {Array<number>}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'indicators'?: Array<number>;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'participant_timestamp': number;
    /**
     * The sequence number represents the sequence in which quote events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'sequence_number': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this quote from the exchange which produced it.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'sip_timestamp': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'tape'?: number;
    /**
     * The nanosecond accuracy TRF (Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this quote.
     * @type {number}
     * @memberof GetStocksQuotes200ResponseResultsInner
     */
    'trf_timestamp'?: number;
}
/**
 * 
 * @export
 * @interface GetStocksSnapshotDirection200Response
 */
export interface GetStocksSnapshotDirection200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksSnapshotDirection200Response
     */
    'status': string;
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetStocksSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof GetStocksSnapshotDirection200Response
     */
    'tickers'?: Array<GetStocksSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface GetStocksSnapshotTicker200Response
 */
export interface GetStocksSnapshotTicker200Response {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksSnapshotTicker200Response
     */
    'status': string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksSnapshotTicker200Response
     */
    'request_id': string;
    /**
     * 
     * @type {GetStocksSnapshotTicker200ResponseAllOfTicker}
     * @memberof GetStocksSnapshotTicker200Response
     */
    'ticker'?: GetStocksSnapshotTicker200ResponseAllOfTicker;
}
/**
 * Contains the requested snapshot data for the specified ticker.
 * @export
 * @interface GetStocksSnapshotTicker200ResponseAllOfTicker
 */
export interface GetStocksSnapshotTicker200ResponseAllOfTicker {
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'day'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://massive.com/contact\">contact us</a>.
     * @type {number}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'fmv'?: number;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'lastQuote'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'lastTrade'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'min'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'prevDay'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'ticker'?: string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'todaysChange'?: number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'todaysChangePerc'?: number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof GetStocksSnapshotTicker200ResponseAllOfTicker
     */
    'updated'?: number;
}
/**
 * 
 * @export
 * @interface GetStocksSnapshotTickers200Response
 */
export interface GetStocksSnapshotTickers200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200Response
     */
    'count'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksSnapshotTickers200Response
     */
    'status': string;
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetStocksSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof GetStocksSnapshotTickers200Response
     */
    'tickers'?: Array<GetStocksSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface GetStocksSnapshotTickers200ResponseAllOfTickersInner
 */
export interface GetStocksSnapshotTickers200ResponseAllOfTickersInner {
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'day'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay;
    /**
     * Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, <a rel=\"nofollow\" target=\"_blank\" href=\"https://massive.com/contact\">contact us</a>.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'fmv'?: number;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'lastQuote'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'lastTrade'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'min'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin;
    /**
     * 
     * @type {GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'prevDay'?: GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'ticker'?: string;
    /**
     * The value of the change from the previous day.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'todaysChange'?: number;
    /**
     * The percentage change since the previous day.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'todaysChangePerc'?: number;
    /**
     * The last updated timestamp.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInner
     */
    'updated'?: number;
}
/**
 * The most recent daily bar for this ticker.
 * @export
 * @interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
 */
export interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'otc'?: boolean;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerDay
     */
    'vw': number;
}
/**
 * The most recent quote for this ticker.  This is only returned if your current plan includes quotes.
 * @export
 * @interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote
 */
export interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    'P': number;
    /**
     * The ask size in lots.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    'S': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    'p': number;
    /**
     * The bid size in lots.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    's': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastQuote
     */
    't': number;
}
/**
 * The most recent trade for this ticker.  This is only returned if your current plan includes trades.
 * @export
 * @interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade
 */
export interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade {
    /**
     * The trade conditions.
     * @type {Array<number>}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'c': Array<number>;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'p': number;
    /**
     * The size (volume) of the trade.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    's': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    't': number;
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerLastTrade
     */
    'x': number;
}
/**
 * The most recent minute bar for this ticker.
 * @export
 * @interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
 */
export interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin {
    /**
     * The accumulated volume.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'av': number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'otc'?: boolean;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerMin
     */
    'vw': number;
}
/**
 * The previous day\'s bar for this ticker.
 * @export
 * @interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
 */
export interface GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'otc'?: boolean;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof GetStocksSnapshotTickers200ResponseAllOfTickersInnerPrevDay
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface GetStocksTrades200Response
 */
export interface GetStocksTrades200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof GetStocksTrades200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksTrades200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<GetStocksTrades200ResponseResultsInner>}
     * @memberof GetStocksTrades200Response
     */
    'results'?: Array<GetStocksTrades200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksTrades200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetStocksTrades200ResponseResultsInner
 */
export interface GetStocksTrades200ResponseResultsInner {
    /**
     * A list of condition codes.
     * @type {Array<number>}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'conditions'?: Array<number>;
    /**
     * The trade correction indicator.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'correction'?: number;
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'exchange': number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
     * @type {string}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'id': string;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the trade was actually generated at the exchange.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'participant_timestamp': number;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'price': number;
    /**
     * The sequence number represents the sequence in which trade events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'sequence_number': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'sip_timestamp': number;
    /**
     * The size of a trade (also known as volume).
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'size': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'tape'?: number;
    /**
     * The ID for the Trade Reporting Facility where the trade took place.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'trf_id'?: number;
    /**
     * The nanosecond accuracy TRF (Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this trade.
     * @type {number}
     * @memberof GetStocksTrades200ResponseResultsInner
     */
    'trf_timestamp'?: number;
}
/**
 * 
 * @export
 * @interface GetStocksV1Dividends200Response
 */
export interface GetStocksV1Dividends200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetStocksV1Dividends200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksV1Dividends200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetStocksV1Dividends200ResponseResultsInner>}
     * @memberof GetStocksV1Dividends200Response
     */
    'results': Array<GetStocksV1Dividends200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksV1Dividends200Response
     */
    'status': GetStocksV1Dividends200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetStocksV1Dividends200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetStocksV1Dividends200ResponseResultsInner
 */
export interface GetStocksV1Dividends200ResponseResultsInner {
    /**
     * Original dividend amount per share in the specified currency
     * @type {number}
     * @memberof GetStocksV1Dividends200ResponseResultsInner
     */
    'cash_amount'?: number;
    /**
     * Currency code for the dividend payment (e.g., USD, CAD)
     * @type {string}
     * @memberof GetStocksV1Dividends200ResponseResultsInner
     */
    'currency'?: string;
    /**
     * Date when the company officially announced the dividend
     * @type {string}
     * @memberof GetStocksV1Dividends200ResponseResultsInner
     */
    'declaration_date'?: string;
    /**
     * Classification describing the nature of this dividend\'s recurrence pattern: recurring (paid on a regular schedule), special (one-time or commemorative), supplemental (extra beyond the regular schedule), irregular (unpredictable or non-recurring), unknown (cannot be classified from available data)
     * @type {string}
     * @memberof GetStocksV1Dividends200ResponseResultsInner
     */
    'distribution_type': string;
    /**
     * Date when the stock begins trading without the dividend value
     * @type {string}
     * @memberof GetStocksV1Dividends200ResponseResultsInner
     */
    'ex_dividend_date'?: string;
    /**
     * How many times per year this dividend is expected to occur. A value of 0 means the distribution is non-recurring or irregular (e.g., special, supplemental, or a one-off dividend). Other possible values include 1 (annual), 2 (semi-annual), 3 (trimester), 4 (quarterly), 12 (monthly), 24 (bi-monthly), 26 (bi-weekly), 52 (weekly), and 365 (daily) depending on the issuer\'s declared or inferred payout cadence.
     * @type {number}
     * @memberof GetStocksV1Dividends200ResponseResultsInner
     */
    'frequency'?: number;
    /**
     * Cumulative adjustment factor used to offset dividend effects on historical prices. To adjust a historical price for dividends: for a price on date D, find the first dividend whose `ex_dividend_date` is after date D and multiply the price by that dividend\'s `historical_adjustment_factor`.
     * @type {number}
     * @memberof GetStocksV1Dividends200ResponseResultsInner
     */
    'historical_adjustment_factor'?: number;
    /**
     * Unique identifier for each dividend record
     * @type {string}
     * @memberof GetStocksV1Dividends200ResponseResultsInner
     */
    'id'?: string;
    /**
     * Date when the dividend payment is distributed to shareholders
     * @type {string}
     * @memberof GetStocksV1Dividends200ResponseResultsInner
     */
    'pay_date'?: string;
    /**
     * Date when shareholders must be on record to be eligible for the dividend payment
     * @type {string}
     * @memberof GetStocksV1Dividends200ResponseResultsInner
     */
    'record_date'?: string;
    /**
     * Dividend amount adjusted for stock splits that occurred after the dividend was paid, expressed on a current share basis
     * @type {number}
     * @memberof GetStocksV1Dividends200ResponseResultsInner
     */
    'split_adjusted_cash_amount'?: number;
    /**
     * Stock symbol for the company issuing the dividend
     * @type {string}
     * @memberof GetStocksV1Dividends200ResponseResultsInner
     */
    'ticker'?: string;
}
/**
 * 
 * @export
 * @interface GetStocksV1Exchanges200Response
 */
export interface GetStocksV1Exchanges200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetStocksV1Exchanges200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksV1Exchanges200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetStocksV1Exchanges200ResponseResultsInner>}
     * @memberof GetStocksV1Exchanges200Response
     */
    'results': Array<GetStocksV1Exchanges200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksV1Exchanges200Response
     */
    'status': GetStocksV1Exchanges200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetStocksV1Exchanges200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetStocksV1Exchanges200ResponseResultsInner
 */
export interface GetStocksV1Exchanges200ResponseResultsInner {
    /**
     * Short acronym or abbreviation (may be null for some venues).
     * @type {string}
     * @memberof GetStocksV1Exchanges200ResponseResultsInner
     */
    'acronym'?: string;
    /**
     * Numeric identifier for the trading venue or exchange.
     * @type {string}
     * @memberof GetStocksV1Exchanges200ResponseResultsInner
     */
    'id': string;
    /**
     * Geographic location code.
     * @type {string}
     * @memberof GetStocksV1Exchanges200ResponseResultsInner
     */
    'locale'?: string;
    /**
     * Market Identifier Code (MIC) - ISO 10383 standard four-character code for the market (may be empty for some venues).
     * @type {string}
     * @memberof GetStocksV1Exchanges200ResponseResultsInner
     */
    'mic'?: string;
    /**
     * Full official name of the exchange, trading venue, or reporting facility.
     * @type {string}
     * @memberof GetStocksV1Exchanges200ResponseResultsInner
     */
    'name': string;
    /**
     * Operating Market Identifier Code - identifies the specific operating entity or parent organization.
     * @type {string}
     * @memberof GetStocksV1Exchanges200ResponseResultsInner
     */
    'operating_mic'?: string;
    /**
     * Single-character participant identifier used in market data feeds and trade reporting.
     * @type {string}
     * @memberof GetStocksV1Exchanges200ResponseResultsInner
     */
    'participant_id'?: string;
    /**
     * Type of trading venue: \'exchange\' for stock exchanges, \'TRF\' for Trade Reporting Facilities, \'SIP\' for Securities Information Processors, \'ORF\' for OTC Reporting Facility.
     * @type {string}
     * @memberof GetStocksV1Exchanges200ResponseResultsInner
     */
    'type': string;
    /**
     * Official website URL of the organization operating the venue.
     * @type {string}
     * @memberof GetStocksV1Exchanges200ResponseResultsInner
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface GetStocksV1ShortInterest200Response
 */
export interface GetStocksV1ShortInterest200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetStocksV1ShortInterest200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksV1ShortInterest200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetStocksV1ShortInterest200ResponseResultsInner>}
     * @memberof GetStocksV1ShortInterest200Response
     */
    'results': Array<GetStocksV1ShortInterest200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksV1ShortInterest200Response
     */
    'status': GetStocksV1ShortInterest200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetStocksV1ShortInterest200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetStocksV1ShortInterest200ResponseResultsInner
 */
export interface GetStocksV1ShortInterest200ResponseResultsInner {
    /**
     * The average daily trading volume for the stock over a specified period, typically used to contextualize short interest.
     * @type {number}
     * @memberof GetStocksV1ShortInterest200ResponseResultsInner
     */
    'avg_daily_volume': number;
    /**
     * Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume.
     * @type {number}
     * @memberof GetStocksV1ShortInterest200ResponseResultsInner
     */
    'days_to_cover': number;
    /**
     * The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
     * @type {string}
     * @memberof GetStocksV1ShortInterest200ResponseResultsInner
     */
    'settlement_date': string;
    /**
     * The total number of shares that have been sold short but have not yet been covered or closed out.
     * @type {number}
     * @memberof GetStocksV1ShortInterest200ResponseResultsInner
     */
    'short_interest'?: number;
    /**
     * The primary ticker symbol for the stock.
     * @type {string}
     * @memberof GetStocksV1ShortInterest200ResponseResultsInner
     */
    'ticker'?: string;
}
/**
 * 
 * @export
 * @interface GetStocksV1ShortVolume200Response
 */
export interface GetStocksV1ShortVolume200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetStocksV1ShortVolume200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksV1ShortVolume200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetStocksV1ShortVolume200ResponseResultsInner>}
     * @memberof GetStocksV1ShortVolume200Response
     */
    'results': Array<GetStocksV1ShortVolume200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksV1ShortVolume200Response
     */
    'status': GetStocksV1ShortVolume200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetStocksV1ShortVolume200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetStocksV1ShortVolume200ResponseResultsInner
 */
export interface GetStocksV1ShortVolume200ResponseResultsInner {
    /**
     * Short volume reported via the Alternative Display Facility (ADF), excluding exempt volume.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'adf_short_volume'?: number;
    /**
     * Short volume reported via ADF that was marked as exempt.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'adf_short_volume_exempt'?: number;
    /**
     * The date of trade activity reported in the format YYYY-MM-DD
     * @type {string}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'date': string;
    /**
     * Portion of short volume that was marked as exempt from regulation SHO.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'exempt_volume'?: number;
    /**
     * Short volume reported from Nasdaq\'s Carteret facility, excluding exempt volume.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'nasdaq_carteret_short_volume'?: number;
    /**
     * Short volume from Nasdaq Carteret that was marked as exempt.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'nasdaq_carteret_short_volume_exempt'?: number;
    /**
     * Short volume reported from Nasdaq\'s Chicago facility, excluding exempt volume.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'nasdaq_chicago_short_volume'?: number;
    /**
     * Short volume from Nasdaq Chicago that was marked as exempt.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'nasdaq_chicago_short_volume_exempt'?: number;
    /**
     * Portion of short volume that was not exempt from regulation SHO (i.e., short_volume - exempt_volume).
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'non_exempt_volume'?: number;
    /**
     * Short volume reported from NYSE facilities, excluding exempt volume.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'nyse_short_volume'?: number;
    /**
     * Short volume from NYSE facilities that was marked as exempt.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'nyse_short_volume_exempt'?: number;
    /**
     * Total number of shares sold short across all venues for the ticker on the given date.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'short_volume'?: number;
    /**
     * The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'short_volume_ratio'?: number;
    /**
     * The primary ticker symbol for the stock.
     * @type {string}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * Total reported volume across all venues for the ticker on the given date.
     * @type {number}
     * @memberof GetStocksV1ShortVolume200ResponseResultsInner
     */
    'total_volume'?: number;
}
/**
 * 
 * @export
 * @interface GetStocksV1Splits200Response
 */
export interface GetStocksV1Splits200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetStocksV1Splits200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetStocksV1Splits200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetStocksV1Splits200ResponseResultsInner>}
     * @memberof GetStocksV1Splits200Response
     */
    'results': Array<GetStocksV1Splits200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetStocksV1Splits200Response
     */
    'status': GetStocksV1Splits200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetStocksV1Splits200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetStocksV1Splits200ResponseResultsInner
 */
export interface GetStocksV1Splits200ResponseResultsInner {
    /**
     * Classification of the share-change event. Possible values include: forward_split (share count increases), reverse_split (share count decreases), stock_dividend (shares issued as a dividend)
     * @type {string}
     * @memberof GetStocksV1Splits200ResponseResultsInner
     */
    'adjustment_type': string;
    /**
     * Date when the stock split was applied and shares adjusted
     * @type {string}
     * @memberof GetStocksV1Splits200ResponseResultsInner
     */
    'execution_date'?: string;
    /**
     * Cumulative adjustment factor used to offset split effects on historical prices. To adjust a historical price for splits: for a price on date D, find the first split whose `execution_date` is after date D and multiply the unadjusted price by the `historical_adjustment_factor`.
     * @type {number}
     * @memberof GetStocksV1Splits200ResponseResultsInner
     */
    'historical_adjustment_factor'?: number;
    /**
     * Unique identifier for each stock split event
     * @type {string}
     * @memberof GetStocksV1Splits200ResponseResultsInner
     */
    'id'?: string;
    /**
     * Denominator of the split ratio (old shares)
     * @type {number}
     * @memberof GetStocksV1Splits200ResponseResultsInner
     */
    'split_from'?: number;
    /**
     * Numerator of the split ratio (new shares)
     * @type {number}
     * @memberof GetStocksV1Splits200ResponseResultsInner
     */
    'split_to'?: number;
    /**
     * Stock symbol for the company that executed the split
     * @type {string}
     * @memberof GetStocksV1Splits200ResponseResultsInner
     */
    'ticker'?: string;
}
/**
 * 
 * @export
 * @interface GetTicker200Response
 */
export interface GetTicker200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof GetTicker200Response
     */
    'count'?: number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetTicker200Response
     */
    'request_id'?: string;
    /**
     * 
     * @type {GetTicker200ResponseResults}
     * @memberof GetTicker200Response
     */
    'results'?: GetTicker200ResponseResults;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetTicker200Response
     */
    'status'?: string;
}
/**
 * Ticker with details.
 * @export
 * @interface GetTicker200ResponseResults
 */
export interface GetTicker200ResponseResults {
    /**
     * Whether or not the asset is actively traded. False means the asset has been delisted.
     * @type {boolean}
     * @memberof GetTicker200ResponseResults
     */
    'active': boolean;
    /**
     * 
     * @type {GetTicker200ResponseResultsAddress}
     * @memberof GetTicker200ResponseResults
     */
    'address'?: GetTicker200ResponseResultsAddress;
    /**
     * 
     * @type {GetTicker200ResponseResultsBranding}
     * @memberof GetTicker200ResponseResults
     */
    'branding'?: GetTicker200ResponseResultsBranding;
    /**
     * The CIK number for this ticker. Find more information [here](https://en.wikipedia.org/wiki/Central_Index_Key).
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'cik'?: string;
    /**
     * The composite OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'composite_figi'?: string;
    /**
     * The name of the currency that this asset is traded with.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'currency_name': string;
    /**
     * The last date that the asset was traded.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'delisted_utc'?: string;
    /**
     * A description of the company and what they do/offer.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'description'?: string;
    /**
     * The URL of the company\'s website homepage.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'homepage_url'?: string;
    /**
     * The date that the symbol was first publicly listed in the format YYYY-MM-DD.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'list_date'?: string;
    /**
     * The locale of the asset.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'locale': GetTicker200ResponseResultsLocaleEnum;
    /**
     * The market type of the asset.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'market': GetTicker200ResponseResultsMarketEnum;
    /**
     * The most recent close price of the ticker multiplied by weighted outstanding shares.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'market_cap'?: number;
    /**
     * The name of the asset. For stocks/equities this will be the companies registered name. For crypto/fx this will be the name of the currency or coin pair.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'name': string;
    /**
     * The phone number for the company behind this ticker.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'phone_number'?: string;
    /**
     * The ISO code of the primary listing exchange for this asset.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'primary_exchange'?: string;
    /**
     * Round lot size of this security.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'round_lot'?: number;
    /**
     * The share Class OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'share_class_figi'?: string;
    /**
     * The recorded number of outstanding shares for this particular share class.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'share_class_shares_outstanding'?: number;
    /**
     * The standard industrial classification code for this ticker.  For a list of SIC Codes, see the SEC\'s <a rel=\"nofollow\" target=\"_blank\" href=\"https://www.sec.gov/info/edgar/siccodes.htm\">SIC Code List</a>.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'sic_code'?: string;
    /**
     * A description of this ticker\'s SIC code.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'sic_description'?: string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'ticker': string;
    /**
     * The root of a specified ticker. For example, the root of BRK.A is BRK.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'ticker_root'?: string;
    /**
     * The suffix of a specified ticker. For example, the suffix of BRK.A is A.
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'ticker_suffix'?: string;
    /**
     * The approximate number of employees for the company.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'total_employees'?: number;
    /**
     * The type of the asset. Find the types that we support via our [Ticker Types API](https://massive.com/docs/rest/stocks/tickers/ticker-types).
     * @type {string}
     * @memberof GetTicker200ResponseResults
     */
    'type'?: string;
    /**
     * The shares outstanding calculated assuming all shares of other share classes are converted to this share class.
     * @type {number}
     * @memberof GetTicker200ResponseResults
     */
    'weighted_shares_outstanding'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum GetTicker200ResponseResultsLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
    * @export
    * @enum {string}
    */
export enum GetTicker200ResponseResultsMarketEnum {
    Stocks = 'stocks',
    Crypto = 'crypto',
    Fx = 'fx',
    Otc = 'otc',
    Indices = 'indices'
}

/**
 * Company headquarters address details.
 * @export
 * @interface GetTicker200ResponseResultsAddress
 */
export interface GetTicker200ResponseResultsAddress {
    /**
     * The first line of the company\'s headquarters address.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'address1'?: string;
    /**
     * The second line of the company\'s headquarters address, if applicable.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'address2'?: string;
    /**
     * The city of the company\'s headquarters address.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'city'?: string;
    /**
     * The postal code of the company\'s headquarters address.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'postal_code'?: string;
    /**
     * The state of the company\'s headquarters address.
     * @type {string}
     * @memberof GetTicker200ResponseResultsAddress
     */
    'state'?: string;
}
/**
 * Provides URLs aiding in visual identification.
 * @export
 * @interface GetTicker200ResponseResultsBranding
 */
export interface GetTicker200ResponseResultsBranding {
    /**
     * A link to this ticker\'s company\'s icon. Icon\'s are generally smaller, square images that represent the company at a glance. Note that you must provide an API key when accessing this URL. See the \"Authentication\" section at the top of this page for more details.
     * @type {string}
     * @memberof GetTicker200ResponseResultsBranding
     */
    'icon_url'?: string;
    /**
     * A link to this ticker\'s company\'s logo. Note that you must provide an API key when accessing this URL. See the \"Authentication\" section at the top of this page for more details.
     * @type {string}
     * @memberof GetTicker200ResponseResultsBranding
     */
    'logo_url'?: string;
}
/**
 * 
 * @export
 * @interface GetTmxV1CorporateEvents200Response
 */
export interface GetTmxV1CorporateEvents200Response {
    /**
     * If present, this value can be used to fetch the next page.
     * @type {string}
     * @memberof GetTmxV1CorporateEvents200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof GetTmxV1CorporateEvents200Response
     */
    'request_id': string;
    /**
     * The results for this request.
     * @type {Array<GetTmxV1CorporateEvents200ResponseResultsInner>}
     * @memberof GetTmxV1CorporateEvents200Response
     */
    'results': Array<GetTmxV1CorporateEvents200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof GetTmxV1CorporateEvents200Response
     */
    'status': GetTmxV1CorporateEvents200ResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetTmxV1CorporateEvents200ResponseStatusEnum {
    Ok = 'OK'
}

/**
 * 
 * @export
 * @interface GetTmxV1CorporateEvents200ResponseResultsInner
 */
export interface GetTmxV1CorporateEvents200ResponseResultsInner {
    /**
     * Full name of the company.
     * @type {string}
     * @memberof GetTmxV1CorporateEvents200ResponseResultsInner
     */
    'company_name'?: string;
    /**
     * Scheduled date of the corporate event, formatted as YYYY-MM-DD.
     * @type {string}
     * @memberof GetTmxV1CorporateEvents200ResponseResultsInner
     */
    'date'?: string;
    /**
     * Standard international identifier for the company\'s common stock.
     * @type {string}
     * @memberof GetTmxV1CorporateEvents200ResponseResultsInner
     */
    'isin'?: string;
    /**
     * Name or title of the event.
     * @type {string}
     * @memberof GetTmxV1CorporateEvents200ResponseResultsInner
     */
    'name'?: string;
    /**
     * The current status of the event. Possible values include: approved, canceled, confirmed, historical, pending_approval, postponed, and unconfirmed.
     * @type {string}
     * @memberof GetTmxV1CorporateEvents200ResponseResultsInner
     */
    'status'?: string;
    /**
     * The company\'s stock symbol.
     * @type {string}
     * @memberof GetTmxV1CorporateEvents200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * Unique numeric identifier for the company used by TMX.
     * @type {number}
     * @memberof GetTmxV1CorporateEvents200ResponseResultsInner
     */
    'tmx_company_id'?: number;
    /**
     * The unique alphanumeric identifier for the event record used by TMX.
     * @type {string}
     * @memberof GetTmxV1CorporateEvents200ResponseResultsInner
     */
    'tmx_record_id'?: string;
    /**
     * MIC (Market Identifier Code) of the exchange where the company\'s stock is listed.
     * @type {string}
     * @memberof GetTmxV1CorporateEvents200ResponseResultsInner
     */
    'trading_venue'?: string;
    /**
     * The normalized type of corporate event. Possible values include: analyst_day, business_update, capital_markets_day, conference, dividend, earnings_announcement_date, earnings_conference_call, earnings_results_announcement, forum, interim_statement, other_interim_announcement, production_update, research_and_development_day, seminar, shareholder_meeting, sales_update, stock_split, summit, service_level_update, tradeshow, company_travel, and workshop.
     * @type {string}
     * @memberof GetTmxV1CorporateEvents200ResponseResultsInner
     */
    'type'?: string;
    /**
     * URL linking to the primary public source of the event announcement, if available.
     * @type {string}
     * @memberof GetTmxV1CorporateEvents200ResponseResultsInner
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface IndexAggsBase
 */
export interface IndexAggsBase {
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof IndexAggsBase
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof IndexAggsBase
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof IndexAggsBase
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof IndexAggsBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface IndicesGroupedResults
 */
export interface IndicesGroupedResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetPreviousIndicesAggregates200ResponseAllOfResultsInner>}
     * @memberof IndicesGroupedResults
     */
    'results'?: Array<GetPreviousIndicesAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface IndicesOpenClose
 */
export interface IndicesOpenClose {
    /**
     * The close value of the ticker symbol in after hours trading.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'afterHours'?: number;
    /**
     * The close value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'close': number;
    /**
     * The requested date.
     * @type {string}
     * @memberof IndicesOpenClose
     */
    'from': string;
    /**
     * The highest value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'high': number;
    /**
     * The lowest value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'low': number;
    /**
     * The open value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'open': number;
    /**
     * The open value of the ticker symbol in pre-market trading.
     * @type {number}
     * @memberof IndicesOpenClose
     */
    'preMarket'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof IndicesOpenClose
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof IndicesOpenClose
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface IndicesTickerResults
 */
export interface IndicesTickerResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<IndicesTickerResultsResultsInner>}
     * @memberof IndicesTickerResults
     */
    'results'?: Array<IndicesTickerResultsResultsInner>;
}
/**
 * 
 * @export
 * @interface IndicesTickerResultsResultsInner
 */
export interface IndicesTickerResultsResultsInner {
    /**
     * The close value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'c': number;
    /**
     * The highest value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'h': number;
    /**
     * The lowest value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'n'?: number;
    /**
     * The open value for the symbol in the given time period.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof IndicesTickerResultsResultsInner
     */
    't': number;
}
/**
 * 
 * @export
 * @interface ListConditions200Response
 */
export interface ListConditions200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListConditions200Response
     */
    'count': number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListConditions200Response
     */
    'next_url'?: string;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListConditions200Response
     */
    'request_id': string;
    /**
     * An array of conditions that match your query.
     * @type {Array<ListConditions200ResponseResultsInner>}
     * @memberof ListConditions200Response
     */
    'results': Array<ListConditions200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListConditions200Response
     */
    'status': string;
}
/**
 * A condition generally refers to any extra information passed in a trade or a quote. These conditions may or may not affect the behavior of aggregates.
 * @export
 * @interface ListConditions200ResponseResultsInner
 */
export interface ListConditions200ResponseResultsInner {
    /**
     * A commonly-used abbreviation for this condition.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'abbreviation'?: string;
    /**
     * An identifier for a group of similar financial instruments.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'asset_class': ListConditions200ResponseResultsInnerAssetClassEnum;
    /**
     * Data types that this condition applies to.
     * @type {Array<string>}
     * @memberof ListConditions200ResponseResultsInner
     */
    'data_types': Array<ListConditions200ResponseResultsInnerDataTypesEnum>;
    /**
     * A short description of the semantics of this condition.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'description'?: string;
    /**
     * If present, mapping this condition from a Massive code to a SIP symbol depends on this attribute. In other words, data with this condition attached comes exclusively from the given exchange.
     * @type {number}
     * @memberof ListConditions200ResponseResultsInner
     */
    'exchange'?: number;
    /**
     * An identifier used by Massive for this condition. Unique per data type.
     * @type {number}
     * @memberof ListConditions200ResponseResultsInner
     */
    'id': number;
    /**
     * If true, this condition is from an old version of the SIPs\' specs and no longer is used. Other conditions may or may not reuse the same symbol as this one.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInner
     */
    'legacy'?: boolean;
    /**
     * The name of this condition.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'name': string;
    /**
     * 
     * @type {ListConditions200ResponseResultsInnerSipMapping}
     * @memberof ListConditions200ResponseResultsInner
     */
    'sip_mapping': ListConditions200ResponseResultsInnerSipMapping;
    /**
     * An identifier for a collection of related conditions.
     * @type {string}
     * @memberof ListConditions200ResponseResultsInner
     */
    'type': ListConditions200ResponseResultsInnerTypeEnum;
    /**
     * 
     * @type {ListConditions200ResponseResultsInnerUpdateRules}
     * @memberof ListConditions200ResponseResultsInner
     */
    'update_rules'?: ListConditions200ResponseResultsInnerUpdateRules;
}

/**
    * @export
    * @enum {string}
    */
export enum ListConditions200ResponseResultsInnerAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx'
}
/**
    * @export
    * @enum {string}
    */
export enum ListConditions200ResponseResultsInnerDataTypesEnum {
    Trade = 'trade',
    Bbo = 'bbo',
    Nbbo = 'nbbo'
}
/**
    * @export
    * @enum {string}
    */
export enum ListConditions200ResponseResultsInnerTypeEnum {
    SaleCondition = 'sale_condition',
    QuoteCondition = 'quote_condition',
    SipGeneratedFlag = 'sip_generated_flag',
    FinancialStatusIndicator = 'financial_status_indicator',
    ShortSaleRestrictionIndicator = 'short_sale_restriction_indicator',
    SettlementCondition = 'settlement_condition',
    MarketCondition = 'market_condition',
    TradeThruExempt = 'trade_thru_exempt'
}

/**
 * A comprehensive mapping that translates condition codes from individual SIPs (CTA, OPRA, UTP) to a unified code used by Massive. This facilitates consistent interpretation and application of market data conditions across different data streams, ensuring that users can accurately apply these conditions to their data analysis and reporting.
 * @export
 * @interface ListConditions200ResponseResultsInnerSipMapping
 */
export interface ListConditions200ResponseResultsInnerSipMapping {
    /**
     * Condition code from the Consolidated Tape Association (CTA).
     * @type {string}
     * @memberof ListConditions200ResponseResultsInnerSipMapping
     */
    'CTA'?: string;
    /**
     * Condition code from the Options Price Reporting Authority (OPRA).
     * @type {string}
     * @memberof ListConditions200ResponseResultsInnerSipMapping
     */
    'OPRA'?: string;
    /**
     * Condition code from UTP Plan (UTP).
     * @type {string}
     * @memberof ListConditions200ResponseResultsInnerSipMapping
     */
    'UTP'?: string;
}
/**
 * A list of aggregation rules.
 * @export
 * @interface ListConditions200ResponseResultsInnerUpdateRules
 */
export interface ListConditions200ResponseResultsInnerUpdateRules {
    /**
     * 
     * @type {ListConditions200ResponseResultsInnerUpdateRulesConsolidated}
     * @memberof ListConditions200ResponseResultsInnerUpdateRules
     */
    'consolidated': ListConditions200ResponseResultsInnerUpdateRulesConsolidated;
    /**
     * 
     * @type {ListConditions200ResponseResultsInnerUpdateRulesMarketCenter}
     * @memberof ListConditions200ResponseResultsInnerUpdateRules
     */
    'market_center': ListConditions200ResponseResultsInnerUpdateRulesMarketCenter;
}
/**
 * Describes aggregation rules on a consolidated (all exchanges) basis.
 * @export
 * @interface ListConditions200ResponseResultsInnerUpdateRulesConsolidated
 */
export interface ListConditions200ResponseResultsInnerUpdateRulesConsolidated {
    /**
     * Whether or not trades with this condition update the high/low.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesConsolidated
     */
    'updates_high_low': boolean;
    /**
     * Whether or not trades with this condition update the open/close.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesConsolidated
     */
    'updates_open_close': boolean;
    /**
     * Whether or not trades with this condition update the volume.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesConsolidated
     */
    'updates_volume': boolean;
}
/**
 * Describes aggregation rules on a per-market-center basis.
 * @export
 * @interface ListConditions200ResponseResultsInnerUpdateRulesMarketCenter
 */
export interface ListConditions200ResponseResultsInnerUpdateRulesMarketCenter {
    /**
     * Whether or not trades with this condition update the high/low.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesMarketCenter
     */
    'updates_high_low': boolean;
    /**
     * Whether or not trades with this condition update the open/close.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesMarketCenter
     */
    'updates_open_close': boolean;
    /**
     * Whether or not trades with this condition update the volume.
     * @type {boolean}
     * @memberof ListConditions200ResponseResultsInnerUpdateRulesMarketCenter
     */
    'updates_volume': boolean;
}
/**
 * 
 * @export
 * @interface ListConditions400Response
 */
export interface ListConditions400Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListConditions400Response
     */
    'count': number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListConditions400Response
     */
    'next_url'?: string;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListConditions400Response
     */
    'request_id': string;
    /**
     * An array of conditions that match your query.
     * @type {Array<ListConditions200ResponseResultsInner>}
     * @memberof ListConditions400Response
     */
    'results': Array<ListConditions200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListConditions400Response
     */
    'status': string;
}
/**
 * A list of dividends.
 * @export
 * @interface ListDividends200Response
 */
export interface ListDividends200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListDividends200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListDividends200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListDividends200ResponseResultsInner>}
     * @memberof ListDividends200Response
     */
    'results'?: Array<ListDividends200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListDividends200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListDividends200ResponseResultsInner
 */
export interface ListDividends200ResponseResultsInner {
    /**
     * The cash amount of the dividend per share owned.
     * @type {number}
     * @memberof ListDividends200ResponseResultsInner
     */
    'cash_amount': number;
    /**
     * The currency in which the dividend is paid.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'currency'?: string;
    /**
     * The date that the dividend was announced.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'declaration_date'?: string;
    /**
     * The type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC. Long-Term and Short-Term capital gain distributions are denoted as LT and ST, respectively.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'dividend_type': ListDividends200ResponseResultsInnerDividendTypeEnum;
    /**
     * The date that the stock first trades without the dividend, determined by the exchange.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'ex_dividend_date': string;
    /**
     * The number of times per year the dividend is paid out. Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
     * @type {number}
     * @memberof ListDividends200ResponseResultsInner
     */
    'frequency': number;
    /**
     * The unique identifier of the dividend.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'id': string;
    /**
     * The date that the dividend is paid out.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'pay_date'?: string;
    /**
     * The date that the stock must be held to receive the dividend, set by the company.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'record_date'?: string;
    /**
     * The ticker symbol of the dividend.
     * @type {string}
     * @memberof ListDividends200ResponseResultsInner
     */
    'ticker': string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListDividends200ResponseResultsInnerDividendTypeEnum {
    Cd = 'CD',
    Sc = 'SC',
    Lt = 'LT',
    St = 'ST'
}

/**
 * 
 * @export
 * @interface ListExchanges200Response
 */
export interface ListExchanges200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListExchanges200Response
     */
    'count'?: number;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListExchanges200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListExchanges200ResponseResultsInner>}
     * @memberof ListExchanges200Response
     */
    'results'?: Array<ListExchanges200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListExchanges200Response
     */
    'status': string;
}
/**
 * An entity that reports trades.
 * @export
 * @interface ListExchanges200ResponseResultsInner
 */
export interface ListExchanges200ResponseResultsInner {
    /**
     * A commonly used abbreviation for this exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'acronym'?: string;
    /**
     * An identifier for a group of similar financial instruments.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'asset_class': ListExchanges200ResponseResultsInnerAssetClassEnum;
    /**
     * A unique identifier used by Massive for this exchange.
     * @type {number}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'id': number;
    /**
     * An identifier for a geographical location.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'locale': ListExchanges200ResponseResultsInnerLocaleEnum;
    /**
     * The Market Identifier Code of this exchange (see ISO 10383).
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'mic'?: string;
    /**
     * Name of this exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'name': string;
    /**
     * The MIC of the entity that operates this exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'operating_mic'?: string;
    /**
     * The ID used by SIP\'s to represent this exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'participant_id'?: string;
    /**
     * Represents the type of exchange.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'type': ListExchanges200ResponseResultsInnerTypeEnum;
    /**
     * A link to this exchange\'s website, if one exists.
     * @type {string}
     * @memberof ListExchanges200ResponseResultsInner
     */
    'url'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListExchanges200ResponseResultsInnerAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx',
    Futures = 'futures'
}
/**
    * @export
    * @enum {string}
    */
export enum ListExchanges200ResponseResultsInnerLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
    * @export
    * @enum {string}
    */
export enum ListExchanges200ResponseResultsInnerTypeEnum {
    Exchange = 'exchange',
    Trf = 'TRF',
    Sip = 'SIP'
}

/**
 * 
 * @export
 * @interface ListExchanges400Response
 */
export interface ListExchanges400Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListExchanges400Response
     */
    'count'?: number;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListExchanges400Response
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListExchanges400Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ListFinancials200Response
 */
export interface ListFinancials200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListFinancials200Response
     */
    'count': number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListFinancials200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListFinancials200Response
     */
    'request_id': string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListFinancials200ResponseResultsInner>}
     * @memberof ListFinancials200Response
     */
    'results': Array<ListFinancials200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListFinancials200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ListFinancials200ResponseResultsInner
 */
export interface ListFinancials200ResponseResultsInner {
    /**
     * The datetime (EST timezone) the filing was accepted by EDGAR in YYYYMMDDHHMMSS format.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'acceptance_datetime'?: string;
    /**
     * The CIK number for the company.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'cik': string;
    /**
     * The company name.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'company_name': string;
    /**
     * The end date of the period that these financials cover in YYYYMMDD format.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'end_date'?: string;
    /**
     * The date that the SEC filing which these financials were derived from was made available. Note that this is not necessarily the date when this information became public, as some companies may publish a press release before filing with the SEC.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'filing_date'?: string;
    /**
     * 
     * @type {ListFinancials200ResponseResultsInnerFinancials}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'financials': ListFinancials200ResponseResultsInnerFinancials;
    /**
     * Fiscal period of the report according to the company (Q1, Q2, Q3, Q4, or FY).
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'fiscal_period': string;
    /**
     * Fiscal year of the report according to the company.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'fiscal_year'?: string;
    /**
     * The Standard Industrial Classification (SIC) code for the company.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'sic'?: string;
    /**
     * The URL of the specific XBRL instance document within the SEC filing that these financials were derived from.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'source_filing_file_url'?: string;
    /**
     * The URL of the SEC filing that these financials were derived from.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'source_filing_url'?: string;
    /**
     * The start date of the period that these financials cover in YYYYMMDD format.
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'start_date'?: string;
    /**
     * The list of ticker symbols for the company.
     * @type {Array<string>}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'tickers'?: Array<string>;
    /**
     * The timeframe of the report (quarterly, annual or ttm).
     * @type {string}
     * @memberof ListFinancials200ResponseResultsInner
     */
    'timeframe': string;
}
/**
 * Structured financial statements with detailed data points and metadata.
 * @export
 * @interface ListFinancials200ResponseResultsInnerFinancials
 */
export interface ListFinancials200ResponseResultsInnerFinancials {
    /**
     * 
     * @type {ListFinancials200ResponseResultsInnerFinancialsBalanceSheet}
     * @memberof ListFinancials200ResponseResultsInnerFinancials
     */
    'balance_sheet'?: ListFinancials200ResponseResultsInnerFinancialsBalanceSheet;
    /**
     * Cash flow statement. The keys in this object can be any of the fields listed in the Cash Flow Statement section of the <a target=\"_blank\" href=\"https://massive.com/blog/financials-api-glossary-of-fields\">financials API glossary of terms</a>. See the attributes of the objects within `balance_sheet` for more details.
     * @type {object}
     * @memberof ListFinancials200ResponseResultsInnerFinancials
     */
    'cash_flow_statement'?: object;
    /**
     * Comprehensive income. The keys in this object can be any of the fields listed in the Comprehensive Income section of the <a target=\"_blank\" href=\"https://massive.com/blog/financials-api-glossary-of-fields\">financials API glossary of terms</a>. See the attributes of the objects within `balance_sheet` for more details.
     * @type {object}
     * @memberof ListFinancials200ResponseResultsInnerFinancials
     */
    'comprehensive_income'?: object;
    /**
     * Income statement. The keys in this object can be any of the fields listed in the Income Statement section of the <a target=\"_blank\" href=\"https://massive.com/blog/financials-api-glossary-of-fields\">financials API glossary of terms</a>. See the attributes of the objects within `balance_sheet` for more details.
     * @type {object}
     * @memberof ListFinancials200ResponseResultsInnerFinancials
     */
    'income_statement'?: object;
}
/**
 * Balance sheet. The keys in this object can be any of the fields listed in the Balance Sheet section of the <a target=\"_blank\" href=\"https://massive.com/blog/financials-api-glossary-of-fields\">financials API glossary of terms</a>.
 * @export
 * @interface ListFinancials200ResponseResultsInnerFinancialsBalanceSheet
 */
export interface ListFinancials200ResponseResultsInnerFinancialsBalanceSheet {
    /**
     * 
     * @type {ListFinancials200ResponseResultsInnerFinancialsBalanceSheet}
     * @memberof ListFinancials200ResponseResultsInnerFinancialsBalanceSheet
     */
    '*'?: ListFinancials200ResponseResultsInnerFinancialsBalanceSheet;
}
/**
 * 
 * @export
 * @interface ListIPOs200Response
 */
export interface ListIPOs200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListIPOs200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListIPOs200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListIPOs200ResponseResultsInner>}
     * @memberof ListIPOs200Response
     */
    'results'?: Array<ListIPOs200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListIPOs200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListIPOs200ResponseResultsInner
 */
export interface ListIPOs200ResponseResultsInner {
    /**
     * The date when the IPO event was announced.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'announced_date'?: string;
    /**
     * Underlying currency of the security.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'currency_code'?: string;
    /**
     * The price set by the company and its underwriters before the IPO goes live.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'final_issue_price'?: number;
    /**
     * The highest price within the IPO price range that the company might use to price the shares.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'highest_offer_price'?: number;
    /**
     * The status of the IPO event. IPO events start out as status \"rumor\" or \"pending\". On listing day, the status changes to \"new\". After the listing day, the status changes to \"history\".  The status \"direct_listing_process\" corresponds to a type of offering where, instead of going through all the IPO processes, the company decides to list its shares directly on an exchange, without using an investment bank or other intermediaries. This is called a direct listing, direct placement, or direct public offering (DPO).
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'ipo_status': ListIPOs200ResponseResultsInnerIpoStatusEnum;
    /**
     * International Securities Identification Number. This is a unique twelve-digit code that is assigned to every security issuance in the world.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'isin'?: string;
    /**
     * Name of issuer.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'issuer_name': string;
    /**
     * The date when the IPO event was last modified.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'last_updated': string;
    /**
     * First trading date for the newly listed entity.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'listing_date'?: string;
    /**
     * The minimum number of shares that can be bought or sold in a single transaction.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'lot_size'?: number;
    /**
     * The lowest price within the IPO price range that the company is willing to offer its shares to investors.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'lowest_offer_price'?: number;
    /**
     * The upper limit of the shares that the company is offering to investors.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'max_shares_offered'?: number;
    /**
     * The lower limit of shares that the company is willing to sell in the IPO.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'min_shares_offered'?: number;
    /**
     * Market Identifier Code (MIC) of the primary exchange where the security is listed. The Market Identifier Code (MIC) (ISO 10383) is a unique identification code used to identify securities trading exchanges, regulated and non-regulated trading markets.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'primary_exchange'?: string;
    /**
     * Description of the security.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'security_description'?: string;
    /**
     * The classification of the stock. For example, \"CS\" stands for Common Stock.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'security_type': string;
    /**
     * The total number of shares that the company has issued and are held by investors.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'shares_outstanding'?: number;
    /**
     * The ticker symbol of the IPO event.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The total amount raised by the company for IPO.
     * @type {number}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'total_offer_size'?: number;
    /**
     * This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
     * @type {string}
     * @memberof ListIPOs200ResponseResultsInner
     */
    'us_code'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListIPOs200ResponseResultsInnerIpoStatusEnum {
    DirectListingProcess = 'direct_listing_process',
    History = 'history',
    New = 'new',
    Pending = 'pending',
    Postponed = 'postponed',
    Rumor = 'rumor',
    Withdrawn = 'withdrawn'
}

/**
 * 
 * @export
 * @interface ListNews200Response
 */
export interface ListNews200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListNews200Response
     */
    'count'?: number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListNews200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListNews200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListNews200ResponseResultsInner>}
     * @memberof ListNews200Response
     */
    'results'?: Array<ListNews200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListNews200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListNews200ResponseResultsInner
 */
export interface ListNews200ResponseResultsInner {
    /**
     * The mobile friendly Accelerated Mobile Page (AMP) URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'amp_url'?: string;
    /**
     * A link to the news article.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'article_url': string;
    /**
     * The article\'s author.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'author': string;
    /**
     * A description of the article.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'description'?: string;
    /**
     * Unique identifier for the article.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'id': string;
    /**
     * The article\'s image URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'image_url'?: string;
    /**
     * The insights related to the article.
     * @type {Array<ListNews200ResponseResultsInnerInsightsInner>}
     * @memberof ListNews200ResponseResultsInner
     */
    'insights'?: Array<ListNews200ResponseResultsInnerInsightsInner>;
    /**
     * The keywords associated with the article (which will vary depending on the publishing source).
     * @type {Array<string>}
     * @memberof ListNews200ResponseResultsInner
     */
    'keywords'?: Array<string>;
    /**
     * The UTC date and time when the article was published, formatted in RFC3339 standard (e.g. YYYY-MM-DDTHH:MM:SSZ).
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'published_utc': string;
    /**
     * 
     * @type {ListNews200ResponseResultsInnerPublisher}
     * @memberof ListNews200ResponseResultsInner
     */
    'publisher': ListNews200ResponseResultsInnerPublisher;
    /**
     * The ticker symbols associated with the article.
     * @type {Array<string>}
     * @memberof ListNews200ResponseResultsInner
     */
    'tickers': Array<string>;
    /**
     * The title of the news article.
     * @type {string}
     * @memberof ListNews200ResponseResultsInner
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ListNews200ResponseResultsInnerInsightsInner
 */
export interface ListNews200ResponseResultsInnerInsightsInner {
    /**
     * The sentiment of the insight.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerInsightsInner
     */
    'sentiment': ListNews200ResponseResultsInnerInsightsInnerSentimentEnum;
    /**
     * The reasoning behind the sentiment.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerInsightsInner
     */
    'sentiment_reasoning': string;
    /**
     * The ticker symbol associated with the insight.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerInsightsInner
     */
    'ticker': string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListNews200ResponseResultsInnerInsightsInnerSentimentEnum {
    Positive = 'positive',
    Neutral = 'neutral',
    Negative = 'negative'
}

/**
 * Details the source of the news article, including the publisher\'s name, logo, and homepage URLs. This information helps users identify and access the original source of news content.
 * @export
 * @interface ListNews200ResponseResultsInnerPublisher
 */
export interface ListNews200ResponseResultsInnerPublisher {
    /**
     * The publisher\'s homepage favicon URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerPublisher
     */
    'favicon_url'?: string;
    /**
     * The publisher\'s homepage URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerPublisher
     */
    'homepage_url': string;
    /**
     * The publisher\'s logo URL.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerPublisher
     */
    'logo_url': string;
    /**
     * The publisher\'s name.
     * @type {string}
     * @memberof ListNews200ResponseResultsInnerPublisher
     */
    'name': string;
}
/**
 * @type ListNewsPublishedUtcParameter
 * @export
 */
export type ListNewsPublishedUtcParameter = string;

/**
 * 
 * @export
 * @interface ListOptionsContracts200Response
 */
export interface ListOptionsContracts200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListOptionsContracts200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListOptionsContracts200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListOptionsContracts200ResponseResultsInner>}
     * @memberof ListOptionsContracts200Response
     */
    'results'?: Array<ListOptionsContracts200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListOptionsContracts200Response
     */
    'status'?: string;
}
/**
 * Contains the requested data for the specified options contract.
 * @export
 * @interface ListOptionsContracts200ResponseResultsInner
 */
export interface ListOptionsContracts200ResponseResultsInner {
    /**
     * If an option contract has additional underlyings or deliverables associated with it, they will appear here. See <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"https://www.optionseducation.org/referencelibrary/faq/splits-mergers-spinoffs-bankruptcies\">here</a> for some examples of what might cause a contract to have additional underlyings.
     * @type {Array<ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner>}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'additional_underlyings'?: Array<ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner>;
    /**
     * The 6 letter CFI code of the contract (defined in <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/ISO_10962\">ISO 10962</a>)
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'cfi'?: string;
    /**
     * The type of contract. Can be \"put\", \"call\", or in some rare cases, \"other\".
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'contract_type'?: string;
    /**
     * The correction number for this option contract.
     * @type {number}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'correction'?: number;
    /**
     * The exercise style of this contract. See <a rel=\"nofollow\" target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Option_style\">this link</a> for more details on exercise styles.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'exercise_style'?: ListOptionsContracts200ResponseResultsInnerExerciseStyleEnum;
    /**
     * The contract\'s expiration date in YYYY-MM-DD format.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'expiration_date'?: string;
    /**
     * The MIC code of the primary exchange that this contract is listed on.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'primary_exchange'?: string;
    /**
     * The number of shares per contract for this contract.
     * @type {number}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'shares_per_contract'?: number;
    /**
     * The strike price of the option contract.
     * @type {number}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'strike_price'?: number;
    /**
     * The ticker for the option contract.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'ticker'?: string;
    /**
     * The underlying ticker that the option contract relates to.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInner
     */
    'underlying_ticker'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListOptionsContracts200ResponseResultsInnerExerciseStyleEnum {
    American = 'american',
    European = 'european',
    Bermudan = 'bermudan'
}

/**
 * 
 * @export
 * @interface ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner
 */
export interface ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner {
    /**
     * The number of shares per contract of the additional underlying, or the cash-in-lieu amount of the currency.
     * @type {number}
     * @memberof ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner
     */
    'amount'?: number;
    /**
     * The type of the additional underlying asset, either equity or currency.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner
     */
    'type'?: string;
    /**
     * The name of the additional underlying asset.
     * @type {string}
     * @memberof ListOptionsContracts200ResponseResultsInnerAdditionalUnderlyingsInner
     */
    'underlying'?: string;
}
/**
 * 
 * @export
 * @interface ListStockSplits200Response
 */
export interface ListStockSplits200Response {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListStockSplits200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListStockSplits200Response
     */
    'request_id'?: string;
    /**
     * An array of results containing the requested data.
     * @type {Array<ListStockSplits200ResponseResultsInner>}
     * @memberof ListStockSplits200Response
     */
    'results'?: Array<ListStockSplits200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListStockSplits200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListStockSplits200ResponseResultsInner
 */
export interface ListStockSplits200ResponseResultsInner {
    /**
     * The execution date of the stock split. On this date the stock split was applied.
     * @type {string}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'execution_date': string;
    /**
     * The unique identifier for this stock split.
     * @type {string}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'id': string;
    /**
     * The second number in the split ratio.  For example: In a 2-for-1 split, split_from would be 1.
     * @type {number}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'split_from': number;
    /**
     * The first number in the split ratio.  For example: In a 2-for-1 split, split_to would be 2.
     * @type {number}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'split_to': number;
    /**
     * The ticker symbol of the stock split.
     * @type {string}
     * @memberof ListStockSplits200ResponseResultsInner
     */
    'ticker': string;
}
/**
 * 
 * @export
 * @interface ListTickerTypes200Response
 */
export interface ListTickerTypes200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListTickerTypes200Response
     */
    'count'?: number;
    /**
     * A request ID assigned by the server.
     * @type {string}
     * @memberof ListTickerTypes200Response
     */
    'request_id': string;
    /**
     * 
     * @type {Array<ListTickerTypes200ResponseResultsInner>}
     * @memberof ListTickerTypes200Response
     */
    'results'?: Array<ListTickerTypes200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListTickerTypes200Response
     */
    'status': string;
}
/**
 * Describes the type of financial instrument represented by a ticker.
 * @export
 * @interface ListTickerTypes200ResponseResultsInner
 */
export interface ListTickerTypes200ResponseResultsInner {
    /**
     * An identifier for a group of similar financial instruments.
     * @type {string}
     * @memberof ListTickerTypes200ResponseResultsInner
     */
    'asset_class': ListTickerTypes200ResponseResultsInnerAssetClassEnum;
    /**
     * A code used by Massive.com to refer to this ticker type.
     * @type {string}
     * @memberof ListTickerTypes200ResponseResultsInner
     */
    'code': string;
    /**
     * A short description of this ticker type.
     * @type {string}
     * @memberof ListTickerTypes200ResponseResultsInner
     */
    'description': string;
    /**
     * An identifier for a geographical location.
     * @type {string}
     * @memberof ListTickerTypes200ResponseResultsInner
     */
    'locale': ListTickerTypes200ResponseResultsInnerLocaleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ListTickerTypes200ResponseResultsInnerAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx',
    Indices = 'indices'
}
/**
    * @export
    * @enum {string}
    */
export enum ListTickerTypes200ResponseResultsInnerLocaleEnum {
    Us = 'us',
    Global = 'global'
}

/**
 * 
 * @export
 * @interface ListTickers200Response
 */
export interface ListTickers200Response {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof ListTickers200Response
     */
    'count'?: number;
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof ListTickers200Response
     */
    'next_url'?: string;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof ListTickers200Response
     */
    'request_id'?: string;
    /**
     * An array of tickers that match your query.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
     * @type {Array<ListTickers200ResponseResultsInner>}
     * @memberof ListTickers200Response
     */
    'results'?: Array<ListTickers200ResponseResultsInner>;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof ListTickers200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListTickers200ResponseResultsInner
 */
export interface ListTickers200ResponseResultsInner {
    /**
     * Whether or not the asset is actively traded. False means the asset has been delisted.
     * @type {boolean}
     * @memberof ListTickers200ResponseResultsInner
     */
    'active'?: boolean;
    /**
     * The name of the currency that this asset is priced against.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'base_currency_name'?: string;
    /**
     * The ISO 4217 code of the currency that this asset is priced against.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'base_currency_symbol'?: string;
    /**
     * The CIK number for this ticker. Find more information [here](https://en.wikipedia.org/wiki/Central_Index_Key).
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'cik'?: string;
    /**
     * The composite OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'composite_figi'?: string;
    /**
     * The name of the currency that this asset is traded with.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'currency_name'?: string;
    /**
     * The ISO 4217 code of the currency that this asset is traded with.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'currency_symbol'?: string;
    /**
     * The last date that the asset was traded.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'delisted_utc'?: string;
    /**
     * The information is accurate up to this time.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'last_updated_utc'?: string;
    /**
     * The locale of the asset.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'locale': ListTickers200ResponseResultsInnerLocaleEnum;
    /**
     * The market type of the asset.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'market': ListTickers200ResponseResultsInnerMarketEnum;
    /**
     * The name of the asset. For stocks/equities this will be the companies registered name. For crypto/fx this will be the name of the currency or coin pair.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'name': string;
    /**
     * The ISO code of the primary listing exchange for this asset.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'primary_exchange'?: string;
    /**
     * The share Class OpenFIGI number for this ticker. Find more information [here](https://www.openfigi.com/about/figi)
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'share_class_figi'?: string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'ticker': string;
    /**
     * The type of the asset. Find the types that we support via our [Ticker Types API](https://massive.com/docs/rest/stocks/tickers/ticker-types).
     * @type {string}
     * @memberof ListTickers200ResponseResultsInner
     */
    'type'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListTickers200ResponseResultsInnerLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
    * @export
    * @enum {string}
    */
export enum ListTickers200ResponseResultsInnerMarketEnum {
    Stocks = 'stocks',
    Crypto = 'crypto',
    Fx = 'fx',
    Otc = 'otc',
    Indices = 'indices'
}

/**
 * 
 * @export
 * @interface Locales
 */
export interface Locales {
    /**
     * 
     * @type {Array<LocalesResultsInner>}
     * @memberof Locales
     */
    'results'?: Array<LocalesResultsInner>;
}
/**
 * 
 * @export
 * @interface LocalesResultsInner
 */
export interface LocalesResultsInner {
    /**
     * An abbreviated country name.
     * @type {string}
     * @memberof LocalesResultsInner
     */
    'locale'?: string;
    /**
     * The name of the country.
     * @type {string}
     * @memberof LocalesResultsInner
     */
    'name'?: string;
}
/**
 * A dynamic key from the results set
 * @export
 * @interface MapKey
 */
export interface MapKey {
    /**
     * The descriptive name of this results key
     * @type {string}
     * @memberof MapKey
     */
    'name'?: string;
    /**
     * The data type of this results key
     * @type {string}
     * @memberof MapKey
     */
    'type'?: MapKeyTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum MapKeyTypeEnum {
    String = 'string',
    Int = 'int',
    Int64 = 'int64',
    Float64 = 'float64'
}

/**
 * 
 * @export
 * @interface MarketHolidayInner
 */
export interface MarketHolidayInner {
    /**
     * The market close time on the holiday (if it\'s not closed).
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'close'?: string;
    /**
     * The date of the holiday.
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'date': string;
    /**
     * Which market the record is for.
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'exchange': string;
    /**
     * The name of the holiday.
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'name': string;
    /**
     * The market open time on the holiday (if it\'s not closed).
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'open'?: string;
    /**
     * The status of the market on the holiday.
     * @type {string}
     * @memberof MarketHolidayInner
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface MarketStatus
 */
export interface MarketStatus {
    /**
     * Whether or not the market is in post-market hours.
     * @type {boolean}
     * @memberof MarketStatus
     */
    'afterHours'?: boolean;
    /**
     * 
     * @type {MarketStatusCurrencies}
     * @memberof MarketStatus
     */
    'currencies'?: MarketStatusCurrencies;
    /**
     * Whether or not the market is in pre-market hours.
     * @type {boolean}
     * @memberof MarketStatus
     */
    'earlyHours'?: boolean;
    /**
     * 
     * @type {MarketStatusExchanges}
     * @memberof MarketStatus
     */
    'exchanges'?: MarketStatusExchanges;
    /**
     * The status of the market as a whole.
     * @type {string}
     * @memberof MarketStatus
     */
    'market'?: string;
    /**
     * The current time of the server.
     * @type {string}
     * @memberof MarketStatus
     */
    'serverTime'?: string;
}
/**
 * 
 * @export
 * @interface MarketStatusCurrencies
 */
export interface MarketStatusCurrencies {
    /**
     * The status of the crypto market.
     * @type {string}
     * @memberof MarketStatusCurrencies
     */
    'crypto'?: string;
    /**
     * The status of the forex market.
     * @type {string}
     * @memberof MarketStatusCurrencies
     */
    'fx'?: string;
}
/**
 * 
 * @export
 * @interface MarketStatusExchanges
 */
export interface MarketStatusExchanges {
    /**
     * The status of the Nasdaq market.
     * @type {string}
     * @memberof MarketStatusExchanges
     */
    'nasdaq'?: string;
    /**
     * The status of the NYSE market.
     * @type {string}
     * @memberof MarketStatusExchanges
     */
    'nyse'?: string;
    /**
     * The status of the OTC market.
     * @type {string}
     * @memberof MarketStatusExchanges
     */
    'otc'?: string;
}
/**
 * 
 * @export
 * @interface Markets
 */
export interface Markets {
    /**
     * A list of supported markets.
     * @type {Array<MarketsResultsInner>}
     * @memberof Markets
     */
    'results'?: Array<MarketsResultsInner>;
}
/**
 * 
 * @export
 * @interface MarketsResultsInner
 */
export interface MarketsResultsInner {
    /**
     * A description of the market.
     * @type {string}
     * @memberof MarketsResultsInner
     */
    'desc'?: string;
    /**
     * The name of the market.
     * @type {string}
     * @memberof MarketsResultsInner
     */
    'market'?: string;
}
/**
 * @type ModelDate
 * @export
 */
export type ModelDate = string;

/**
 * A mapping of the keys returned in the results to their descriptive name and data types.
 * @export
 * @interface ModelMap
 */
export interface ModelMap {
    /**
     * 
     * @type {MapKey}
     * @memberof ModelMap
     */
    'key'?: MapKey;
}
/**
 * 
 * @export
 * @interface NewsInner
 */
export interface NewsInner {
    /**
     * A URL of the image for the news article, if found.
     * @type {string}
     * @memberof NewsInner
     */
    'image'?: string;
    /**
     * A list of common keywords related to the news article.
     * @type {Array<string>}
     * @memberof NewsInner
     */
    'keywords'?: Array<string>;
    /**
     * The publication source of the article.
     * @type {string}
     * @memberof NewsInner
     */
    'source'?: string;
    /**
     * A summary of the news article.
     * @type {string}
     * @memberof NewsInner
     */
    'summary'?: string;
    /**
     * A list of ticker symbols relating to the article.
     * @type {Array<string>}
     * @memberof NewsInner
     */
    'symbols'?: Array<string>;
    /**
     * The timestamp of the news article.
     * @type {string}
     * @memberof NewsInner
     */
    'timestamp'?: string;
    /**
     * The title of the news article.
     * @type {string}
     * @memberof NewsInner
     */
    'title'?: string;
    /**
     * A direct link to the news article from its source publication.
     * @type {string}
     * @memberof NewsInner
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface PaginationHooksBase
 */
export interface PaginationHooksBase {
    /**
     * If present, this value can be used to fetch the next page of data.
     * @type {string}
     * @memberof PaginationHooksBase
     */
    'next_url'?: string;
}
/**
 * 
 * @export
 * @interface RatingSection
 */
export interface RatingSection {
    /**
     * Analyst Rating at current month
     * @type {number}
     * @memberof RatingSection
     */
    'current': number;
    /**
     * Analyst Ratings at 1 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month1': number;
    /**
     * Analyst Ratings at 2 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month2': number;
    /**
     * Analyst Ratings at 3 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month3': number;
    /**
     * Analyst Ratings at 4 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month4'?: number;
    /**
     * Analyst Ratings at 5 month in the future
     * @type {number}
     * @memberof RatingSection
     */
    'month5'?: number;
}
/**
 * 
 * @export
 * @interface RequestIdBase
 */
export interface RequestIdBase {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof RequestIdBase
     */
    'request_id': string;
}
/**
 * 
 * @export
 * @interface SnapshotMinOHLCV
 */
export interface SnapshotMinOHLCV {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'c'?: number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'h'?: number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'l'?: number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'n'?: number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'o'?: number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    't'?: number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotMinOHLCV
     */
    'v'?: number;
}
/**
 * 
 * @export
 * @interface SnapshotOHLCV
 */
export interface SnapshotOHLCV {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCV
     */
    'v': number;
}
/**
 * 
 * @export
 * @interface SnapshotOHLCVVW
 */
export interface SnapshotOHLCVVW {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'o': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof SnapshotOHLCVVW
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface SnapshotOHLCVVWOtc
 */
export interface SnapshotOHLCVVWOtc {
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'l': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof SnapshotOHLCVVWOtc
     */
    'otc'?: boolean;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof SnapshotOHLCVVWOtc
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface StandardBase
 */
export interface StandardBase {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof StandardBase
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof StandardBase
     */
    'count'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof StandardBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface StatusBase
 */
export interface StatusBase {
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof StatusBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface StatusCountBase
 */
export interface StatusCountBase {
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof StatusCountBase
     */
    'count'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof StatusCountBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface StocksGroupedResults
 */
export interface StocksGroupedResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetGroupedStocksAggregates200ResponseAllOfResultsInner>}
     * @memberof StocksGroupedResults
     */
    'results'?: Array<GetGroupedStocksAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface StocksOpenClose
 */
export interface StocksOpenClose {
    /**
     * The close price of the ticker symbol in after hours trading.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'afterHours'?: number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'close': number;
    /**
     * The requested date.
     * @type {string}
     * @memberof StocksOpenClose
     */
    'from': string;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'high': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'low': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'open': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof StocksOpenClose
     */
    'otc'?: boolean;
    /**
     * The open price of the ticker symbol in pre-market trading.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'preMarket'?: number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof StocksOpenClose
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof StocksOpenClose
     */
    'symbol': string;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof StocksOpenClose
     */
    'volume': number;
}
/**
 * 
 * @export
 * @interface StocksSnapshotLastQuote
 */
export interface StocksSnapshotLastQuote {
    /**
     * The ask price.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    'P': number;
    /**
     * The ask size in lots.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    'S': number;
    /**
     * The bid price.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    'p': number;
    /**
     * The bid size in lots.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    's': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof StocksSnapshotLastQuote
     */
    't': number;
}
/**
 * 
 * @export
 * @interface StocksSnapshotMinute
 */
export interface StocksSnapshotMinute {
    /**
     * The accumulated volume.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'av': number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'o': number;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof StocksSnapshotMinute
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface StocksSnapshotMinuteOTC
 */
export interface StocksSnapshotMinuteOTC {
    /**
     * The accumulated volume.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'av': number;
    /**
     * The close price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'c': number;
    /**
     * The highest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'h': number;
    /**
     * The lowest price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'l': number;
    /**
     * The number of transactions in the aggregate window.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'n': number;
    /**
     * The open price for the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'o': number;
    /**
     * Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
     * @type {boolean}
     * @memberof StocksSnapshotMinuteOTC
     */
    'otc'?: boolean;
    /**
     * The Unix millisecond timestamp for the start of the aggregate window.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    't': number;
    /**
     * The trading volume of the symbol in the given time period.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'v': number;
    /**
     * The volume weighted average price.
     * @type {number}
     * @memberof StocksSnapshotMinuteOTC
     */
    'vw': number;
}
/**
 * 
 * @export
 * @interface StocksSnapshotTicker
 */
export interface StocksSnapshotTicker {
    /**
     * 
     * @type {GetStocksSnapshotTicker200ResponseAllOfTicker}
     * @memberof StocksSnapshotTicker
     */
    'ticker'?: GetStocksSnapshotTicker200ResponseAllOfTicker;
}
/**
 * 
 * @export
 * @interface StocksSnapshotTickers
 */
export interface StocksSnapshotTickers {
    /**
     * An array of snapshot data for the specified tickers.
     * @type {Array<GetStocksSnapshotTickers200ResponseAllOfTickersInner>}
     * @memberof StocksSnapshotTickers
     */
    'tickers'?: Array<GetStocksSnapshotTickers200ResponseAllOfTickersInner>;
}
/**
 * 
 * @export
 * @interface StocksTickerResultsOTC
 */
export interface StocksTickerResultsOTC {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetStocksAggregates200ResponseAllOfResultsInner>}
     * @memberof StocksTickerResultsOTC
     */
    'results'?: Array<GetStocksAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface StocksV2Base
 */
export interface StocksV2Base {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof StocksV2Base
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof StocksV2Base
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof StocksV2Base
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof StocksV2Base
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof StocksV2Base
     */
    'y': number;
}
/**
 * 
 * @export
 * @interface StocksV2NBBO
 */
export interface StocksV2NBBO {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof StocksV2NBBO
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'y': number;
    /**
     * The ask price.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'P': number;
    /**
     * The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'S': number;
    /**
     * The ask exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'X': number;
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof StocksV2NBBO
     */
    'c': Array<number>;
    /**
     * The indicators. For more information, see our glossary of [Conditions and Indicators](https://massive.com/glossary/conditions-indicators). 
     * @type {Array<number>}
     * @memberof StocksV2NBBO
     */
    'i': Array<number>;
    /**
     * The bid price.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'p': number;
    /**
     * The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    's': number;
    /**
     * The bid exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'x': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ 
     * @type {number}
     * @memberof StocksV2NBBO
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface StocksV2NBBOs
 */
export interface StocksV2NBBOs {
    /**
     * 
     * @type {Array<DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner>}
     * @memberof StocksV2NBBOs
     */
    'results'?: Array<DeprecatedGetHistoricStocksQuotes200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface StocksV2Trade
 */
export interface StocksV2Trade {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof StocksV2Trade
     */
    'T': string;
    /**
     * The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
     * @type {number}
     * @memberof StocksV2Trade
     */
    'f': number;
    /**
     * The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'q': number;
    /**
     * The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
     * @type {number}
     * @memberof StocksV2Trade
     */
    't': number;
    /**
     * The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
     * @type {number}
     * @memberof StocksV2Trade
     */
    'y': number;
    /**
     * A list of condition codes. 
     * @type {Array<number>}
     * @memberof StocksV2Trade
     */
    'c': Array<number>;
    /**
     * The trade correction indicator. 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'e': number;
    /**
     * The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
     * @type {string}
     * @memberof StocksV2Trade
     */
    'i': string;
    /**
     * The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00. 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'p': number;
    /**
     * The ID for the Trade Reporting Facility where the trade took place. 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'r': number;
    /**
     * The size of a trade (also known as volume). 
     * @type {number}
     * @memberof StocksV2Trade
     */
    's': number;
    /**
     * The exchange ID. See <a href=\"https://massive.com/docs/rest/stocks/market-operations/exchanges\" alt=\"Exchanges\">Exchanges</a> for Massive.com\'s mapping of exchange IDs.
     * @type {number}
     * @memberof StocksV2Trade
     */
    'x': number;
    /**
     * There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ 
     * @type {number}
     * @memberof StocksV2Trade
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface StocksV2Trades
 */
export interface StocksV2Trades {
    /**
     * 
     * @type {Array<DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner>}
     * @memberof StocksV2Trades
     */
    'results'?: Array<DeprecatedGetHistoricStocksTrades200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface TickerBase
 */
export interface TickerBase {
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof TickerBase
     */
    'ticker': string;
}
/**
 * 
 * @export
 * @interface TickerResults
 */
export interface TickerResults {
    /**
     * An array of results containing the requested data.
     * @type {Array<GetCryptoAggregates200ResponseAllOfResultsInner>}
     * @memberof TickerResults
     */
    'results'?: Array<GetCryptoAggregates200ResponseAllOfResultsInner>;
}
/**
 * 
 * @export
 * @interface TradeDetailsMapItem
 */
export interface TradeDetailsMapItem {
    /**
     * Name of the trade detail item
     * @type {string}
     * @memberof TradeDetailsMapItem
     */
    'name'?: string;
    /**
     * Actual type of the trade detail item
     * @type {string}
     * @memberof TradeDetailsMapItem
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface V1LastBase
 */
export interface V1LastBase {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V1LastBase
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V1LastBase
     */
    'status': string;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V1LastBase
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface V2AggsBase
 */
export interface V2AggsBase {
    /**
     * Whether or not this response was adjusted for splits.
     * @type {boolean}
     * @memberof V2AggsBase
     */
    'adjusted': boolean;
    /**
     * The number of aggregates (minute or day) used to generate the response.
     * @type {number}
     * @memberof V2AggsBase
     */
    'queryCount': number;
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2AggsBase
     */
    'request_id': string;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2AggsBase
     */
    'resultsCount': number;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2AggsBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface V2LastBase
 */
export interface V2LastBase {
    /**
     * A request id assigned by the server.
     * @type {string}
     * @memberof V2LastBase
     */
    'request_id': string;
    /**
     * The status of this request\'s response.
     * @type {string}
     * @memberof V2LastBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface V2TicksBase
 */
export interface V2TicksBase {
    /**
     * Latency in milliseconds for the query results from the database.
     * @type {number}
     * @memberof V2TicksBase
     */
    'db_latency'?: number;
    /**
     * The total number of results for this request.
     * @type {number}
     * @memberof V2TicksBase
     */
    'results_count'?: number;
    /**
     * Whether or not this query was executed successfully.
     * @type {boolean}
     * @memberof V2TicksBase
     */
    'success'?: boolean;
    /**
     * The exchange symbol that this item is traded under.
     * @type {string}
     * @memberof V2TicksBase
     */
    'ticker'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker Full Book (L2)
         * @param {string} ticker The cryptocurrency ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetCryptoSnapshotTickerBook: async (ticker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('deprecatedGetCryptoSnapshotTickerBook', 'ticker', ticker)
            const localVarPath = `/v2/snapshot/locale/global/markets/crypto/tickers/{ticker}/book`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historic trade ticks for a cryptocurrency pair. 
         * @summary Historic Crypto Trades
         * @param {string} from The \&quot;from\&quot; symbol of the crypto pair.
         * @param {string} to The \&quot;to\&quot; symbol of the crypto pair.
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricCryptoTrades: async (from: string, to: string, date: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('deprecatedGetHistoricCryptoTrades', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('deprecatedGetHistoricCryptoTrades', 'to', to)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('deprecatedGetHistoricCryptoTrades', 'date', date)
            const localVarPath = `/v1/historic/crypto/{from}/{to}/{date}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historic ticks for a forex currency pair. 
         * @summary Historic Forex Ticks
         * @param {string} from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
         * @param {string} to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricForexQuotes: async (from: string, to: string, date: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('deprecatedGetHistoricForexQuotes', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('deprecatedGetHistoricForexQuotes', 'to', to)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('deprecatedGetHistoricForexQuotes', 'date', date)
            const localVarPath = `/v1/historic/forex/{from}/{to}/{date}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get NBBO quotes for a given ticker symbol on a specified date. 
         * @summary Quotes (NBBO)
         * @param {string} ticker The ticker symbol we want quotes for.
         * @param {string} date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricStocksQuotes: async (ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('deprecatedGetHistoricStocksQuotes', 'ticker', ticker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('deprecatedGetHistoricStocksQuotes', 'date', date)
            const localVarPath = `/v2/ticks/stocks/nbbo/{ticker}/{date}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampLimit !== undefined) {
                localVarQueryParameter['timestampLimit'] = timestampLimit;
            }

            if (reverse !== undefined) {
                localVarQueryParameter['reverse'] = reverse;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a given ticker symbol on a specified date. 
         * @summary Trades
         * @param {string} ticker The ticker symbol we want trades for.
         * @param {string} date The date/day of the trades to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricStocksTrades: async (ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('deprecatedGetHistoricStocksTrades', 'ticker', ticker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('deprecatedGetHistoricStocksTrades', 'date', date)
            const localVarPath = `/v2/ticks/stocks/trades/{ticker}/{date}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampLimit !== undefined) {
                localVarQueryParameter['timestampLimit'] = timestampLimit;
            }

            if (reverse !== undefined) {
                localVarQueryParameter['reverse'] = reverse;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A comprehensive database of financial analyst insights and ratings for various publicly traded companies, capturing detailed information about analyst recommendations and price targets.
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company being rated.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedGt] Filter greater than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedLt] Filter less than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [firm] The name of the research firm or investment bank issuing the rating.
         * @param {string} [firmAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [firmGt] Filter greater than the value.
         * @param {string} [firmGte] Filter greater than or equal to the value.
         * @param {string} [firmLt] Filter less than the value.
         * @param {string} [firmLte] Filter less than or equal to the value.
         * @param {string} [ratingAction] The description of the change in rating from the firm\&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
         * @param {string} [ratingActionAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [ratingActionGt] Filter greater than the value.
         * @param {string} [ratingActionGte] Filter greater than or equal to the value.
         * @param {string} [ratingActionLt] Filter less than the value.
         * @param {string} [ratingActionLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] The identifer used by Benzinga for the firm record.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaRatingId] The identifier used by Benzinga for the rating record.
         * @param {string} [benzingaRatingIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaRatingIdGt] Filter greater than the value.
         * @param {string} [benzingaRatingIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaRatingIdLt] Filter less than the value.
         * @param {string} [benzingaRatingIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;last_updated\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1AnalystInsights: async (date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, lastUpdated?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, firm?: string, firmAnyOf?: string, firmGt?: string, firmGte?: string, firmLt?: string, firmLte?: string, ratingAction?: string, ratingActionAnyOf?: string, ratingActionGt?: string, ratingActionGte?: string, ratingActionLt?: string, ratingActionLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, benzingaRatingId?: string, benzingaRatingIdAnyOf?: string, benzingaRatingIdGt?: string, benzingaRatingIdGte?: string, benzingaRatingIdLt?: string, benzingaRatingIdLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v1/analyst-insights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGt !== undefined) {
                localVarQueryParameter['last_updated.gt'] = lastUpdatedGt;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated.gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLt !== undefined) {
                localVarQueryParameter['last_updated.lt'] = lastUpdatedLt;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated.lte'] = lastUpdatedLte;
            }

            if (firm !== undefined) {
                localVarQueryParameter['firm'] = firm;
            }

            if (firmAnyOf !== undefined) {
                localVarQueryParameter['firm.any_of'] = firmAnyOf;
            }

            if (firmGt !== undefined) {
                localVarQueryParameter['firm.gt'] = firmGt;
            }

            if (firmGte !== undefined) {
                localVarQueryParameter['firm.gte'] = firmGte;
            }

            if (firmLt !== undefined) {
                localVarQueryParameter['firm.lt'] = firmLt;
            }

            if (firmLte !== undefined) {
                localVarQueryParameter['firm.lte'] = firmLte;
            }

            if (ratingAction !== undefined) {
                localVarQueryParameter['rating_action'] = ratingAction;
            }

            if (ratingActionAnyOf !== undefined) {
                localVarQueryParameter['rating_action.any_of'] = ratingActionAnyOf;
            }

            if (ratingActionGt !== undefined) {
                localVarQueryParameter['rating_action.gt'] = ratingActionGt;
            }

            if (ratingActionGte !== undefined) {
                localVarQueryParameter['rating_action.gte'] = ratingActionGte;
            }

            if (ratingActionLt !== undefined) {
                localVarQueryParameter['rating_action.lt'] = ratingActionLt;
            }

            if (ratingActionLte !== undefined) {
                localVarQueryParameter['rating_action.lte'] = ratingActionLte;
            }

            if (benzingaFirmId !== undefined) {
                localVarQueryParameter['benzinga_firm_id'] = benzingaFirmId;
            }

            if (benzingaFirmIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_firm_id.any_of'] = benzingaFirmIdAnyOf;
            }

            if (benzingaFirmIdGt !== undefined) {
                localVarQueryParameter['benzinga_firm_id.gt'] = benzingaFirmIdGt;
            }

            if (benzingaFirmIdGte !== undefined) {
                localVarQueryParameter['benzinga_firm_id.gte'] = benzingaFirmIdGte;
            }

            if (benzingaFirmIdLt !== undefined) {
                localVarQueryParameter['benzinga_firm_id.lt'] = benzingaFirmIdLt;
            }

            if (benzingaFirmIdLte !== undefined) {
                localVarQueryParameter['benzinga_firm_id.lte'] = benzingaFirmIdLte;
            }

            if (benzingaRatingId !== undefined) {
                localVarQueryParameter['benzinga_rating_id'] = benzingaRatingId;
            }

            if (benzingaRatingIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_rating_id.any_of'] = benzingaRatingIdAnyOf;
            }

            if (benzingaRatingIdGt !== undefined) {
                localVarQueryParameter['benzinga_rating_id.gt'] = benzingaRatingIdGt;
            }

            if (benzingaRatingIdGte !== undefined) {
                localVarQueryParameter['benzinga_rating_id.gte'] = benzingaRatingIdGte;
            }

            if (benzingaRatingIdLt !== undefined) {
                localVarQueryParameter['benzinga_rating_id.lt'] = benzingaRatingIdLt;
            }

            if (benzingaRatingIdLte !== undefined) {
                localVarQueryParameter['benzinga_rating_id.lte'] = benzingaRatingIdLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A comprehensive database of financial analysts, containing detailed performance metrics and identification information for individual analysts across various financial firms.
         * @param {string} [benzingaId] The identifier used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] The unique identifier assigned by Benzinga to the research firm or investment bank.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {string} [firmName] The name of the research firm or investment bank issuing the ratings.
         * @param {string} [firmNameAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [firmNameGt] Filter greater than the value.
         * @param {string} [firmNameGte] Filter greater than or equal to the value.
         * @param {string} [firmNameLt] Filter less than the value.
         * @param {string} [firmNameLte] Filter less than or equal to the value.
         * @param {string} [fullName] The full name of the analyst associated with the ratings.
         * @param {string} [fullNameAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fullNameGt] Filter greater than the value.
         * @param {string} [fullNameGte] Filter greater than or equal to the value.
         * @param {string} [fullNameLt] Filter less than the value.
         * @param {string} [fullNameLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;full_name\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Analysts: async (benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, firmName?: string, firmNameAnyOf?: string, firmNameGt?: string, firmNameGte?: string, firmNameLt?: string, firmNameLte?: string, fullName?: string, fullNameAnyOf?: string, fullNameGt?: string, fullNameGte?: string, fullNameLt?: string, fullNameLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v1/analysts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (benzingaId !== undefined) {
                localVarQueryParameter['benzinga_id'] = benzingaId;
            }

            if (benzingaIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_id.any_of'] = benzingaIdAnyOf;
            }

            if (benzingaIdGt !== undefined) {
                localVarQueryParameter['benzinga_id.gt'] = benzingaIdGt;
            }

            if (benzingaIdGte !== undefined) {
                localVarQueryParameter['benzinga_id.gte'] = benzingaIdGte;
            }

            if (benzingaIdLt !== undefined) {
                localVarQueryParameter['benzinga_id.lt'] = benzingaIdLt;
            }

            if (benzingaIdLte !== undefined) {
                localVarQueryParameter['benzinga_id.lte'] = benzingaIdLte;
            }

            if (benzingaFirmId !== undefined) {
                localVarQueryParameter['benzinga_firm_id'] = benzingaFirmId;
            }

            if (benzingaFirmIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_firm_id.any_of'] = benzingaFirmIdAnyOf;
            }

            if (benzingaFirmIdGt !== undefined) {
                localVarQueryParameter['benzinga_firm_id.gt'] = benzingaFirmIdGt;
            }

            if (benzingaFirmIdGte !== undefined) {
                localVarQueryParameter['benzinga_firm_id.gte'] = benzingaFirmIdGte;
            }

            if (benzingaFirmIdLt !== undefined) {
                localVarQueryParameter['benzinga_firm_id.lt'] = benzingaFirmIdLt;
            }

            if (benzingaFirmIdLte !== undefined) {
                localVarQueryParameter['benzinga_firm_id.lte'] = benzingaFirmIdLte;
            }

            if (firmName !== undefined) {
                localVarQueryParameter['firm_name'] = firmName;
            }

            if (firmNameAnyOf !== undefined) {
                localVarQueryParameter['firm_name.any_of'] = firmNameAnyOf;
            }

            if (firmNameGt !== undefined) {
                localVarQueryParameter['firm_name.gt'] = firmNameGt;
            }

            if (firmNameGte !== undefined) {
                localVarQueryParameter['firm_name.gte'] = firmNameGte;
            }

            if (firmNameLt !== undefined) {
                localVarQueryParameter['firm_name.lt'] = firmNameLt;
            }

            if (firmNameLte !== undefined) {
                localVarQueryParameter['firm_name.lte'] = firmNameLte;
            }

            if (fullName !== undefined) {
                localVarQueryParameter['full_name'] = fullName;
            }

            if (fullNameAnyOf !== undefined) {
                localVarQueryParameter['full_name.any_of'] = fullNameAnyOf;
            }

            if (fullNameGt !== undefined) {
                localVarQueryParameter['full_name.gt'] = fullNameGt;
            }

            if (fullNameGte !== undefined) {
                localVarQueryParameter['full_name.gte'] = fullNameGte;
            }

            if (fullNameLt !== undefined) {
                localVarQueryParameter['full_name.lt'] = fullNameLt;
            }

            if (fullNameLte !== undefined) {
                localVarQueryParameter['full_name.lte'] = fullNameLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A comprehensive financial consensus ratings table that aggregates analyst recommendations and price targets for individual stock tickers, capturing detailed rating breakdowns and statistical insights.
         * @param {string} ticker The requested ticker.
         * @param {string} [date] The date range to aggregate analyst ratings over. For example, date.gte&#x3D;2024-10-01 and date.lt&#x3D;2025-01-01 for ratings published in Q4 2024. By default, all ratings are aggregated regardless of date.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1ConsensusRatings: async (ticker: string, date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getBenzingaV1ConsensusRatings', 'ticker', ticker)
            const localVarPath = `/benzinga/v1/consensus-ratings/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This table contains earnings data from Benzinga, tracking both actual and estimated financial metrics for publicly traded companies. It includes EPS and revenue figures with surprise calculations, along with metadata like fiscal periods, company identifiers, and reporting timestamps.
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company reporting earnings.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedGt] Filter greater than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedLt] Filter less than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateStatus] Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed.
         * @param {string} [dateStatusAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateStatusGt] Filter greater than the value.
         * @param {string} [dateStatusGte] Filter greater than or equal to the value.
         * @param {string} [dateStatusLt] Filter less than the value.
         * @param {string} [dateStatusLte] Filter less than or equal to the value.
         * @param {number} [epsSurprisePercent] The percentage difference between the actual and estimated EPS. Value must be a floating point number.
         * @param {string} [epsSurprisePercentAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [epsSurprisePercentGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercent] The percentage difference between the actual and estimated revenue. Value must be a floating point number.
         * @param {string} [revenueSurprisePercentAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalYear] The fiscal year in which the earnings period falls. Value must be an integer.
         * @param {string} [fiscalYearAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be an integer.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be an integer.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [fiscalPeriod] The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY.
         * @param {string} [fiscalPeriodAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fiscalPeriodGt] Filter greater than the value.
         * @param {string} [fiscalPeriodGte] Filter greater than or equal to the value.
         * @param {string} [fiscalPeriodLt] Filter less than the value.
         * @param {string} [fiscalPeriodLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;last_updated\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Earnings: async (date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, dateStatus?: string, dateStatusAnyOf?: string, dateStatusGt?: string, dateStatusGte?: string, dateStatusLt?: string, dateStatusLte?: string, epsSurprisePercent?: number, epsSurprisePercentAnyOf?: string, epsSurprisePercentGt?: number, epsSurprisePercentGte?: number, epsSurprisePercentLt?: number, epsSurprisePercentLte?: number, revenueSurprisePercent?: number, revenueSurprisePercentAnyOf?: string, revenueSurprisePercentGt?: number, revenueSurprisePercentGte?: number, revenueSurprisePercentLt?: number, revenueSurprisePercentLte?: number, fiscalYear?: number, fiscalYearAnyOf?: string, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalPeriod?: string, fiscalPeriodAnyOf?: string, fiscalPeriodGt?: string, fiscalPeriodGte?: string, fiscalPeriodLt?: string, fiscalPeriodLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v1/earnings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (importance !== undefined) {
                localVarQueryParameter['importance'] = importance;
            }

            if (importanceAnyOf !== undefined) {
                localVarQueryParameter['importance.any_of'] = importanceAnyOf;
            }

            if (importanceGt !== undefined) {
                localVarQueryParameter['importance.gt'] = importanceGt;
            }

            if (importanceGte !== undefined) {
                localVarQueryParameter['importance.gte'] = importanceGte;
            }

            if (importanceLt !== undefined) {
                localVarQueryParameter['importance.lt'] = importanceLt;
            }

            if (importanceLte !== undefined) {
                localVarQueryParameter['importance.lte'] = importanceLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedAnyOf !== undefined) {
                localVarQueryParameter['last_updated.any_of'] = lastUpdatedAnyOf;
            }

            if (lastUpdatedGt !== undefined) {
                localVarQueryParameter['last_updated.gt'] = lastUpdatedGt;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated.gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLt !== undefined) {
                localVarQueryParameter['last_updated.lt'] = lastUpdatedLt;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated.lte'] = lastUpdatedLte;
            }

            if (dateStatus !== undefined) {
                localVarQueryParameter['date_status'] = dateStatus;
            }

            if (dateStatusAnyOf !== undefined) {
                localVarQueryParameter['date_status.any_of'] = dateStatusAnyOf;
            }

            if (dateStatusGt !== undefined) {
                localVarQueryParameter['date_status.gt'] = dateStatusGt;
            }

            if (dateStatusGte !== undefined) {
                localVarQueryParameter['date_status.gte'] = dateStatusGte;
            }

            if (dateStatusLt !== undefined) {
                localVarQueryParameter['date_status.lt'] = dateStatusLt;
            }

            if (dateStatusLte !== undefined) {
                localVarQueryParameter['date_status.lte'] = dateStatusLte;
            }

            if (epsSurprisePercent !== undefined) {
                localVarQueryParameter['eps_surprise_percent'] = epsSurprisePercent;
            }

            if (epsSurprisePercentAnyOf !== undefined) {
                localVarQueryParameter['eps_surprise_percent.any_of'] = epsSurprisePercentAnyOf;
            }

            if (epsSurprisePercentGt !== undefined) {
                localVarQueryParameter['eps_surprise_percent.gt'] = epsSurprisePercentGt;
            }

            if (epsSurprisePercentGte !== undefined) {
                localVarQueryParameter['eps_surprise_percent.gte'] = epsSurprisePercentGte;
            }

            if (epsSurprisePercentLt !== undefined) {
                localVarQueryParameter['eps_surprise_percent.lt'] = epsSurprisePercentLt;
            }

            if (epsSurprisePercentLte !== undefined) {
                localVarQueryParameter['eps_surprise_percent.lte'] = epsSurprisePercentLte;
            }

            if (revenueSurprisePercent !== undefined) {
                localVarQueryParameter['revenue_surprise_percent'] = revenueSurprisePercent;
            }

            if (revenueSurprisePercentAnyOf !== undefined) {
                localVarQueryParameter['revenue_surprise_percent.any_of'] = revenueSurprisePercentAnyOf;
            }

            if (revenueSurprisePercentGt !== undefined) {
                localVarQueryParameter['revenue_surprise_percent.gt'] = revenueSurprisePercentGt;
            }

            if (revenueSurprisePercentGte !== undefined) {
                localVarQueryParameter['revenue_surprise_percent.gte'] = revenueSurprisePercentGte;
            }

            if (revenueSurprisePercentLt !== undefined) {
                localVarQueryParameter['revenue_surprise_percent.lt'] = revenueSurprisePercentLt;
            }

            if (revenueSurprisePercentLte !== undefined) {
                localVarQueryParameter['revenue_surprise_percent.lte'] = revenueSurprisePercentLte;
            }

            if (fiscalYear !== undefined) {
                localVarQueryParameter['fiscal_year'] = fiscalYear;
            }

            if (fiscalYearAnyOf !== undefined) {
                localVarQueryParameter['fiscal_year.any_of'] = fiscalYearAnyOf;
            }

            if (fiscalYearGt !== undefined) {
                localVarQueryParameter['fiscal_year.gt'] = fiscalYearGt;
            }

            if (fiscalYearGte !== undefined) {
                localVarQueryParameter['fiscal_year.gte'] = fiscalYearGte;
            }

            if (fiscalYearLt !== undefined) {
                localVarQueryParameter['fiscal_year.lt'] = fiscalYearLt;
            }

            if (fiscalYearLte !== undefined) {
                localVarQueryParameter['fiscal_year.lte'] = fiscalYearLte;
            }

            if (fiscalPeriod !== undefined) {
                localVarQueryParameter['fiscal_period'] = fiscalPeriod;
            }

            if (fiscalPeriodAnyOf !== undefined) {
                localVarQueryParameter['fiscal_period.any_of'] = fiscalPeriodAnyOf;
            }

            if (fiscalPeriodGt !== undefined) {
                localVarQueryParameter['fiscal_period.gt'] = fiscalPeriodGt;
            }

            if (fiscalPeriodGte !== undefined) {
                localVarQueryParameter['fiscal_period.gte'] = fiscalPeriodGte;
            }

            if (fiscalPeriodLt !== undefined) {
                localVarQueryParameter['fiscal_period.lt'] = fiscalPeriodLt;
            }

            if (fiscalPeriodLte !== undefined) {
                localVarQueryParameter['fiscal_period.lte'] = fiscalPeriodLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A comprehensive database of financial firms, tracking unique identifiers, names, and basic metadata for various financial institutions and research firms.
         * @param {string} [benzingaId] The identifer used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;name\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Firms: async (benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v1/firms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (benzingaId !== undefined) {
                localVarQueryParameter['benzinga_id'] = benzingaId;
            }

            if (benzingaIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_id.any_of'] = benzingaIdAnyOf;
            }

            if (benzingaIdGt !== undefined) {
                localVarQueryParameter['benzinga_id.gt'] = benzingaIdGt;
            }

            if (benzingaIdGte !== undefined) {
                localVarQueryParameter['benzinga_id.gte'] = benzingaIdGte;
            }

            if (benzingaIdLt !== undefined) {
                localVarQueryParameter['benzinga_id.lt'] = benzingaIdLt;
            }

            if (benzingaIdLte !== undefined) {
                localVarQueryParameter['benzinga_id.lte'] = benzingaIdLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A comprehensive database of financial guidance and earnings estimates for various companies, capturing key metrics related to earnings per share (EPS) and revenue projections across different fiscal periods.
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the guidance was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company issuing guidance.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [positioning] Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are \&#39;primary\&#39; (the emphasized figure) and \&#39;secondary\&#39; (a supporting or alternate figure)
         * @param {string} [positioningAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [positioningGt] Filter greater than the value.
         * @param {string} [positioningGte] Filter greater than or equal to the value.
         * @param {string} [positioningLt] Filter less than the value.
         * @param {string} [positioningLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {number} [fiscalYear] The fiscal year corresponding to the period for which the guidance is issued. Value must be an integer.
         * @param {string} [fiscalYearAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be an integer.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be an integer.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [fiscalPeriod] The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4.
         * @param {string} [fiscalPeriodAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fiscalPeriodGt] Filter greater than the value.
         * @param {string} [fiscalPeriodGte] Filter greater than or equal to the value.
         * @param {string} [fiscalPeriodLt] Filter less than the value.
         * @param {string} [fiscalPeriodLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Guidance: async (date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, positioning?: string, positioningAnyOf?: string, positioningGt?: string, positioningGte?: string, positioningLt?: string, positioningLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, fiscalYear?: number, fiscalYearAnyOf?: string, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalPeriod?: string, fiscalPeriodAnyOf?: string, fiscalPeriodGt?: string, fiscalPeriodGte?: string, fiscalPeriodLt?: string, fiscalPeriodLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v1/guidance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (positioning !== undefined) {
                localVarQueryParameter['positioning'] = positioning;
            }

            if (positioningAnyOf !== undefined) {
                localVarQueryParameter['positioning.any_of'] = positioningAnyOf;
            }

            if (positioningGt !== undefined) {
                localVarQueryParameter['positioning.gt'] = positioningGt;
            }

            if (positioningGte !== undefined) {
                localVarQueryParameter['positioning.gte'] = positioningGte;
            }

            if (positioningLt !== undefined) {
                localVarQueryParameter['positioning.lt'] = positioningLt;
            }

            if (positioningLte !== undefined) {
                localVarQueryParameter['positioning.lte'] = positioningLte;
            }

            if (importance !== undefined) {
                localVarQueryParameter['importance'] = importance;
            }

            if (importanceAnyOf !== undefined) {
                localVarQueryParameter['importance.any_of'] = importanceAnyOf;
            }

            if (importanceGt !== undefined) {
                localVarQueryParameter['importance.gt'] = importanceGt;
            }

            if (importanceGte !== undefined) {
                localVarQueryParameter['importance.gte'] = importanceGte;
            }

            if (importanceLt !== undefined) {
                localVarQueryParameter['importance.lt'] = importanceLt;
            }

            if (importanceLte !== undefined) {
                localVarQueryParameter['importance.lte'] = importanceLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedAnyOf !== undefined) {
                localVarQueryParameter['last_updated.any_of'] = lastUpdatedAnyOf;
            }

            if (lastUpdatedGt !== undefined) {
                localVarQueryParameter['last_updated.gt'] = lastUpdatedGt;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated.gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLt !== undefined) {
                localVarQueryParameter['last_updated.lt'] = lastUpdatedLt;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated.lte'] = lastUpdatedLte;
            }

            if (fiscalYear !== undefined) {
                localVarQueryParameter['fiscal_year'] = fiscalYear;
            }

            if (fiscalYearAnyOf !== undefined) {
                localVarQueryParameter['fiscal_year.any_of'] = fiscalYearAnyOf;
            }

            if (fiscalYearGt !== undefined) {
                localVarQueryParameter['fiscal_year.gt'] = fiscalYearGt;
            }

            if (fiscalYearGte !== undefined) {
                localVarQueryParameter['fiscal_year.gte'] = fiscalYearGte;
            }

            if (fiscalYearLt !== undefined) {
                localVarQueryParameter['fiscal_year.lt'] = fiscalYearLt;
            }

            if (fiscalYearLte !== undefined) {
                localVarQueryParameter['fiscal_year.lte'] = fiscalYearLte;
            }

            if (fiscalPeriod !== undefined) {
                localVarQueryParameter['fiscal_period'] = fiscalPeriod;
            }

            if (fiscalPeriodAnyOf !== undefined) {
                localVarQueryParameter['fiscal_period.any_of'] = fiscalPeriodAnyOf;
            }

            if (fiscalPeriodGt !== undefined) {
                localVarQueryParameter['fiscal_period.gt'] = fiscalPeriodGt;
            }

            if (fiscalPeriodGte !== undefined) {
                localVarQueryParameter['fiscal_period.gte'] = fiscalPeriodGte;
            }

            if (fiscalPeriodLt !== undefined) {
                localVarQueryParameter['fiscal_period.lt'] = fiscalPeriodLt;
            }

            if (fiscalPeriodLte !== undefined) {
                localVarQueryParameter['fiscal_period.lte'] = fiscalPeriodLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A comprehensive news article database from Benzinga, containing detailed information about financial news articles including metadata, content, and associated financial information.
         * @param {string} [published] The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
         * @param {string} [publishedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [publishedGt] Filter greater than the value.
         * @param {string} [publishedGte] Filter greater than or equal to the value.
         * @param {string} [publishedLt] Filter less than the value.
         * @param {string} [publishedLte] Filter less than or equal to the value.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {string} [tickers] Filter for arrays that contain the value.
         * @param {string} [tickersAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickersAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [channels] Filter for arrays that contain the value.
         * @param {string} [channelsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [channelsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tags] Filter for arrays that contain the value.
         * @param {string} [tagsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tagsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [author] The name of the journalist or entity that authored the news article.
         * @param {string} [authorAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [authorGt] Filter greater than the value.
         * @param {string} [authorGte] Filter greater than or equal to the value.
         * @param {string} [authorLt] Filter less than the value.
         * @param {string} [authorLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;published\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1News: async (published?: string, publishedAnyOf?: string, publishedGt?: string, publishedGte?: string, publishedLt?: string, publishedLte?: string, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, tickers?: string, tickersAllOf?: string, tickersAnyOf?: string, channels?: string, channelsAllOf?: string, channelsAnyOf?: string, tags?: string, tagsAllOf?: string, tagsAnyOf?: string, author?: string, authorAnyOf?: string, authorGt?: string, authorGte?: string, authorLt?: string, authorLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v1/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (published !== undefined) {
                localVarQueryParameter['published'] = published;
            }

            if (publishedAnyOf !== undefined) {
                localVarQueryParameter['published.any_of'] = publishedAnyOf;
            }

            if (publishedGt !== undefined) {
                localVarQueryParameter['published.gt'] = publishedGt;
            }

            if (publishedGte !== undefined) {
                localVarQueryParameter['published.gte'] = publishedGte;
            }

            if (publishedLt !== undefined) {
                localVarQueryParameter['published.lt'] = publishedLt;
            }

            if (publishedLte !== undefined) {
                localVarQueryParameter['published.lte'] = publishedLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedAnyOf !== undefined) {
                localVarQueryParameter['last_updated.any_of'] = lastUpdatedAnyOf;
            }

            if (lastUpdatedGt !== undefined) {
                localVarQueryParameter['last_updated.gt'] = lastUpdatedGt;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated.gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLt !== undefined) {
                localVarQueryParameter['last_updated.lt'] = lastUpdatedLt;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated.lte'] = lastUpdatedLte;
            }

            if (tickers !== undefined) {
                localVarQueryParameter['tickers'] = tickers;
            }

            if (tickersAllOf !== undefined) {
                localVarQueryParameter['tickers.all_of'] = tickersAllOf;
            }

            if (tickersAnyOf !== undefined) {
                localVarQueryParameter['tickers.any_of'] = tickersAnyOf;
            }

            if (channels !== undefined) {
                localVarQueryParameter['channels'] = channels;
            }

            if (channelsAllOf !== undefined) {
                localVarQueryParameter['channels.all_of'] = channelsAllOf;
            }

            if (channelsAnyOf !== undefined) {
                localVarQueryParameter['channels.any_of'] = channelsAnyOf;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (tagsAllOf !== undefined) {
                localVarQueryParameter['tags.all_of'] = tagsAllOf;
            }

            if (tagsAnyOf !== undefined) {
                localVarQueryParameter['tags.any_of'] = tagsAnyOf;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (authorAnyOf !== undefined) {
                localVarQueryParameter['author.any_of'] = authorAnyOf;
            }

            if (authorGt !== undefined) {
                localVarQueryParameter['author.gt'] = authorGt;
            }

            if (authorGte !== undefined) {
                localVarQueryParameter['author.gte'] = authorGte;
            }

            if (authorLt !== undefined) {
                localVarQueryParameter['author.lt'] = authorLt;
            }

            if (authorLte !== undefined) {
                localVarQueryParameter['author.lte'] = authorLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This table contains analyst ratings and price target data from investment firms, tracking rating changes (upgrades, downgrades, initiates coverage, etc.) and price target adjustments for publicly traded companies. Each record includes the analyst details, company information, current and previous ratings/targets, and metadata like timestamps and Benzinga identifiers.
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company being rated.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedGt] Filter greater than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedLt] Filter less than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [ratingAction] The description of the change in rating from the firm\&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
         * @param {string} [ratingActionAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [ratingActionGt] Filter greater than the value.
         * @param {string} [ratingActionGte] Filter greater than or equal to the value.
         * @param {string} [ratingActionLt] Filter less than the value.
         * @param {string} [ratingActionLte] Filter less than or equal to the value.
         * @param {string} [priceTargetAction] The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
         * @param {string} [priceTargetActionAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [priceTargetActionGt] Filter greater than the value.
         * @param {string} [priceTargetActionGte] Filter greater than or equal to the value.
         * @param {string} [priceTargetActionLt] Filter less than the value.
         * @param {string} [priceTargetActionLte] Filter less than or equal to the value.
         * @param {string} [benzingaId] The identifer used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaAnalystId] The identifer used by Benzinga for this analyst.
         * @param {string} [benzingaAnalystIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaAnalystIdGt] Filter greater than the value.
         * @param {string} [benzingaAnalystIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaAnalystIdLt] Filter less than the value.
         * @param {string} [benzingaAnalystIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] The identifer used by Benzinga for this firm.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;last_updated\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Ratings: async (date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, importance?: number, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, ratingAction?: string, ratingActionAnyOf?: string, ratingActionGt?: string, ratingActionGte?: string, ratingActionLt?: string, ratingActionLte?: string, priceTargetAction?: string, priceTargetActionAnyOf?: string, priceTargetActionGt?: string, priceTargetActionGte?: string, priceTargetActionLt?: string, priceTargetActionLte?: string, benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, benzingaAnalystId?: string, benzingaAnalystIdAnyOf?: string, benzingaAnalystIdGt?: string, benzingaAnalystIdGte?: string, benzingaAnalystIdLt?: string, benzingaAnalystIdLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v1/ratings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (importance !== undefined) {
                localVarQueryParameter['importance'] = importance;
            }

            if (importanceGt !== undefined) {
                localVarQueryParameter['importance.gt'] = importanceGt;
            }

            if (importanceGte !== undefined) {
                localVarQueryParameter['importance.gte'] = importanceGte;
            }

            if (importanceLt !== undefined) {
                localVarQueryParameter['importance.lt'] = importanceLt;
            }

            if (importanceLte !== undefined) {
                localVarQueryParameter['importance.lte'] = importanceLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGt !== undefined) {
                localVarQueryParameter['last_updated.gt'] = lastUpdatedGt;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated.gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLt !== undefined) {
                localVarQueryParameter['last_updated.lt'] = lastUpdatedLt;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated.lte'] = lastUpdatedLte;
            }

            if (ratingAction !== undefined) {
                localVarQueryParameter['rating_action'] = ratingAction;
            }

            if (ratingActionAnyOf !== undefined) {
                localVarQueryParameter['rating_action.any_of'] = ratingActionAnyOf;
            }

            if (ratingActionGt !== undefined) {
                localVarQueryParameter['rating_action.gt'] = ratingActionGt;
            }

            if (ratingActionGte !== undefined) {
                localVarQueryParameter['rating_action.gte'] = ratingActionGte;
            }

            if (ratingActionLt !== undefined) {
                localVarQueryParameter['rating_action.lt'] = ratingActionLt;
            }

            if (ratingActionLte !== undefined) {
                localVarQueryParameter['rating_action.lte'] = ratingActionLte;
            }

            if (priceTargetAction !== undefined) {
                localVarQueryParameter['price_target_action'] = priceTargetAction;
            }

            if (priceTargetActionAnyOf !== undefined) {
                localVarQueryParameter['price_target_action.any_of'] = priceTargetActionAnyOf;
            }

            if (priceTargetActionGt !== undefined) {
                localVarQueryParameter['price_target_action.gt'] = priceTargetActionGt;
            }

            if (priceTargetActionGte !== undefined) {
                localVarQueryParameter['price_target_action.gte'] = priceTargetActionGte;
            }

            if (priceTargetActionLt !== undefined) {
                localVarQueryParameter['price_target_action.lt'] = priceTargetActionLt;
            }

            if (priceTargetActionLte !== undefined) {
                localVarQueryParameter['price_target_action.lte'] = priceTargetActionLte;
            }

            if (benzingaId !== undefined) {
                localVarQueryParameter['benzinga_id'] = benzingaId;
            }

            if (benzingaIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_id.any_of'] = benzingaIdAnyOf;
            }

            if (benzingaIdGt !== undefined) {
                localVarQueryParameter['benzinga_id.gt'] = benzingaIdGt;
            }

            if (benzingaIdGte !== undefined) {
                localVarQueryParameter['benzinga_id.gte'] = benzingaIdGte;
            }

            if (benzingaIdLt !== undefined) {
                localVarQueryParameter['benzinga_id.lt'] = benzingaIdLt;
            }

            if (benzingaIdLte !== undefined) {
                localVarQueryParameter['benzinga_id.lte'] = benzingaIdLte;
            }

            if (benzingaAnalystId !== undefined) {
                localVarQueryParameter['benzinga_analyst_id'] = benzingaAnalystId;
            }

            if (benzingaAnalystIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_analyst_id.any_of'] = benzingaAnalystIdAnyOf;
            }

            if (benzingaAnalystIdGt !== undefined) {
                localVarQueryParameter['benzinga_analyst_id.gt'] = benzingaAnalystIdGt;
            }

            if (benzingaAnalystIdGte !== undefined) {
                localVarQueryParameter['benzinga_analyst_id.gte'] = benzingaAnalystIdGte;
            }

            if (benzingaAnalystIdLt !== undefined) {
                localVarQueryParameter['benzinga_analyst_id.lt'] = benzingaAnalystIdLt;
            }

            if (benzingaAnalystIdLte !== undefined) {
                localVarQueryParameter['benzinga_analyst_id.lte'] = benzingaAnalystIdLte;
            }

            if (benzingaFirmId !== undefined) {
                localVarQueryParameter['benzinga_firm_id'] = benzingaFirmId;
            }

            if (benzingaFirmIdAnyOf !== undefined) {
                localVarQueryParameter['benzinga_firm_id.any_of'] = benzingaFirmIdAnyOf;
            }

            if (benzingaFirmIdGt !== undefined) {
                localVarQueryParameter['benzinga_firm_id.gt'] = benzingaFirmIdGt;
            }

            if (benzingaFirmIdGte !== undefined) {
                localVarQueryParameter['benzinga_firm_id.gte'] = benzingaFirmIdGte;
            }

            if (benzingaFirmIdLt !== undefined) {
                localVarQueryParameter['benzinga_firm_id.lt'] = benzingaFirmIdLt;
            }

            if (benzingaFirmIdLte !== undefined) {
                localVarQueryParameter['benzinga_firm_id.lte'] = benzingaFirmIdLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A comprehensive news article database from Benzinga, containing detailed information about financial news articles including metadata, content, and associated financial information.
         * @param {string} [published] The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [publishedGt] Filter greater than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [publishedGte] Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [publishedLt] Filter less than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [publishedLte] Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [channels] Filter for arrays that contain the value.
         * @param {string} [channelsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [channelsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tags] Filter for arrays that contain the value.
         * @param {string} [tagsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tagsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [author] The name of the journalist or entity that authored the news article.
         * @param {string} [authorAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [authorGt] Filter greater than the value.
         * @param {string} [authorGte] Filter greater than or equal to the value.
         * @param {string} [authorLt] Filter less than the value.
         * @param {string} [authorLte] Filter less than or equal to the value.
         * @param {string} [stocks] Filter for arrays that contain the value.
         * @param {string} [stocksAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [stocksAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickers] Filter for arrays that contain the value.
         * @param {string} [tickersAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickersAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;published\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV2News: async (published?: string, publishedGt?: string, publishedGte?: string, publishedLt?: string, publishedLte?: string, channels?: string, channelsAllOf?: string, channelsAnyOf?: string, tags?: string, tagsAllOf?: string, tagsAnyOf?: string, author?: string, authorAnyOf?: string, authorGt?: string, authorGte?: string, authorLt?: string, authorLte?: string, stocks?: string, stocksAllOf?: string, stocksAnyOf?: string, tickers?: string, tickersAllOf?: string, tickersAnyOf?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/benzinga/v2/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (published !== undefined) {
                localVarQueryParameter['published'] = published;
            }

            if (publishedGt !== undefined) {
                localVarQueryParameter['published.gt'] = publishedGt;
            }

            if (publishedGte !== undefined) {
                localVarQueryParameter['published.gte'] = publishedGte;
            }

            if (publishedLt !== undefined) {
                localVarQueryParameter['published.lt'] = publishedLt;
            }

            if (publishedLte !== undefined) {
                localVarQueryParameter['published.lte'] = publishedLte;
            }

            if (channels !== undefined) {
                localVarQueryParameter['channels'] = channels;
            }

            if (channelsAllOf !== undefined) {
                localVarQueryParameter['channels.all_of'] = channelsAllOf;
            }

            if (channelsAnyOf !== undefined) {
                localVarQueryParameter['channels.any_of'] = channelsAnyOf;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (tagsAllOf !== undefined) {
                localVarQueryParameter['tags.all_of'] = tagsAllOf;
            }

            if (tagsAnyOf !== undefined) {
                localVarQueryParameter['tags.any_of'] = tagsAnyOf;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (authorAnyOf !== undefined) {
                localVarQueryParameter['author.any_of'] = authorAnyOf;
            }

            if (authorGt !== undefined) {
                localVarQueryParameter['author.gt'] = authorGt;
            }

            if (authorGte !== undefined) {
                localVarQueryParameter['author.gte'] = authorGte;
            }

            if (authorLt !== undefined) {
                localVarQueryParameter['author.lt'] = authorLt;
            }

            if (authorLte !== undefined) {
                localVarQueryParameter['author.lte'] = authorLte;
            }

            if (stocks !== undefined) {
                localVarQueryParameter['stocks'] = stocks;
            }

            if (stocksAllOf !== undefined) {
                localVarQueryParameter['stocks.all_of'] = stocksAllOf;
            }

            if (stocksAnyOf !== undefined) {
                localVarQueryParameter['stocks.any_of'] = stocksAnyOf;
            }

            if (tickers !== undefined) {
                localVarQueryParameter['tickers'] = tickers;
            }

            if (tickersAllOf !== undefined) {
                localVarQueryParameter['tickers.all_of'] = tickersAllOf;
            }

            if (tickersAnyOf !== undefined) {
                localVarQueryParameter['tickers.any_of'] = tickersAnyOf;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetCryptoAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetCryptoAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoAggregates: async (cryptoTicker: string, multiplier: number, timespan: GetCryptoAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetCryptoAggregatesSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('getCryptoAggregates', 'cryptoTicker', cryptoTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('getCryptoAggregates', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('getCryptoAggregates', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getCryptoAggregates', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getCryptoAggregates', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{cryptoTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} cryptoTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoEMA: async (cryptoTicker: string, timestamp?: string, timespan?: GetCryptoEMATimespanEnum, window?: number, seriesType?: GetCryptoEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('getCryptoEMA', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v1/indicators/ema/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} cryptoTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetCryptoMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate MACD data. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoMACD: async (cryptoTicker: string, timestamp?: string, timespan?: GetCryptoMACDTimespanEnum, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetCryptoMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('getCryptoMACD', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v1/indicators/macd/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the open, close prices of a cryptocurrency symbol on a certain day. 
         * @summary Daily Open/Close
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoOpenClose: async (from: string, to: string, date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getCryptoOpenClose', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getCryptoOpenClose', 'to', to)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getCryptoOpenClose', 'date', date)
            const localVarPath = `/v1/open-close/crypto/{from}/{to}/{date}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} cryptoTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoRSI: async (cryptoTicker: string, timestamp?: string, timespan?: GetCryptoRSITimespanEnum, window?: number, seriesType?: GetCryptoRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('getCryptoRSI', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v1/indicators/rsi/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} cryptoTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSMA: async (cryptoTicker: string, timestamp?: string, timespan?: GetCryptoSMATimespanEnum, window?: number, seriesType?: GetCryptoSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('getCryptoSMA', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v1/indicators/sma/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current top 20 gainers or losers of the day in cryptocurrency markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetCryptoSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSnapshotDirection: async (direction: GetCryptoSnapshotDirectionDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('getCryptoSnapshotDirection', 'direction', direction)
            const localVarPath = `/v2/snapshot/locale/global/markets/crypto/{direction}`
                .replace(`{${"direction"}}`, encodeURIComponent(String(direction)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker Ticker of the snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSnapshotTicker: async (ticker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getCryptoSnapshotTicker', 'ticker', ticker)
            const localVarPath = `/v2/snapshot/locale/global/markets/crypto/tickers/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSnapshotTickers: async (tickers?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/snapshot/locale/global/markets/crypto/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickers) {
                localVarQueryParameter['tickers'] = tickers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a crypto ticker symbol in a given time range.
         * @summary Trades
         * @param {string} cryptoTicker The ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetCryptoTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetCryptoTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoTrades: async (cryptoTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetCryptoTradesOrderEnum, limit?: number, sort?: GetCryptoTradesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('getCryptoTrades', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v3/trades/{cryptoTicker}`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Global cryptocurrency exchanges and digital asset trading platforms, including major centralized exchanges (Coinbase, Binance, Bitfinex, etc.) that facilitate trading of cryptocurrencies and digital tokens worldwide.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoV1Exchanges: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/crypto/v1/exchanges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
         * @summary Real-time Currency Conversion
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {number} [amount] The amount to convert, with a decimal.
         * @param {GetCurrencyConversionPrecisionEnum} [precision] The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyConversion: async (from: string, to: string, amount?: number, precision?: GetCurrencyConversionPrecisionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getCurrencyConversion', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getCurrencyConversion', 'to', to)
            const localVarPath = `/v1/conversion/{from}/{to}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (precision !== undefined) {
                localVarQueryParameter['precision'] = precision;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ETF Global analytics data containing risk scores, reward metrics, and quantitative analysis for ETF composite tickers.
         * @param {string} [compositeTicker] The stock ticker symbol used to identify this ETF product on exchanges.
         * @param {string} [compositeTickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [compositeTickerGt] Filter greater than the value.
         * @param {string} [compositeTickerGte] Filter greater than or equal to the value.
         * @param {string} [compositeTickerLt] Filter less than the value.
         * @param {string} [compositeTickerLte] Filter less than or equal to the value.
         * @param {string} [processedDate] The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDate] The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {number} [riskTotalScore] ETF Global\&#39;s proprietary Red Diamond overall risk assessment score for the ETF. Value must be a floating point number.
         * @param {number} [riskTotalScoreGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [riskTotalScoreGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [riskTotalScoreLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [riskTotalScoreLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [rewardScore] ETF Global\&#39;s proprietary Green Diamond score measuring the potential reward and return prospects of the ETF. Value must be a floating point number.
         * @param {number} [rewardScoreGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [rewardScoreGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [rewardScoreLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [rewardScoreLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [quantTotalScore] ETF Global\&#39;s comprehensive quantitative analysis score combining all quantitative factors. Value must be a floating point number.
         * @param {number} [quantTotalScoreGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quantTotalScoreGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quantTotalScoreLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quantTotalScoreLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {string} [quantGrade] Letter grade summarizing the ETF\&#39;s overall quantitative assessment, where A &#x3D; 71-100, B &#x3D; 56-70, etc.
         * @param {string} [quantGradeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [quantGradeGt] Filter greater than the value.
         * @param {string} [quantGradeGte] Filter greater than or equal to the value.
         * @param {string} [quantGradeLt] Filter less than the value.
         * @param {string} [quantGradeLte] Filter less than or equal to the value.
         * @param {number} [quantCompositeTechnical] Combined technical analysis score aggregating short, intermediate, and long-term technical factors. Value must be a floating point number.
         * @param {number} [quantCompositeTechnicalGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quantCompositeTechnicalGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeTechnicalLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quantCompositeTechnicalLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeSentiment] Overall market sentiment score combining put/call ratios, short interest, and implied volatility. Value must be a floating point number.
         * @param {number} [quantCompositeSentimentGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quantCompositeSentimentGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeSentimentLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quantCompositeSentimentLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeBehavioral] Behavioral analysis score measuring investor psychology and market behavior patterns. Value must be a floating point number.
         * @param {number} [quantCompositeBehavioralGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quantCompositeBehavioralGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeBehavioralLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quantCompositeBehavioralLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeFundamental] Overall fundamental analysis score combining P/E, P/CF, P/B, and dividend yield metrics. Value must be a floating point number.
         * @param {number} [quantCompositeFundamentalGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quantCompositeFundamentalGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeFundamentalLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quantCompositeFundamentalLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeGlobal] Overall global theme score combining sector and country analysis for macro investment views. Value must be a floating point number.
         * @param {number} [quantCompositeGlobalGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quantCompositeGlobalGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeGlobalLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quantCompositeGlobalLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeQuality] Overall quality assessment score combining liquidity, diversification, and issuing firm factors. Value must be a floating point number.
         * @param {number} [quantCompositeQualityGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quantCompositeQualityGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeQualityLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quantCompositeQualityLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEtfGlobalV1Analytics: async (compositeTicker?: string, compositeTickerAnyOf?: string, compositeTickerGt?: string, compositeTickerGte?: string, compositeTickerLt?: string, compositeTickerLte?: string, processedDate?: string, processedDateGt?: string, processedDateGte?: string, processedDateLt?: string, processedDateLte?: string, effectiveDate?: string, effectiveDateGt?: string, effectiveDateGte?: string, effectiveDateLt?: string, effectiveDateLte?: string, riskTotalScore?: number, riskTotalScoreGt?: number, riskTotalScoreGte?: number, riskTotalScoreLt?: number, riskTotalScoreLte?: number, rewardScore?: number, rewardScoreGt?: number, rewardScoreGte?: number, rewardScoreLt?: number, rewardScoreLte?: number, quantTotalScore?: number, quantTotalScoreGt?: number, quantTotalScoreGte?: number, quantTotalScoreLt?: number, quantTotalScoreLte?: number, quantGrade?: string, quantGradeAnyOf?: string, quantGradeGt?: string, quantGradeGte?: string, quantGradeLt?: string, quantGradeLte?: string, quantCompositeTechnical?: number, quantCompositeTechnicalGt?: number, quantCompositeTechnicalGte?: number, quantCompositeTechnicalLt?: number, quantCompositeTechnicalLte?: number, quantCompositeSentiment?: number, quantCompositeSentimentGt?: number, quantCompositeSentimentGte?: number, quantCompositeSentimentLt?: number, quantCompositeSentimentLte?: number, quantCompositeBehavioral?: number, quantCompositeBehavioralGt?: number, quantCompositeBehavioralGte?: number, quantCompositeBehavioralLt?: number, quantCompositeBehavioralLte?: number, quantCompositeFundamental?: number, quantCompositeFundamentalGt?: number, quantCompositeFundamentalGte?: number, quantCompositeFundamentalLt?: number, quantCompositeFundamentalLte?: number, quantCompositeGlobal?: number, quantCompositeGlobalGt?: number, quantCompositeGlobalGte?: number, quantCompositeGlobalLt?: number, quantCompositeGlobalLte?: number, quantCompositeQuality?: number, quantCompositeQualityGt?: number, quantCompositeQualityGte?: number, quantCompositeQualityLt?: number, quantCompositeQualityLte?: number, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/etf-global/v1/analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (compositeTicker !== undefined) {
                localVarQueryParameter['composite_ticker'] = compositeTicker;
            }

            if (compositeTickerAnyOf !== undefined) {
                localVarQueryParameter['composite_ticker.any_of'] = compositeTickerAnyOf;
            }

            if (compositeTickerGt !== undefined) {
                localVarQueryParameter['composite_ticker.gt'] = compositeTickerGt;
            }

            if (compositeTickerGte !== undefined) {
                localVarQueryParameter['composite_ticker.gte'] = compositeTickerGte;
            }

            if (compositeTickerLt !== undefined) {
                localVarQueryParameter['composite_ticker.lt'] = compositeTickerLt;
            }

            if (compositeTickerLte !== undefined) {
                localVarQueryParameter['composite_ticker.lte'] = compositeTickerLte;
            }

            if (processedDate !== undefined) {
                localVarQueryParameter['processed_date'] = processedDate;
            }

            if (processedDateGt !== undefined) {
                localVarQueryParameter['processed_date.gt'] = processedDateGt;
            }

            if (processedDateGte !== undefined) {
                localVarQueryParameter['processed_date.gte'] = processedDateGte;
            }

            if (processedDateLt !== undefined) {
                localVarQueryParameter['processed_date.lt'] = processedDateLt;
            }

            if (processedDateLte !== undefined) {
                localVarQueryParameter['processed_date.lte'] = processedDateLte;
            }

            if (effectiveDate !== undefined) {
                localVarQueryParameter['effective_date'] = effectiveDate;
            }

            if (effectiveDateGt !== undefined) {
                localVarQueryParameter['effective_date.gt'] = effectiveDateGt;
            }

            if (effectiveDateGte !== undefined) {
                localVarQueryParameter['effective_date.gte'] = effectiveDateGte;
            }

            if (effectiveDateLt !== undefined) {
                localVarQueryParameter['effective_date.lt'] = effectiveDateLt;
            }

            if (effectiveDateLte !== undefined) {
                localVarQueryParameter['effective_date.lte'] = effectiveDateLte;
            }

            if (riskTotalScore !== undefined) {
                localVarQueryParameter['risk_total_score'] = riskTotalScore;
            }

            if (riskTotalScoreGt !== undefined) {
                localVarQueryParameter['risk_total_score.gt'] = riskTotalScoreGt;
            }

            if (riskTotalScoreGte !== undefined) {
                localVarQueryParameter['risk_total_score.gte'] = riskTotalScoreGte;
            }

            if (riskTotalScoreLt !== undefined) {
                localVarQueryParameter['risk_total_score.lt'] = riskTotalScoreLt;
            }

            if (riskTotalScoreLte !== undefined) {
                localVarQueryParameter['risk_total_score.lte'] = riskTotalScoreLte;
            }

            if (rewardScore !== undefined) {
                localVarQueryParameter['reward_score'] = rewardScore;
            }

            if (rewardScoreGt !== undefined) {
                localVarQueryParameter['reward_score.gt'] = rewardScoreGt;
            }

            if (rewardScoreGte !== undefined) {
                localVarQueryParameter['reward_score.gte'] = rewardScoreGte;
            }

            if (rewardScoreLt !== undefined) {
                localVarQueryParameter['reward_score.lt'] = rewardScoreLt;
            }

            if (rewardScoreLte !== undefined) {
                localVarQueryParameter['reward_score.lte'] = rewardScoreLte;
            }

            if (quantTotalScore !== undefined) {
                localVarQueryParameter['quant_total_score'] = quantTotalScore;
            }

            if (quantTotalScoreGt !== undefined) {
                localVarQueryParameter['quant_total_score.gt'] = quantTotalScoreGt;
            }

            if (quantTotalScoreGte !== undefined) {
                localVarQueryParameter['quant_total_score.gte'] = quantTotalScoreGte;
            }

            if (quantTotalScoreLt !== undefined) {
                localVarQueryParameter['quant_total_score.lt'] = quantTotalScoreLt;
            }

            if (quantTotalScoreLte !== undefined) {
                localVarQueryParameter['quant_total_score.lte'] = quantTotalScoreLte;
            }

            if (quantGrade !== undefined) {
                localVarQueryParameter['quant_grade'] = quantGrade;
            }

            if (quantGradeAnyOf !== undefined) {
                localVarQueryParameter['quant_grade.any_of'] = quantGradeAnyOf;
            }

            if (quantGradeGt !== undefined) {
                localVarQueryParameter['quant_grade.gt'] = quantGradeGt;
            }

            if (quantGradeGte !== undefined) {
                localVarQueryParameter['quant_grade.gte'] = quantGradeGte;
            }

            if (quantGradeLt !== undefined) {
                localVarQueryParameter['quant_grade.lt'] = quantGradeLt;
            }

            if (quantGradeLte !== undefined) {
                localVarQueryParameter['quant_grade.lte'] = quantGradeLte;
            }

            if (quantCompositeTechnical !== undefined) {
                localVarQueryParameter['quant_composite_technical'] = quantCompositeTechnical;
            }

            if (quantCompositeTechnicalGt !== undefined) {
                localVarQueryParameter['quant_composite_technical.gt'] = quantCompositeTechnicalGt;
            }

            if (quantCompositeTechnicalGte !== undefined) {
                localVarQueryParameter['quant_composite_technical.gte'] = quantCompositeTechnicalGte;
            }

            if (quantCompositeTechnicalLt !== undefined) {
                localVarQueryParameter['quant_composite_technical.lt'] = quantCompositeTechnicalLt;
            }

            if (quantCompositeTechnicalLte !== undefined) {
                localVarQueryParameter['quant_composite_technical.lte'] = quantCompositeTechnicalLte;
            }

            if (quantCompositeSentiment !== undefined) {
                localVarQueryParameter['quant_composite_sentiment'] = quantCompositeSentiment;
            }

            if (quantCompositeSentimentGt !== undefined) {
                localVarQueryParameter['quant_composite_sentiment.gt'] = quantCompositeSentimentGt;
            }

            if (quantCompositeSentimentGte !== undefined) {
                localVarQueryParameter['quant_composite_sentiment.gte'] = quantCompositeSentimentGte;
            }

            if (quantCompositeSentimentLt !== undefined) {
                localVarQueryParameter['quant_composite_sentiment.lt'] = quantCompositeSentimentLt;
            }

            if (quantCompositeSentimentLte !== undefined) {
                localVarQueryParameter['quant_composite_sentiment.lte'] = quantCompositeSentimentLte;
            }

            if (quantCompositeBehavioral !== undefined) {
                localVarQueryParameter['quant_composite_behavioral'] = quantCompositeBehavioral;
            }

            if (quantCompositeBehavioralGt !== undefined) {
                localVarQueryParameter['quant_composite_behavioral.gt'] = quantCompositeBehavioralGt;
            }

            if (quantCompositeBehavioralGte !== undefined) {
                localVarQueryParameter['quant_composite_behavioral.gte'] = quantCompositeBehavioralGte;
            }

            if (quantCompositeBehavioralLt !== undefined) {
                localVarQueryParameter['quant_composite_behavioral.lt'] = quantCompositeBehavioralLt;
            }

            if (quantCompositeBehavioralLte !== undefined) {
                localVarQueryParameter['quant_composite_behavioral.lte'] = quantCompositeBehavioralLte;
            }

            if (quantCompositeFundamental !== undefined) {
                localVarQueryParameter['quant_composite_fundamental'] = quantCompositeFundamental;
            }

            if (quantCompositeFundamentalGt !== undefined) {
                localVarQueryParameter['quant_composite_fundamental.gt'] = quantCompositeFundamentalGt;
            }

            if (quantCompositeFundamentalGte !== undefined) {
                localVarQueryParameter['quant_composite_fundamental.gte'] = quantCompositeFundamentalGte;
            }

            if (quantCompositeFundamentalLt !== undefined) {
                localVarQueryParameter['quant_composite_fundamental.lt'] = quantCompositeFundamentalLt;
            }

            if (quantCompositeFundamentalLte !== undefined) {
                localVarQueryParameter['quant_composite_fundamental.lte'] = quantCompositeFundamentalLte;
            }

            if (quantCompositeGlobal !== undefined) {
                localVarQueryParameter['quant_composite_global'] = quantCompositeGlobal;
            }

            if (quantCompositeGlobalGt !== undefined) {
                localVarQueryParameter['quant_composite_global.gt'] = quantCompositeGlobalGt;
            }

            if (quantCompositeGlobalGte !== undefined) {
                localVarQueryParameter['quant_composite_global.gte'] = quantCompositeGlobalGte;
            }

            if (quantCompositeGlobalLt !== undefined) {
                localVarQueryParameter['quant_composite_global.lt'] = quantCompositeGlobalLt;
            }

            if (quantCompositeGlobalLte !== undefined) {
                localVarQueryParameter['quant_composite_global.lte'] = quantCompositeGlobalLte;
            }

            if (quantCompositeQuality !== undefined) {
                localVarQueryParameter['quant_composite_quality'] = quantCompositeQuality;
            }

            if (quantCompositeQualityGt !== undefined) {
                localVarQueryParameter['quant_composite_quality.gt'] = quantCompositeQualityGt;
            }

            if (quantCompositeQualityGte !== undefined) {
                localVarQueryParameter['quant_composite_quality.gte'] = quantCompositeQualityGte;
            }

            if (quantCompositeQualityLt !== undefined) {
                localVarQueryParameter['quant_composite_quality.lt'] = quantCompositeQualityLt;
            }

            if (quantCompositeQualityLte !== undefined) {
                localVarQueryParameter['quant_composite_quality.lte'] = quantCompositeQualityLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ETF Global constituents data containing detailed information about the securities held within ETFs, including weights, market values, and security identifiers.
         * @param {string} [compositeTicker] The stock ticker symbol of the ETF that holds these constituent securities.
         * @param {string} [compositeTickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [compositeTickerGt] Filter greater than the value.
         * @param {string} [compositeTickerGte] Filter greater than or equal to the value.
         * @param {string} [compositeTickerLt] Filter less than the value.
         * @param {string} [compositeTickerLte] Filter less than or equal to the value.
         * @param {string} [constituentTicker] The stock ticker symbol of the individual security held within the ETF.
         * @param {string} [constituentTickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [constituentTickerGt] Filter greater than the value.
         * @param {string} [constituentTickerGte] Filter greater than or equal to the value.
         * @param {string} [constituentTickerLt] Filter less than the value.
         * @param {string} [constituentTickerLte] Filter less than or equal to the value.
         * @param {string} [effectiveDate] The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDate] The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [usCode] A unique identifier code for the constituent security in US markets.
         * @param {string} [usCodeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [usCodeGt] Filter greater than the value.
         * @param {string} [usCodeGte] Filter greater than or equal to the value.
         * @param {string} [usCodeLt] Filter less than the value.
         * @param {string} [usCodeLte] Filter less than or equal to the value.
         * @param {string} [isin] The International Securities Identification Number, a global standard for identifying securities.
         * @param {string} [isinAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [isinGt] Filter greater than the value.
         * @param {string} [isinGte] Filter greater than or equal to the value.
         * @param {string} [isinLt] Filter less than the value.
         * @param {string} [isinLte] Filter less than or equal to the value.
         * @param {string} [figi] The Financial Instrument Global Identifier, an open standard for uniquely identifying financial instruments.
         * @param {string} [figiAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [figiGt] Filter greater than the value.
         * @param {string} [figiGte] Filter greater than or equal to the value.
         * @param {string} [figiLt] Filter less than the value.
         * @param {string} [figiLte] Filter less than or equal to the value.
         * @param {string} [sedol] The Stock Exchange Daily Official List code, primarily used for securities trading in the UK.
         * @param {string} [sedolAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [sedolGt] Filter greater than the value.
         * @param {string} [sedolGte] Filter greater than or equal to the value.
         * @param {string} [sedolLt] Filter less than the value.
         * @param {string} [sedolLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEtfGlobalV1Constituents: async (compositeTicker?: string, compositeTickerAnyOf?: string, compositeTickerGt?: string, compositeTickerGte?: string, compositeTickerLt?: string, compositeTickerLte?: string, constituentTicker?: string, constituentTickerAnyOf?: string, constituentTickerGt?: string, constituentTickerGte?: string, constituentTickerLt?: string, constituentTickerLte?: string, effectiveDate?: string, effectiveDateGt?: string, effectiveDateGte?: string, effectiveDateLt?: string, effectiveDateLte?: string, processedDate?: string, processedDateGt?: string, processedDateGte?: string, processedDateLt?: string, processedDateLte?: string, usCode?: string, usCodeAnyOf?: string, usCodeGt?: string, usCodeGte?: string, usCodeLt?: string, usCodeLte?: string, isin?: string, isinAnyOf?: string, isinGt?: string, isinGte?: string, isinLt?: string, isinLte?: string, figi?: string, figiAnyOf?: string, figiGt?: string, figiGte?: string, figiLt?: string, figiLte?: string, sedol?: string, sedolAnyOf?: string, sedolGt?: string, sedolGte?: string, sedolLt?: string, sedolLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/etf-global/v1/constituents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (compositeTicker !== undefined) {
                localVarQueryParameter['composite_ticker'] = compositeTicker;
            }

            if (compositeTickerAnyOf !== undefined) {
                localVarQueryParameter['composite_ticker.any_of'] = compositeTickerAnyOf;
            }

            if (compositeTickerGt !== undefined) {
                localVarQueryParameter['composite_ticker.gt'] = compositeTickerGt;
            }

            if (compositeTickerGte !== undefined) {
                localVarQueryParameter['composite_ticker.gte'] = compositeTickerGte;
            }

            if (compositeTickerLt !== undefined) {
                localVarQueryParameter['composite_ticker.lt'] = compositeTickerLt;
            }

            if (compositeTickerLte !== undefined) {
                localVarQueryParameter['composite_ticker.lte'] = compositeTickerLte;
            }

            if (constituentTicker !== undefined) {
                localVarQueryParameter['constituent_ticker'] = constituentTicker;
            }

            if (constituentTickerAnyOf !== undefined) {
                localVarQueryParameter['constituent_ticker.any_of'] = constituentTickerAnyOf;
            }

            if (constituentTickerGt !== undefined) {
                localVarQueryParameter['constituent_ticker.gt'] = constituentTickerGt;
            }

            if (constituentTickerGte !== undefined) {
                localVarQueryParameter['constituent_ticker.gte'] = constituentTickerGte;
            }

            if (constituentTickerLt !== undefined) {
                localVarQueryParameter['constituent_ticker.lt'] = constituentTickerLt;
            }

            if (constituentTickerLte !== undefined) {
                localVarQueryParameter['constituent_ticker.lte'] = constituentTickerLte;
            }

            if (effectiveDate !== undefined) {
                localVarQueryParameter['effective_date'] = effectiveDate;
            }

            if (effectiveDateGt !== undefined) {
                localVarQueryParameter['effective_date.gt'] = effectiveDateGt;
            }

            if (effectiveDateGte !== undefined) {
                localVarQueryParameter['effective_date.gte'] = effectiveDateGte;
            }

            if (effectiveDateLt !== undefined) {
                localVarQueryParameter['effective_date.lt'] = effectiveDateLt;
            }

            if (effectiveDateLte !== undefined) {
                localVarQueryParameter['effective_date.lte'] = effectiveDateLte;
            }

            if (processedDate !== undefined) {
                localVarQueryParameter['processed_date'] = processedDate;
            }

            if (processedDateGt !== undefined) {
                localVarQueryParameter['processed_date.gt'] = processedDateGt;
            }

            if (processedDateGte !== undefined) {
                localVarQueryParameter['processed_date.gte'] = processedDateGte;
            }

            if (processedDateLt !== undefined) {
                localVarQueryParameter['processed_date.lt'] = processedDateLt;
            }

            if (processedDateLte !== undefined) {
                localVarQueryParameter['processed_date.lte'] = processedDateLte;
            }

            if (usCode !== undefined) {
                localVarQueryParameter['us_code'] = usCode;
            }

            if (usCodeAnyOf !== undefined) {
                localVarQueryParameter['us_code.any_of'] = usCodeAnyOf;
            }

            if (usCodeGt !== undefined) {
                localVarQueryParameter['us_code.gt'] = usCodeGt;
            }

            if (usCodeGte !== undefined) {
                localVarQueryParameter['us_code.gte'] = usCodeGte;
            }

            if (usCodeLt !== undefined) {
                localVarQueryParameter['us_code.lt'] = usCodeLt;
            }

            if (usCodeLte !== undefined) {
                localVarQueryParameter['us_code.lte'] = usCodeLte;
            }

            if (isin !== undefined) {
                localVarQueryParameter['isin'] = isin;
            }

            if (isinAnyOf !== undefined) {
                localVarQueryParameter['isin.any_of'] = isinAnyOf;
            }

            if (isinGt !== undefined) {
                localVarQueryParameter['isin.gt'] = isinGt;
            }

            if (isinGte !== undefined) {
                localVarQueryParameter['isin.gte'] = isinGte;
            }

            if (isinLt !== undefined) {
                localVarQueryParameter['isin.lt'] = isinLt;
            }

            if (isinLte !== undefined) {
                localVarQueryParameter['isin.lte'] = isinLte;
            }

            if (figi !== undefined) {
                localVarQueryParameter['figi'] = figi;
            }

            if (figiAnyOf !== undefined) {
                localVarQueryParameter['figi.any_of'] = figiAnyOf;
            }

            if (figiGt !== undefined) {
                localVarQueryParameter['figi.gt'] = figiGt;
            }

            if (figiGte !== undefined) {
                localVarQueryParameter['figi.gte'] = figiGte;
            }

            if (figiLt !== undefined) {
                localVarQueryParameter['figi.lt'] = figiLt;
            }

            if (figiLte !== undefined) {
                localVarQueryParameter['figi.lte'] = figiLte;
            }

            if (sedol !== undefined) {
                localVarQueryParameter['sedol'] = sedol;
            }

            if (sedolAnyOf !== undefined) {
                localVarQueryParameter['sedol.any_of'] = sedolAnyOf;
            }

            if (sedolGt !== undefined) {
                localVarQueryParameter['sedol.gt'] = sedolGt;
            }

            if (sedolGte !== undefined) {
                localVarQueryParameter['sedol.gte'] = sedolGte;
            }

            if (sedolLt !== undefined) {
                localVarQueryParameter['sedol.lt'] = sedolLt;
            }

            if (sedolLte !== undefined) {
                localVarQueryParameter['sedol.lte'] = sedolLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ETF Global fund flow data containing information about ETF share movements, net asset values, and fund flow metrics.
         * @param {string} [processedDate] The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDate] The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [compositeTicker] The stock ticker symbol used to identify this ETF on exchanges.
         * @param {string} [compositeTickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [compositeTickerGt] Filter greater than the value.
         * @param {string} [compositeTickerGte] Filter greater than or equal to the value.
         * @param {string} [compositeTickerLt] Filter less than the value.
         * @param {string} [compositeTickerLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEtfGlobalV1FundFlows: async (processedDate?: string, processedDateGt?: string, processedDateGte?: string, processedDateLt?: string, processedDateLte?: string, effectiveDate?: string, effectiveDateGt?: string, effectiveDateGte?: string, effectiveDateLt?: string, effectiveDateLte?: string, compositeTicker?: string, compositeTickerAnyOf?: string, compositeTickerGt?: string, compositeTickerGte?: string, compositeTickerLt?: string, compositeTickerLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/etf-global/v1/fund-flows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (processedDate !== undefined) {
                localVarQueryParameter['processed_date'] = processedDate;
            }

            if (processedDateGt !== undefined) {
                localVarQueryParameter['processed_date.gt'] = processedDateGt;
            }

            if (processedDateGte !== undefined) {
                localVarQueryParameter['processed_date.gte'] = processedDateGte;
            }

            if (processedDateLt !== undefined) {
                localVarQueryParameter['processed_date.lt'] = processedDateLt;
            }

            if (processedDateLte !== undefined) {
                localVarQueryParameter['processed_date.lte'] = processedDateLte;
            }

            if (effectiveDate !== undefined) {
                localVarQueryParameter['effective_date'] = effectiveDate;
            }

            if (effectiveDateGt !== undefined) {
                localVarQueryParameter['effective_date.gt'] = effectiveDateGt;
            }

            if (effectiveDateGte !== undefined) {
                localVarQueryParameter['effective_date.gte'] = effectiveDateGte;
            }

            if (effectiveDateLt !== undefined) {
                localVarQueryParameter['effective_date.lt'] = effectiveDateLt;
            }

            if (effectiveDateLte !== undefined) {
                localVarQueryParameter['effective_date.lte'] = effectiveDateLte;
            }

            if (compositeTicker !== undefined) {
                localVarQueryParameter['composite_ticker'] = compositeTicker;
            }

            if (compositeTickerAnyOf !== undefined) {
                localVarQueryParameter['composite_ticker.any_of'] = compositeTickerAnyOf;
            }

            if (compositeTickerGt !== undefined) {
                localVarQueryParameter['composite_ticker.gt'] = compositeTickerGt;
            }

            if (compositeTickerGte !== undefined) {
                localVarQueryParameter['composite_ticker.gte'] = compositeTickerGte;
            }

            if (compositeTickerLt !== undefined) {
                localVarQueryParameter['composite_ticker.lt'] = compositeTickerLt;
            }

            if (compositeTickerLte !== undefined) {
                localVarQueryParameter['composite_ticker.lte'] = compositeTickerLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ETF Global industry profile data containing comprehensive ETF metadata including financial metrics, operational details, and exposure information.
         * @param {string} [processedDate] The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDate] The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [compositeTicker] The stock ticker symbol used to identify this ETF product on exchanges.
         * @param {string} [compositeTickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [compositeTickerGt] Filter greater than the value.
         * @param {string} [compositeTickerGte] Filter greater than or equal to the value.
         * @param {string} [compositeTickerLt] Filter less than the value.
         * @param {string} [compositeTickerLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEtfGlobalV1Profiles: async (processedDate?: string, processedDateGt?: string, processedDateGte?: string, processedDateLt?: string, processedDateLte?: string, effectiveDate?: string, effectiveDateGt?: string, effectiveDateGte?: string, effectiveDateLt?: string, effectiveDateLte?: string, compositeTicker?: string, compositeTickerAnyOf?: string, compositeTickerGt?: string, compositeTickerGte?: string, compositeTickerLt?: string, compositeTickerLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/etf-global/v1/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (processedDate !== undefined) {
                localVarQueryParameter['processed_date'] = processedDate;
            }

            if (processedDateGt !== undefined) {
                localVarQueryParameter['processed_date.gt'] = processedDateGt;
            }

            if (processedDateGte !== undefined) {
                localVarQueryParameter['processed_date.gte'] = processedDateGte;
            }

            if (processedDateLt !== undefined) {
                localVarQueryParameter['processed_date.lt'] = processedDateLt;
            }

            if (processedDateLte !== undefined) {
                localVarQueryParameter['processed_date.lte'] = processedDateLte;
            }

            if (effectiveDate !== undefined) {
                localVarQueryParameter['effective_date'] = effectiveDate;
            }

            if (effectiveDateGt !== undefined) {
                localVarQueryParameter['effective_date.gt'] = effectiveDateGt;
            }

            if (effectiveDateGte !== undefined) {
                localVarQueryParameter['effective_date.gte'] = effectiveDateGte;
            }

            if (effectiveDateLt !== undefined) {
                localVarQueryParameter['effective_date.lt'] = effectiveDateLt;
            }

            if (effectiveDateLte !== undefined) {
                localVarQueryParameter['effective_date.lte'] = effectiveDateLte;
            }

            if (compositeTicker !== undefined) {
                localVarQueryParameter['composite_ticker'] = compositeTicker;
            }

            if (compositeTickerAnyOf !== undefined) {
                localVarQueryParameter['composite_ticker.any_of'] = compositeTickerAnyOf;
            }

            if (compositeTickerGt !== undefined) {
                localVarQueryParameter['composite_ticker.gt'] = compositeTickerGt;
            }

            if (compositeTickerGte !== undefined) {
                localVarQueryParameter['composite_ticker.gte'] = compositeTickerGte;
            }

            if (compositeTickerLt !== undefined) {
                localVarQueryParameter['composite_ticker.lt'] = compositeTickerLt;
            }

            if (compositeTickerLte !== undefined) {
                localVarQueryParameter['composite_ticker.lte'] = compositeTickerLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ETF Global taxonomy data containing detailed classification and categorization information for ETFs including investment strategy, methodology, and structural characteristics.
         * @param {string} [processedDate] The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDate] The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [compositeTicker] The stock ticker symbol used to identify this ETF product on exchanges.
         * @param {string} [compositeTickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [compositeTickerGt] Filter greater than the value.
         * @param {string} [compositeTickerGte] Filter greater than or equal to the value.
         * @param {string} [compositeTickerLt] Filter less than the value.
         * @param {string} [compositeTickerLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEtfGlobalV1Taxonomies: async (processedDate?: string, processedDateGt?: string, processedDateGte?: string, processedDateLt?: string, processedDateLte?: string, effectiveDate?: string, effectiveDateGt?: string, effectiveDateGte?: string, effectiveDateLt?: string, effectiveDateLte?: string, compositeTicker?: string, compositeTickerAnyOf?: string, compositeTickerGt?: string, compositeTickerGte?: string, compositeTickerLt?: string, compositeTickerLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/etf-global/v1/taxonomies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (processedDate !== undefined) {
                localVarQueryParameter['processed_date'] = processedDate;
            }

            if (processedDateGt !== undefined) {
                localVarQueryParameter['processed_date.gt'] = processedDateGt;
            }

            if (processedDateGte !== undefined) {
                localVarQueryParameter['processed_date.gte'] = processedDateGte;
            }

            if (processedDateLt !== undefined) {
                localVarQueryParameter['processed_date.lt'] = processedDateLt;
            }

            if (processedDateLte !== undefined) {
                localVarQueryParameter['processed_date.lte'] = processedDateLte;
            }

            if (effectiveDate !== undefined) {
                localVarQueryParameter['effective_date'] = effectiveDate;
            }

            if (effectiveDateGt !== undefined) {
                localVarQueryParameter['effective_date.gt'] = effectiveDateGt;
            }

            if (effectiveDateGte !== undefined) {
                localVarQueryParameter['effective_date.gte'] = effectiveDateGte;
            }

            if (effectiveDateLt !== undefined) {
                localVarQueryParameter['effective_date.lt'] = effectiveDateLt;
            }

            if (effectiveDateLte !== undefined) {
                localVarQueryParameter['effective_date.lte'] = effectiveDateLte;
            }

            if (compositeTicker !== undefined) {
                localVarQueryParameter['composite_ticker'] = compositeTicker;
            }

            if (compositeTickerAnyOf !== undefined) {
                localVarQueryParameter['composite_ticker.any_of'] = compositeTickerAnyOf;
            }

            if (compositeTickerGt !== undefined) {
                localVarQueryParameter['composite_ticker.gt'] = compositeTickerGt;
            }

            if (compositeTickerGte !== undefined) {
                localVarQueryParameter['composite_ticker.gte'] = compositeTickerGte;
            }

            if (compositeTickerLt !== undefined) {
                localVarQueryParameter['composite_ticker.lt'] = compositeTickerLt;
            }

            if (compositeTickerLte !== undefined) {
                localVarQueryParameter['composite_ticker.lte'] = compositeTickerLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
         * @summary Ticker Events
         * @param {string} id Identifier of an asset, which can be a Ticker, CUSIP, or Composite FIGI. Specify a case-sensitive  ticker symbol (e.g. AAPL for Apple Inc). When provided a ticker, events for the entity currently  represented by that ticker are returned. To find events for entities previously associated with a  ticker, obtain the relevant identifier using the [Ticker Details Endpoint](https://massive.com/docs/rest/stocks/tickers/ticker-overview).
         * @param {string} [types] A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (id: string, types?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEvents', 'id', id)
            const localVarPath = `/vX/reference/tickers/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A table tracking inflation and price indices, including Consumer Price Index (CPI) and Personal Consumption Expenditures (PCE) metrics over time.
         * @param {string} [date] Calendar date of the observation (YYYYMMDD).
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFedV1Inflation: async (date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fed/v1/inflation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A table tracking inflation expectations from both market-based and economic model perspectives across different time horizons.
         * @param {string} [date] Calendar date of the observation (YYYYMMDD).
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFedV1InflationExpectations: async (date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fed/v1/inflation-expectations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A record of U.S. Treasury bond yields across various maturity periods, tracking historical interest rates from short-term to long-term government securities.
         * @param {string} [date] Calendar date of the yield observation (YYYY-MM-DD).
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFedV1TreasuryYields: async (date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fed/v1/treasury-yields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for a forex pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetForexAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetForexAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexAggregates: async (forexTicker: string, multiplier: number, timespan: GetForexAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetForexAggregatesSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forexTicker' is not null or undefined
            assertParamExists('getForexAggregates', 'forexTicker', forexTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('getForexAggregates', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('getForexAggregates', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getForexAggregates', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getForexAggregates', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{forexTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"forexTicker"}}`, encodeURIComponent(String(forexTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} fxTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetForexEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexEMA: async (fxTicker: string, timestamp?: string, timespan?: GetForexEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('getForexEMA', 'fxTicker', fxTicker)
            const localVarPath = `/v1/indicators/ema/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} fxTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetForexMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexMACD: async (fxTicker: string, timestamp?: string, timespan?: GetForexMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetForexMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('getForexMACD', 'fxTicker', fxTicker)
            const localVarPath = `/v1/indicators/macd/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get BBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (BBO)
         * @param {string} fxTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetForexQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetForexQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexQuotes: async (fxTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetForexQuotesOrderEnum, limit?: number, sort?: GetForexQuotesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('getForexQuotes', 'fxTicker', fxTicker)
            const localVarPath = `/v3/quotes/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} fxTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetForexRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexRSI: async (fxTicker: string, timestamp?: string, timespan?: GetForexRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('getForexRSI', 'fxTicker', fxTicker)
            const localVarPath = `/v1/indicators/rsi/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} fxTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetForexSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSMA: async (fxTicker: string, timestamp?: string, timespan?: GetForexSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fxTicker' is not null or undefined
            assertParamExists('getForexSMA', 'fxTicker', fxTicker)
            const localVarPath = `/v1/indicators/sma/{fxTicker}`
                .replace(`{${"fxTicker"}}`, encodeURIComponent(String(fxTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current top 20 gainers or losers of the day in forex markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetForexSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSnapshotDirection: async (direction: GetForexSnapshotDirectionDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('getForexSnapshotDirection', 'direction', direction)
            const localVarPath = `/v2/snapshot/locale/global/markets/forex/{direction}`
                .replace(`{${"direction"}}`, encodeURIComponent(String(direction)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded currency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker The forex ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSnapshotTicker: async (ticker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getForexSnapshotTicker', 'ticker', ticker)
            const localVarPath = `/v2/snapshot/locale/global/markets/forex/tickers/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded forex symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSnapshotTickers: async (tickers?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/snapshot/locale/global/markets/forex/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickers) {
                localVarQueryParameter['tickers'] = tickers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Global foreign exchange (FX) trading venues and market infrastructure, including electronic trading platforms, banks, and other institutions facilitating currency pair trading worldwide.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexV1Exchanges: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/forex/v1/exchanges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregates for a contract in a given time range.
         * @summary Aggregates
         * @param {string} ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
         * @param {string} [resolution] This sets the size of the aggregate windows. It accepts custom values that specify the granularity and the duration of the window. For example: 15mins, 30secs, 12hours, or 7days. There are maximum allowable candle sizes. For example, you can request \&quot;1min\&quot; to \&quot;59mins\&quot;, but after that you will need to use \&quot;1hr\&quot;. If you make a request for a candle size that is not supported, we will return a 400 \&quot;Bad Request - resolution value is not allowed.\&quot;
         * @param {string} [windowStart] Specifies the start time of the aggregate (OHLC) candles you want returned (YYYY-MM-DD date or nanosecond Unix timestamp). How it works - If not provided, the API returns the most recent candles available, up to the limit you set. - If provided, the value determines which candle(s) to return. The timestamp or date is snapped to the start time of the matching candle interval. - You can use comparison operators to form ranges:   - &#x60;window_start.gte&#x60;  greater than or equal to   - &#x60;window_start.gt&#x60;  greater than   - &#x60;window_start.lte&#x60;  less than or equal to   - &#x60;window_start.lt&#x60;  less than  Examples 1. Most recent minute candles    &#x60;/vX/aggs/ESU5?resolution&#x3D;1min&amp;limit&#x3D;5&#x60;  2. Daily candle for August 5, 2025    &#x60;/vX/aggs/ESU5?resolution&#x3D;1day&amp;window_start&#x3D;2025-08-05&#x60;  3. Daily candles from July 131, 2025    &#x60;/vX/aggs/ESU5?resolution&#x3D;1day&amp;window_start.gte&#x3D;2025-07-01&amp;window_start.lte&#x3D;2025-07-31&#x60;  4. 1,000 one-second candles after a specific timestamp    &#x60;/vX/aggs/ESU5?resolution&#x3D;1sec&amp;window_start.gt&#x3D;1751409877000000000&amp;limit&#x3D;1000&#x60;
         * @param {number} [limit] The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1).
         * @param {string} [windowStartGte] Range by window_start.
         * @param {string} [windowStartGt] Range by window_start.
         * @param {string} [windowStartLte] Range by window_start.
         * @param {string} [windowStartLt] Range by window_start.
         * @param {GetFuturesAggregatesSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesAggregates: async (ticker: string, resolution?: string, windowStart?: string, limit?: number, windowStartGte?: string, windowStartGt?: string, windowStartLte?: string, windowStartLt?: string, sort?: GetFuturesAggregatesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getFuturesAggregates', 'ticker', ticker)
            const localVarPath = `/futures/vX/aggs/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (resolution !== undefined) {
                localVarQueryParameter['resolution'] = resolution;
            }

            if (windowStart !== undefined) {
                localVarQueryParameter['window_start'] = windowStart;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (windowStartGte !== undefined) {
                localVarQueryParameter['window_start.gte'] = windowStartGte;
            }

            if (windowStartGt !== undefined) {
                localVarQueryParameter['window_start.gt'] = windowStartGt;
            }

            if (windowStartLte !== undefined) {
                localVarQueryParameter['window_start.lte'] = windowStartLte;
            }

            if (windowStartLt !== undefined) {
                localVarQueryParameter['window_start.lt'] = windowStartLt;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Contract Details endpoint returns the details for a single contract at a specific point in time.
         * @summary Contract Details
         * @param {string} ticker The ticker symbol of the contract to retrieve.
         * @param {string} [asOf] The point-in-time of the data to be retrieved. Note that the contract data returned for a given date represents the state of that contract on that day. A date in the format YYYY-MM-DD (default&#x3D;today).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesContractDetails: async (ticker: string, asOf?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getFuturesContractDetails', 'ticker', ticker)
            const localVarPath = `/futures/vX/contracts/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (asOf !== undefined) {
                localVarQueryParameter['as_of'] = (asOf as any instanceof Date) ?
                    (asOf as any).toISOString().substring(0,10) :
                    asOf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Contracts endpoint returns a list of futures contracts. This endpoint can be used to query for contracts based on a variety of parameters, including the contract\'s ticker, product code, first trade date, last trade date, and whether or not the contract was active on a given date.
         * @summary Contracts
         * @param {string} [productCode] A unique identifier for the Product a Contract belongs to. Note that multiple contracts can belong to the same product.
         * @param {string} [firstTradeDate] The first day that a contract was tradeable. A date with the format YYYY-MM-DD.
         * @param {string} [lastTradeDate] The last day that the contract was tradeable. A date with the format YYYY-MM-DD.
         * @param {string} [asOf] Specify the point-in-time for which you want to retrieve information. Note that the contract data returned for a given date is the state of that contract as of that day. A date in the format YYYY-MM-DD (default&#x3D;today).
         * @param {GetFuturesContractsActiveEnum} [active] Filter for contracts based on whether or not they were tradeable at the given point in time. For example, if the date queried is greater-than or equal-to a contract\&#39;s \&#39;first_trade_date\&#39; and less-than-or-equal-to its \&#39;last_trade_date\&#39;, then the contract was active. If the date queried is greater-than-or-equal-to the contract\&#39;s \&#39;last_trade_date\&#39; or less-than-or-equal-to its \&#39;first_trade_date\&#39;, then the contract was inactive.
         * @param {GetFuturesContractsTypeEnum} [type] The type of contract, one of \&quot;all\&quot;, \&quot;single\&quot;, or \&quot;combo\&quot; (default&#x3D;all).
         * @param {number} [limit] The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1).
         * @param {GetFuturesContractsSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesContracts: async (productCode?: string, firstTradeDate?: string, lastTradeDate?: string, asOf?: string, active?: GetFuturesContractsActiveEnum, type?: GetFuturesContractsTypeEnum, limit?: number, sort?: GetFuturesContractsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/futures/vX/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (productCode !== undefined) {
                localVarQueryParameter['product_code'] = productCode;
            }

            if (firstTradeDate !== undefined) {
                localVarQueryParameter['first_trade_date'] = (firstTradeDate as any instanceof Date) ?
                    (firstTradeDate as any).toISOString().substring(0,10) :
                    firstTradeDate;
            }

            if (lastTradeDate !== undefined) {
                localVarQueryParameter['last_trade_date'] = (lastTradeDate as any instanceof Date) ?
                    (lastTradeDate as any).toISOString().substring(0,10) :
                    lastTradeDate;
            }

            if (asOf !== undefined) {
                localVarQueryParameter['as_of'] = (asOf as any instanceof Date) ?
                    (asOf as any).toISOString().substring(0,10) :
                    asOf;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Trading-Date Based Futures Schedules API provides detailed trading schedules for all products on a specific day. This API allows you to retrieve detailed information about trading sessions, including market events like preopen, open, and closed, along with their precise timestamps.
         * @summary Daily Schedules
         * @param {string} [sessionEndDate] The session end date for the schedules (also known as the trading date). This is the day in CT for which the user wants to retrieve data. If left blank, this value defaults to \&#39;today\&#39; in Central Time. e.g. If a request is made from Pacific Time on \&#39;2025-01-01\&#39; at 11:00 pm with no \&#39;session_end_date\&#39; a default value of &#x60;2025-01-02&#x60; will be used.
         * @param {string} [tradingVenue] The trading venue (MIC) of the exchange for the schedules.
         * @param {number} [limit] The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1).
         * @param {GetFuturesDailySchedulesSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDailySchedules: async (sessionEndDate?: string, tradingVenue?: string, limit?: number, sort?: GetFuturesDailySchedulesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/futures/vX/schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (sessionEndDate !== undefined) {
                localVarQueryParameter['session_end_date'] = (sessionEndDate as any instanceof Date) ?
                    (sessionEndDate as any).toISOString().substring(0,10) :
                    sessionEndDate;
            }

            if (tradingVenue !== undefined) {
                localVarQueryParameter['trading_venue'] = tradingVenue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The market status endpoint returns the current status of the futures market for the given product code(s).
         * @summary Market Status
         * @param {string} [productCodeAnyOf] The product code(s) to return market statuses for.  Multiple product codes can be specified by separating them with a comma. Currently, the limit is 250 product codes.
         * @param {string} [productCode] The product code to return market statuses for.
         * @param {number} [limit] The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1).
         * @param {GetFuturesMarketStatusesSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesMarketStatuses: async (productCodeAnyOf?: string, productCode?: string, limit?: number, sort?: GetFuturesMarketStatusesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/futures/vX/market-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (productCodeAnyOf !== undefined) {
                localVarQueryParameter['product_code.any_of'] = productCodeAnyOf;
            }

            if (productCode !== undefined) {
                localVarQueryParameter['product_code'] = productCode;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Product Details endpoint returns the details for a single product as of a specific day.
         * @summary Product Details
         * @param {string} productCode The unique identifier for a product.
         * @param {GetFuturesProductDetailsTypeEnum} [type] The type of product to return. One of \&quot;single\&quot; or \&quot;combo\&quot; (default&#x3D;single).
         * @param {string} [asOf] A date string in the format YYYY-MM-DD. Note that the data returned is the state of this product\&#39;s data at that point-in-time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesProductDetails: async (productCode: string, type?: GetFuturesProductDetailsTypeEnum, asOf?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productCode' is not null or undefined
            assertParamExists('getFuturesProductDetails', 'productCode', productCode)
            const localVarPath = `/futures/vX/products/{product_code}`
                .replace(`{${"product_code"}}`, encodeURIComponent(String(productCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (asOf !== undefined) {
                localVarQueryParameter['as_of'] = (asOf as any instanceof Date) ?
                    (asOf as any).toISOString().substring(0,10) :
                    asOf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Product-Specific Futures Schedules API provides detailed trading schedules for a specific futures product. This API allows you to query schedules for a single product across a range of dates. Users can access comprehensive information about trading sessions, including market events such as preopen, open, and closed, along with their precise timestamps.
         * @summary Product Schedules
         * @param {string} productCode The product code for the futures product.
         * @param {string} [sessionEndDate] The date on which the schedule\&#39;s trading day ended (sometimes referred to as trading date). Defaults to today. Formatted as &#x60;YYYY-MM-DD&#x60;. Note that although there is no time component the day is assumed to be that day in Central Time.
         * @param {number} [limit] The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1).
         * @param {string} [sessionEndDateGte] Range by session_end_date.
         * @param {string} [sessionEndDateGt] Range by session_end_date.
         * @param {string} [sessionEndDateLte] Range by session_end_date.
         * @param {string} [sessionEndDateLt] Range by session_end_date.
         * @param {GetFuturesProductSchedulesSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesProductSchedules: async (productCode: string, sessionEndDate?: string, limit?: number, sessionEndDateGte?: string, sessionEndDateGt?: string, sessionEndDateLte?: string, sessionEndDateLt?: string, sort?: GetFuturesProductSchedulesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productCode' is not null or undefined
            assertParamExists('getFuturesProductSchedules', 'productCode', productCode)
            const localVarPath = `/futures/vX/products/{product_code}/schedules`
                .replace(`{${"product_code"}}`, encodeURIComponent(String(productCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (sessionEndDate !== undefined) {
                localVarQueryParameter['session_end_date'] = (sessionEndDate as any instanceof Date) ?
                    (sessionEndDate as any).toISOString().substring(0,10) :
                    sessionEndDate;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sessionEndDateGte !== undefined) {
                localVarQueryParameter['session_end_date.gte'] = (sessionEndDateGte as any instanceof Date) ?
                    (sessionEndDateGte as any).toISOString().substring(0,10) :
                    sessionEndDateGte;
            }

            if (sessionEndDateGt !== undefined) {
                localVarQueryParameter['session_end_date.gt'] = (sessionEndDateGt as any instanceof Date) ?
                    (sessionEndDateGt as any).toISOString().substring(0,10) :
                    sessionEndDateGt;
            }

            if (sessionEndDateLte !== undefined) {
                localVarQueryParameter['session_end_date.lte'] = (sessionEndDateLte as any instanceof Date) ?
                    (sessionEndDateLte as any).toISOString().substring(0,10) :
                    sessionEndDateLte;
            }

            if (sessionEndDateLt !== undefined) {
                localVarQueryParameter['session_end_date.lt'] = (sessionEndDateLt as any instanceof Date) ?
                    (sessionEndDateLt as any).toISOString().substring(0,10) :
                    sessionEndDateLt;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Products endpoint returns a list of futures products. This endpoint can be used to query for products based on a variety of parameters, including by the product\'s name, exchange, sector, sub-sector, asset class, asset sub-class, and type.
         * @summary Products
         * @param {string} [name] Search for products by Product Name. This parameter supports an exact match, while a name-contains search can be performed using the &#x60;name.search&#x60; parameter. Note that the search is case-sensitive.
         * @param {string} [asOf] A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day (default&#x3D;today).
         * @param {string} [tradingVenue] The trading venue (MIC) for the exchange on which the products trades.
         * @param {GetFuturesProductsSectorEnum} [sector] The sector to which the products belong.
         * @param {GetFuturesProductsSubSectorEnum} [subSector] The sub-sector to which the products belong.
         * @param {GetFuturesProductsAssetClassEnum} [assetClass] The asset class to which the products belong.
         * @param {GetFuturesProductsAssetSubClassEnum} [assetSubClass] The asset sub-class to which the products belong.
         * @param {GetFuturesProductsTypeEnum} [type] The type of products to return. One of \&quot;all\&quot;, \&quot;single\&quot;, or \&quot;combo\&quot; (default&#x3D;all).
         * @param {number} [limit] The number of results to return per page (default&#x3D;100, maximum&#x3D;1000, minimum&#x3D;1).
         * @param {string} [nameSearch] Search by name.
         * @param {GetFuturesProductsSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesProducts: async (name?: string, asOf?: string, tradingVenue?: string, sector?: GetFuturesProductsSectorEnum, subSector?: GetFuturesProductsSubSectorEnum, assetClass?: GetFuturesProductsAssetClassEnum, assetSubClass?: GetFuturesProductsAssetSubClassEnum, type?: GetFuturesProductsTypeEnum, limit?: number, nameSearch?: string, sort?: GetFuturesProductsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/futures/vX/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (asOf !== undefined) {
                localVarQueryParameter['as_of'] = (asOf as any instanceof Date) ?
                    (asOf as any).toISOString().substring(0,10) :
                    asOf;
            }

            if (tradingVenue !== undefined) {
                localVarQueryParameter['trading_venue'] = tradingVenue;
            }

            if (sector !== undefined) {
                localVarQueryParameter['sector'] = sector;
            }

            if (subSector !== undefined) {
                localVarQueryParameter['sub_sector'] = subSector;
            }

            if (assetClass !== undefined) {
                localVarQueryParameter['asset_class'] = assetClass;
            }

            if (assetSubClass !== undefined) {
                localVarQueryParameter['asset_sub_class'] = assetSubClass;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (nameSearch !== undefined) {
                localVarQueryParameter['name.search'] = nameSearch;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get quotes for a contract in a given time range.
         * @summary Quotes
         * @param {string} ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [sessionEndDate] Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
         * @param {number} [limit] The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1).
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {string} [sessionEndDateGte] Range by session_end_date.
         * @param {string} [sessionEndDateGt] Range by session_end_date.
         * @param {string} [sessionEndDateLte] Range by session_end_date.
         * @param {string} [sessionEndDateLt] Range by session_end_date.
         * @param {GetFuturesQuotesSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesQuotes: async (ticker: string, timestamp?: string, sessionEndDate?: string, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, sessionEndDateGte?: string, sessionEndDateGt?: string, sessionEndDateLte?: string, sessionEndDateLt?: string, sort?: GetFuturesQuotesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getFuturesQuotes', 'ticker', ticker)
            const localVarPath = `/futures/vX/quotes/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (sessionEndDate !== undefined) {
                localVarQueryParameter['session_end_date'] = sessionEndDate;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (sessionEndDateGte !== undefined) {
                localVarQueryParameter['session_end_date.gte'] = sessionEndDateGte;
            }

            if (sessionEndDateGt !== undefined) {
                localVarQueryParameter['session_end_date.gt'] = sessionEndDateGt;
            }

            if (sessionEndDateLte !== undefined) {
                localVarQueryParameter['session_end_date.lte'] = sessionEndDateLte;
            }

            if (sessionEndDateLt !== undefined) {
                localVarQueryParameter['session_end_date.lt'] = sessionEndDateLt;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a contract in a given time range.
         * @summary Trades
         * @param {string} ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [sessionEndDate] Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
         * @param {number} [limit] The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1).
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {string} [sessionEndDateGte] Range by session_end_date.
         * @param {string} [sessionEndDateGt] Range by session_end_date.
         * @param {string} [sessionEndDateLte] Range by session_end_date.
         * @param {string} [sessionEndDateLt] Range by session_end_date.
         * @param {GetFuturesTradesSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesTrades: async (ticker: string, timestamp?: string, sessionEndDate?: string, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, sessionEndDateGte?: string, sessionEndDateGt?: string, sessionEndDateLte?: string, sessionEndDateLt?: string, sort?: GetFuturesTradesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getFuturesTrades', 'ticker', ticker)
            const localVarPath = `/futures/vX/trades/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (sessionEndDate !== undefined) {
                localVarQueryParameter['session_end_date'] = sessionEndDate;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (sessionEndDateGte !== undefined) {
                localVarQueryParameter['session_end_date.gte'] = sessionEndDateGte;
            }

            if (sessionEndDateGt !== undefined) {
                localVarQueryParameter['session_end_date.gt'] = sessionEndDateGt;
            }

            if (sessionEndDateLte !== undefined) {
                localVarQueryParameter['session_end_date.lte'] = sessionEndDateLte;
            }

            if (sessionEndDateLt !== undefined) {
                localVarQueryParameter['session_end_date.lt'] = sessionEndDateLt;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information about a specific futures contract identified by its ticker. The response includes comprehensive attributes such as active status, trade dates, days to maturity, exchange code, order quantity limits, settlement date, tick sizes, and other key metrics. Users can specify a point-in-time (as_of) to view the contract\'s state on a particular date, supporting informed trading decisions and historical analysis.  Use Cases: Contract specification, historical product checks, system integration, trading decision support.
         * @summary futures_contracts_v1 API
         * @param {string} [date] A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day (default&#x3D;today). Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [productCode] The unique identifier for the product.
         * @param {string} [productCodeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [productCodeGt] Filter greater than the value.
         * @param {string} [productCodeGte] Filter greater than or equal to the value.
         * @param {string} [productCodeLt] Filter less than the value.
         * @param {string} [productCodeLte] Filter less than or equal to the value.
         * @param {string} [ticker] The ticker for the contract.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [active] The contract is still trading. Value must be \&#39;true\&#39;, \&#39;false\&#39;, \&#39;1\&#39; or \&#39;0\&#39;.
         * @param {string} [type] The type of product, one of \&#39;single\&#39; or \&#39;combo\&#39;.
         * @param {string} [typeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [typeGt] Filter greater than the value.
         * @param {string} [typeGte] Filter greater than or equal to the value.
         * @param {string} [typeLt] Filter less than the value.
         * @param {string} [typeLte] Filter less than or equal to the value.
         * @param {string} [firstTradeDate] The first date the contract trades. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [firstTradeDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [firstTradeDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [firstTradeDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [firstTradeDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastTradeDate] The last date the contract trades. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastTradeDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastTradeDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastTradeDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastTradeDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;1000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;product_code\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesVXContractsNew: async (date?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, productCode?: string, productCodeAnyOf?: string, productCodeGt?: string, productCodeGte?: string, productCodeLt?: string, productCodeLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, active?: string, type?: string, typeAnyOf?: string, typeGt?: string, typeGte?: string, typeLt?: string, typeLte?: string, firstTradeDate?: string, firstTradeDateGt?: string, firstTradeDateGte?: string, firstTradeDateLt?: string, firstTradeDateLte?: string, lastTradeDate?: string, lastTradeDateGt?: string, lastTradeDateGte?: string, lastTradeDateLt?: string, lastTradeDateLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/futures/vX/contracts-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (productCode !== undefined) {
                localVarQueryParameter['product_code'] = productCode;
            }

            if (productCodeAnyOf !== undefined) {
                localVarQueryParameter['product_code.any_of'] = productCodeAnyOf;
            }

            if (productCodeGt !== undefined) {
                localVarQueryParameter['product_code.gt'] = productCodeGt;
            }

            if (productCodeGte !== undefined) {
                localVarQueryParameter['product_code.gte'] = productCodeGte;
            }

            if (productCodeLt !== undefined) {
                localVarQueryParameter['product_code.lt'] = productCodeLt;
            }

            if (productCodeLte !== undefined) {
                localVarQueryParameter['product_code.lte'] = productCodeLte;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (typeAnyOf !== undefined) {
                localVarQueryParameter['type.any_of'] = typeAnyOf;
            }

            if (typeGt !== undefined) {
                localVarQueryParameter['type.gt'] = typeGt;
            }

            if (typeGte !== undefined) {
                localVarQueryParameter['type.gte'] = typeGte;
            }

            if (typeLt !== undefined) {
                localVarQueryParameter['type.lt'] = typeLt;
            }

            if (typeLte !== undefined) {
                localVarQueryParameter['type.lte'] = typeLte;
            }

            if (firstTradeDate !== undefined) {
                localVarQueryParameter['first_trade_date'] = firstTradeDate;
            }

            if (firstTradeDateGt !== undefined) {
                localVarQueryParameter['first_trade_date.gt'] = firstTradeDateGt;
            }

            if (firstTradeDateGte !== undefined) {
                localVarQueryParameter['first_trade_date.gte'] = firstTradeDateGte;
            }

            if (firstTradeDateLt !== undefined) {
                localVarQueryParameter['first_trade_date.lt'] = firstTradeDateLt;
            }

            if (firstTradeDateLte !== undefined) {
                localVarQueryParameter['first_trade_date.lte'] = firstTradeDateLte;
            }

            if (lastTradeDate !== undefined) {
                localVarQueryParameter['last_trade_date'] = lastTradeDate;
            }

            if (lastTradeDateGt !== undefined) {
                localVarQueryParameter['last_trade_date.gt'] = lastTradeDateGt;
            }

            if (lastTradeDateGte !== undefined) {
                localVarQueryParameter['last_trade_date.gte'] = lastTradeDateGte;
            }

            if (lastTradeDateLt !== undefined) {
                localVarQueryParameter['last_trade_date.lt'] = lastTradeDateLt;
            }

            if (lastTradeDateLte !== undefined) {
                localVarQueryParameter['last_trade_date.lte'] = lastTradeDateLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * US futures exchanges and trading venues including major derivatives exchanges (CME, CBOT, NYMEX, COMEX) and other futures market infrastructure for commodity, financial, and other derivative contract trading.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesVXExchanges: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/futures/vX/exchanges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information about a single futures product as of a specified date, including its asset class, exchange code, full product name, settlement details, pricing quotation, sector classifications, and unit of measure. Optional parameters such as product type (single or combo) and as_of allow you to capture the products state on a specific day, providing essential context for trading decisions and system integrations.  Use Cases: Product specification, historical product checks, risk management, trading system integration.
         * @summary futures_products_v1 API
         * @param {string} [name] The full name of the product.
         * @param {string} [nameAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [nameGt] Filter greater than the value.
         * @param {string} [nameGte] Filter greater than or equal to the value.
         * @param {string} [nameLt] Filter less than the value.
         * @param {string} [nameLte] Filter less than or equal to the value.
         * @param {string} [productCode] The unique identifier for the product.
         * @param {string} [productCodeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [productCodeGt] Filter greater than the value.
         * @param {string} [productCodeGte] Filter greater than or equal to the value.
         * @param {string} [productCodeLt] Filter less than the value.
         * @param {string} [productCodeLte] Filter less than or equal to the value.
         * @param {string} [date] A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day (default&#x3D;today). Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [sector] The sector to which the product belongs.
         * @param {string} [sectorAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [sectorGt] Filter greater than the value.
         * @param {string} [sectorGte] Filter greater than or equal to the value.
         * @param {string} [sectorLt] Filter less than the value.
         * @param {string} [sectorLte] Filter less than or equal to the value.
         * @param {string} [subSector] The sub-sector to which the product belongs.
         * @param {string} [subSectorAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [subSectorGt] Filter greater than the value.
         * @param {string} [subSectorGte] Filter greater than or equal to the value.
         * @param {string} [subSectorLt] Filter less than the value.
         * @param {string} [subSectorLte] Filter less than or equal to the value.
         * @param {string} [assetClass] The asset class to which the product belongs.
         * @param {string} [assetClassAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [assetClassGt] Filter greater than the value.
         * @param {string} [assetClassGte] Filter greater than or equal to the value.
         * @param {string} [assetClassLt] Filter less than the value.
         * @param {string} [assetClassLte] Filter less than or equal to the value.
         * @param {string} [assetSubClass] The asset sub-class to which the product belongs.
         * @param {string} [assetSubClassAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [assetSubClassGt] Filter greater than the value.
         * @param {string} [assetSubClassGte] Filter greater than or equal to the value.
         * @param {string} [assetSubClassLt] Filter less than the value.
         * @param {string} [assetSubClassLte] Filter less than or equal to the value.
         * @param {string} [type] The type of product, one of \&#39;single\&#39; or \&#39;combo\&#39;.
         * @param {string} [typeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [typeGt] Filter greater than the value.
         * @param {string} [typeGte] Filter greater than or equal to the value.
         * @param {string} [typeLt] Filter less than the value.
         * @param {string} [typeLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesVXProductsNew: async (name?: string, nameAnyOf?: string, nameGt?: string, nameGte?: string, nameLt?: string, nameLte?: string, productCode?: string, productCodeAnyOf?: string, productCodeGt?: string, productCodeGte?: string, productCodeLt?: string, productCodeLte?: string, date?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, sector?: string, sectorAnyOf?: string, sectorGt?: string, sectorGte?: string, sectorLt?: string, sectorLte?: string, subSector?: string, subSectorAnyOf?: string, subSectorGt?: string, subSectorGte?: string, subSectorLt?: string, subSectorLte?: string, assetClass?: string, assetClassAnyOf?: string, assetClassGt?: string, assetClassGte?: string, assetClassLt?: string, assetClassLte?: string, assetSubClass?: string, assetSubClassAnyOf?: string, assetSubClassGt?: string, assetSubClassGte?: string, assetSubClassLt?: string, assetSubClassLte?: string, type?: string, typeAnyOf?: string, typeGt?: string, typeGte?: string, typeLt?: string, typeLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/futures/vX/products-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameAnyOf !== undefined) {
                localVarQueryParameter['name.any_of'] = nameAnyOf;
            }

            if (nameGt !== undefined) {
                localVarQueryParameter['name.gt'] = nameGt;
            }

            if (nameGte !== undefined) {
                localVarQueryParameter['name.gte'] = nameGte;
            }

            if (nameLt !== undefined) {
                localVarQueryParameter['name.lt'] = nameLt;
            }

            if (nameLte !== undefined) {
                localVarQueryParameter['name.lte'] = nameLte;
            }

            if (productCode !== undefined) {
                localVarQueryParameter['product_code'] = productCode;
            }

            if (productCodeAnyOf !== undefined) {
                localVarQueryParameter['product_code.any_of'] = productCodeAnyOf;
            }

            if (productCodeGt !== undefined) {
                localVarQueryParameter['product_code.gt'] = productCodeGt;
            }

            if (productCodeGte !== undefined) {
                localVarQueryParameter['product_code.gte'] = productCodeGte;
            }

            if (productCodeLt !== undefined) {
                localVarQueryParameter['product_code.lt'] = productCodeLt;
            }

            if (productCodeLte !== undefined) {
                localVarQueryParameter['product_code.lte'] = productCodeLte;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (sector !== undefined) {
                localVarQueryParameter['sector'] = sector;
            }

            if (sectorAnyOf !== undefined) {
                localVarQueryParameter['sector.any_of'] = sectorAnyOf;
            }

            if (sectorGt !== undefined) {
                localVarQueryParameter['sector.gt'] = sectorGt;
            }

            if (sectorGte !== undefined) {
                localVarQueryParameter['sector.gte'] = sectorGte;
            }

            if (sectorLt !== undefined) {
                localVarQueryParameter['sector.lt'] = sectorLt;
            }

            if (sectorLte !== undefined) {
                localVarQueryParameter['sector.lte'] = sectorLte;
            }

            if (subSector !== undefined) {
                localVarQueryParameter['sub_sector'] = subSector;
            }

            if (subSectorAnyOf !== undefined) {
                localVarQueryParameter['sub_sector.any_of'] = subSectorAnyOf;
            }

            if (subSectorGt !== undefined) {
                localVarQueryParameter['sub_sector.gt'] = subSectorGt;
            }

            if (subSectorGte !== undefined) {
                localVarQueryParameter['sub_sector.gte'] = subSectorGte;
            }

            if (subSectorLt !== undefined) {
                localVarQueryParameter['sub_sector.lt'] = subSectorLt;
            }

            if (subSectorLte !== undefined) {
                localVarQueryParameter['sub_sector.lte'] = subSectorLte;
            }

            if (assetClass !== undefined) {
                localVarQueryParameter['asset_class'] = assetClass;
            }

            if (assetClassAnyOf !== undefined) {
                localVarQueryParameter['asset_class.any_of'] = assetClassAnyOf;
            }

            if (assetClassGt !== undefined) {
                localVarQueryParameter['asset_class.gt'] = assetClassGt;
            }

            if (assetClassGte !== undefined) {
                localVarQueryParameter['asset_class.gte'] = assetClassGte;
            }

            if (assetClassLt !== undefined) {
                localVarQueryParameter['asset_class.lt'] = assetClassLt;
            }

            if (assetClassLte !== undefined) {
                localVarQueryParameter['asset_class.lte'] = assetClassLte;
            }

            if (assetSubClass !== undefined) {
                localVarQueryParameter['asset_sub_class'] = assetSubClass;
            }

            if (assetSubClassAnyOf !== undefined) {
                localVarQueryParameter['asset_sub_class.any_of'] = assetSubClassAnyOf;
            }

            if (assetSubClassGt !== undefined) {
                localVarQueryParameter['asset_sub_class.gt'] = assetSubClassGt;
            }

            if (assetSubClassGte !== undefined) {
                localVarQueryParameter['asset_sub_class.gte'] = assetSubClassGte;
            }

            if (assetSubClassLt !== undefined) {
                localVarQueryParameter['asset_sub_class.lt'] = assetSubClassLt;
            }

            if (assetSubClassLte !== undefined) {
                localVarQueryParameter['asset_sub_class.lte'] = assetSubClassLte;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (typeAnyOf !== undefined) {
                localVarQueryParameter['type.any_of'] = typeAnyOf;
            }

            if (typeGt !== undefined) {
                localVarQueryParameter['type.gt'] = typeGt;
            }

            if (typeGte !== undefined) {
                localVarQueryParameter['type.gte'] = typeGte;
            }

            if (typeLt !== undefined) {
                localVarQueryParameter['type.lt'] = typeLt;
            }

            if (typeLte !== undefined) {
                localVarQueryParameter['type.lte'] = typeLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a snapshot of the most recent futures contract data.
         * @summary futures_snapshot_v1 API
         * @param {string} [productCode] The code for the contracts\&#39; underlying product.
         * @param {string} [productCodeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [productCodeGt] Filter greater than the value.
         * @param {string} [productCodeGte] Filter greater than or equal to the value.
         * @param {string} [productCodeLt] Filter less than the value.
         * @param {string} [productCodeLte] Filter less than or equal to the value.
         * @param {string} [ticker] The futures contract identifier, including the base symbol and contract expiration (e.g., ESZ24 for the December 2024 S&amp;P 500 E-mini contract).
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesVXSnapshot: async (productCode?: string, productCodeAnyOf?: string, productCodeGt?: string, productCodeGte?: string, productCodeLt?: string, productCodeLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/futures/vX/snapshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (productCode !== undefined) {
                localVarQueryParameter['product_code'] = productCode;
            }

            if (productCodeAnyOf !== undefined) {
                localVarQueryParameter['product_code.any_of'] = productCodeAnyOf;
            }

            if (productCodeGt !== undefined) {
                localVarQueryParameter['product_code.gt'] = productCodeGt;
            }

            if (productCodeGte !== undefined) {
                localVarQueryParameter['product_code.gte'] = productCodeGte;
            }

            if (productCodeLt !== undefined) {
                localVarQueryParameter['product_code.lt'] = productCodeLt;
            }

            if (productCodeLte !== undefined) {
                localVarQueryParameter['product_code.lte'] = productCodeLte;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedCryptoAggregates: async (date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getGroupedCryptoAggregates', 'date', date)
            const localVarPath = `/v2/aggs/grouped/locale/global/market/crypto/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedForexAggregates: async (date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getGroupedForexAggregates', 'date', date)
            const localVarPath = `/v2/aggs/grouped/locale/global/market/fx/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedStocksAggregates: async (date: string, adjusted?: boolean, includeOtc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getGroupedStocksAggregates', 'date', date)
            const localVarPath = `/v2/aggs/grouped/locale/us/market/stocks/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (includeOtc !== undefined) {
                localVarQueryParameter['include_otc'] = includeOtc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for an index over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetIndicesAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesAggregates: async (indicesTicker: string, multiplier: number, timespan: GetIndicesAggregatesTimespanEnum, from: string, to: string, sort?: GetIndicesAggregatesSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('getIndicesAggregates', 'indicesTicker', indicesTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('getIndicesAggregates', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('getIndicesAggregates', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getIndicesAggregates', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getIndicesAggregates', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{indicesTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} indicesTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetIndicesEMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesEMA: async (indicesTicker: string, timestamp?: string, timespan?: GetIndicesEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('getIndicesEMA', 'indicesTicker', indicesTicker)
            const localVarPath = `/v1/indicators/ema/{indicesTicker}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} indicesTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetIndicesMACDSeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close values to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesMACD: async (indicesTicker: string, timestamp?: string, timespan?: GetIndicesMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetIndicesMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('getIndicesMACD', 'indicesTicker', indicesTicker)
            const localVarPath = `/v1/indicators/macd/{indicesTicker}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the open, close and afterhours values of a index symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesOpenClose: async (indicesTicker: string, date: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('getIndicesOpenClose', 'indicesTicker', indicesTicker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getIndicesOpenClose', 'date', date)
            const localVarPath = `/v1/open-close/{indicesTicker}/{date}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} indicesTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetIndicesRSISeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close values to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesRSI: async (indicesTicker: string, timestamp?: string, timespan?: GetIndicesRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('getIndicesRSI', 'indicesTicker', indicesTicker)
            const localVarPath = `/v1/indicators/rsi/{indicesTicker}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} indicesTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetIndicesSMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesSMA: async (indicesTicker: string, timestamp?: string, timespan?: GetIndicesSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('getIndicesSMA', 'indicesTicker', indicesTicker)
            const localVarPath = `/v1/indicators/sma/{indicesTicker}`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Snapshot of indices data for said tickers
         * @summary Indices Snapshot
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {GetIndicesSnapshotOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetIndicesSnapshotSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesSnapshot: async (tickerAnyOf?: string, ticker?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: GetIndicesSnapshotOrderEnum, limit?: number, sort?: GetIndicesSnapshotSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/snapshot/indices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the last trade tick for a cryptocurrency pair.
         * @summary Last Trade for a Crypto Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastCryptoTrade: async (from: string, to: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getLastCryptoTrade', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getLastCryptoTrade', 'to', to)
            const localVarPath = `/v1/last/crypto/{from}/{to}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the last quote tick for a forex currency pair.
         * @summary Last Quote for a Currency Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastCurrencyQuote: async (from: string, to: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getLastCurrencyQuote', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getLastCurrencyQuote', 'to', to)
            const localVarPath = `/v1/last_quote/currencies/{from}/{to}`
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most recent trade for a given options contract.
         * @summary Last Trade
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastOptionsTrade: async (optionsTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getLastOptionsTrade', 'optionsTicker', optionsTicker)
            const localVarPath = `/v2/last/trade/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most recent NBBO (Quote) tick for a given stock.
         * @summary Last Quote
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastStocksQuote: async (stocksTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('getLastStocksQuote', 'stocksTicker', stocksTicker)
            const localVarPath = `/v2/last/nbbo/{stocksTicker}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most recent trade for a given stock.
         * @summary Last Trade
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastStocksTrade: async (stocksTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('getLastStocksTrade', 'stocksTicker', stocksTicker)
            const localVarPath = `/v2/last/trade/{stocksTicker}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get upcoming market holidays and their open/close times.
         * @summary Market Holidays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketHolidays: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketstatus/upcoming`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current trading status of the exchanges and overall financial markets.
         * @summary Market Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketstatus/now`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the snapshot of an option contract for a stock equity.
         * @summary Option Contract
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {string} optionContract The option contract identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionContract: async (underlyingAsset: string, optionContract: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'underlyingAsset' is not null or undefined
            assertParamExists('getOptionContract', 'underlyingAsset', underlyingAsset)
            // verify required parameter 'optionContract' is not null or undefined
            assertParamExists('getOptionContract', 'optionContract', optionContract)
            const localVarPath = `/v3/snapshot/options/{underlyingAsset}/{optionContract}`
                .replace(`{${"underlyingAsset"}}`, encodeURIComponent(String(underlyingAsset)))
                .replace(`{${"optionContract"}}`, encodeURIComponent(String(optionContract)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for an option contract over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetOptionsAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetOptionsAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsAggregates: async (optionsTicker: string, multiplier: number, timespan: GetOptionsAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetOptionsAggregatesSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsAggregates', 'optionsTicker', optionsTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('getOptionsAggregates', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('getOptionsAggregates', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getOptionsAggregates', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getOptionsAggregates', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{optionsTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the snapshot of all options contracts for an underlying ticker.
         * @summary Options Chain
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {GetOptionsChainContractTypeEnum} [contractType] Query by the type of contract.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {GetOptionsChainOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetOptionsChainSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsChain: async (underlyingAsset: string, strikePrice?: number, expirationDate?: string, contractType?: GetOptionsChainContractTypeEnum, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, order?: GetOptionsChainOrderEnum, limit?: number, sort?: GetOptionsChainSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'underlyingAsset' is not null or undefined
            assertParamExists('getOptionsChain', 'underlyingAsset', underlyingAsset)
            const localVarPath = `/v3/snapshot/options/{underlyingAsset}`
                .replace(`{${"underlyingAsset"}}`, encodeURIComponent(String(underlyingAsset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (strikePrice !== undefined) {
                localVarQueryParameter['strike_price'] = strikePrice;
            }

            if (expirationDate !== undefined) {
                localVarQueryParameter['expiration_date'] = expirationDate;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contract_type'] = contractType;
            }

            if (strikePriceGte !== undefined) {
                localVarQueryParameter['strike_price.gte'] = strikePriceGte;
            }

            if (strikePriceGt !== undefined) {
                localVarQueryParameter['strike_price.gt'] = strikePriceGt;
            }

            if (strikePriceLte !== undefined) {
                localVarQueryParameter['strike_price.lte'] = strikePriceLte;
            }

            if (strikePriceLt !== undefined) {
                localVarQueryParameter['strike_price.lt'] = strikePriceLt;
            }

            if (expirationDateGte !== undefined) {
                localVarQueryParameter['expiration_date.gte'] = expirationDateGte;
            }

            if (expirationDateGt !== undefined) {
                localVarQueryParameter['expiration_date.gt'] = expirationDateGt;
            }

            if (expirationDateLte !== undefined) {
                localVarQueryParameter['expiration_date.lte'] = expirationDateLte;
            }

            if (expirationDateLt !== undefined) {
                localVarQueryParameter['expiration_date.lt'] = expirationDateLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an options contract
         * @summary Options Contract
         * @param {string} optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://massive.com/blog/how-to-read-a-stock-options-ticker/).
         * @param {string} [asOf] Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsContract: async (optionsTicker: string, asOf?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsContract', 'optionsTicker', optionsTicker)
            const localVarPath = `/v3/reference/options/contracts/{options_ticker}`
                .replace(`{${"options_ticker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (asOf !== undefined) {
                localVarQueryParameter['as_of'] = asOf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} optionsTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetOptionsEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsEMA: async (optionsTicker: string, timestamp?: string, timespan?: GetOptionsEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsEMA', 'optionsTicker', optionsTicker)
            const localVarPath = `/v1/indicators/ema/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} optionsTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetOptionsMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsMACD: async (optionsTicker: string, timestamp?: string, timespan?: GetOptionsMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetOptionsMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsMACD', 'optionsTicker', optionsTicker)
            const localVarPath = `/v1/indicators/macd/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the open, close and afterhours prices of an options contract on a certain date. 
         * @summary Daily Open/Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsOpenClose: async (optionsTicker: string, date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsOpenClose', 'optionsTicker', optionsTicker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getOptionsOpenClose', 'date', date)
            const localVarPath = `/v1/open-close/{optionsTicker}/{date}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get quotes for an options ticker symbol in a given time range.
         * @summary Quotes
         * @param {string} optionsTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetOptionsQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetOptionsQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsQuotes: async (optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetOptionsQuotesOrderEnum, limit?: number, sort?: GetOptionsQuotesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsQuotes', 'optionsTicker', optionsTicker)
            const localVarPath = `/v3/quotes/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} optionsTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetOptionsRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsRSI: async (optionsTicker: string, timestamp?: string, timespan?: GetOptionsRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsRSI', 'optionsTicker', optionsTicker)
            const localVarPath = `/v1/indicators/rsi/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} optionsTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetOptionsSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsSMA: async (optionsTicker: string, timestamp?: string, timespan?: GetOptionsSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsSMA', 'optionsTicker', optionsTicker)
            const localVarPath = `/v1/indicators/sma/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for an options ticker symbol in a given time range.
         * @summary Trades
         * @param {string} optionsTicker The options ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetOptionsTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetOptionsTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsTrades: async (optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetOptionsTradesOrderEnum, limit?: number, sort?: GetOptionsTradesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getOptionsTrades', 'optionsTicker', optionsTicker)
            const localVarPath = `/v3/trades/{optionsTicker}`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * US options exchanges and trading venues including traditional options exchanges (CBOE, ISE, etc.), Securities Information Processors (SIP), and other options market infrastructure for derivatives trading.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsV1Exchanges: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/options/v1/exchanges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
         * @summary Previous Close
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousCryptoAggregates: async (cryptoTicker: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoTicker' is not null or undefined
            assertParamExists('getPreviousCryptoAggregates', 'cryptoTicker', cryptoTicker)
            const localVarPath = `/v2/aggs/ticker/{cryptoTicker}/prev`
                .replace(`{${"cryptoTicker"}}`, encodeURIComponent(String(cryptoTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified forex pair. 
         * @summary Previous Close
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousForexAggregates: async (forexTicker: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forexTicker' is not null or undefined
            assertParamExists('getPreviousForexAggregates', 'forexTicker', forexTicker)
            const localVarPath = `/v2/aggs/ticker/{forexTicker}/prev`
                .replace(`{${"forexTicker"}}`, encodeURIComponent(String(forexTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified index. 
         * @summary Previous Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousIndicesAggregates: async (indicesTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indicesTicker' is not null or undefined
            assertParamExists('getPreviousIndicesAggregates', 'indicesTicker', indicesTicker)
            const localVarPath = `/v2/aggs/ticker/{indicesTicker}/prev`
                .replace(`{${"indicesTicker"}}`, encodeURIComponent(String(indicesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified option contract. 
         * @summary Previous Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousOptionsAggregates: async (optionsTicker: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'optionsTicker' is not null or undefined
            assertParamExists('getPreviousOptionsAggregates', 'optionsTicker', optionsTicker)
            const localVarPath = `/v2/aggs/ticker/{optionsTicker}/prev`
                .replace(`{${"optionsTicker"}}`, encodeURIComponent(String(optionsTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified stock ticker. 
         * @summary Previous Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousStocksAggregates: async (stocksTicker: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('getPreviousStocksAggregates', 'stocksTicker', stocksTicker)
            const localVarPath = `/v2/aggs/ticker/{stocksTicker}/prev`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of tickers related to the queried ticker based on News and Returns data.
         * @summary Related Companies
         * @param {string} ticker The ticker symbol to search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedCompanies: async (ticker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getRelatedCompanies', 'ticker', ticker)
            const localVarPath = `/v1/related-companies/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
         * @summary Summaries
         * @param {string} [tickerAnyOf] Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://massive.com/docs/rest/stocks/tickers/all-tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotSummary: async (tickerAnyOf?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/summaries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get snapshots for assets of all types
         * @summary Universal Snapshot
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {GetSnapshotsTypeEnum} [type] Query by the type of asset.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. 
         * @param {GetSnapshotsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetSnapshotsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshots: async (ticker?: string, type?: GetSnapshotsTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, tickerAnyOf?: string, order?: GetSnapshotsOrderEnum, limit?: number, sort?: GetSnapshotsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/snapshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregate bars for a stock over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetStocksAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetStocksAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksAggregates: async (stocksTicker: string, multiplier: number, timespan: GetStocksAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetStocksAggregatesSortEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('getStocksAggregates', 'stocksTicker', stocksTicker)
            // verify required parameter 'multiplier' is not null or undefined
            assertParamExists('getStocksAggregates', 'multiplier', multiplier)
            // verify required parameter 'timespan' is not null or undefined
            assertParamExists('getStocksAggregates', 'timespan', timespan)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getStocksAggregates', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getStocksAggregates', 'to', to)
            const localVarPath = `/v2/aggs/ticker/{stocksTicker}/range/{multiplier}/{timespan}/{from}/{to}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)))
                .replace(`{${"multiplier"}}`, encodeURIComponent(String(multiplier)))
                .replace(`{${"timespan"}}`, encodeURIComponent(String(timespan)))
                .replace(`{${"from"}}`, encodeURIComponent(String(from)))
                .replace(`{${"to"}}`, encodeURIComponent(String(to)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetStocksEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksEMA: async (stockTicker: string, timestamp?: string, timespan?: GetStocksEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('getStocksEMA', 'stockTicker', stockTicker)
            const localVarPath = `/v1/indicators/ema/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A comprehensive financial dataset containing quarterly and annual balance sheet data for public companies. Includes detailed asset, liability, and equity positions representing the company\'s financial position at specific points in time. Balance sheet data represents point-in-time snapshots rather than cumulative flows, showing what the company owns, owes, and shareholders\' equity as of each period end date.
         * @param {string} [cik] The company\&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a company\&#39;s CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
         * @param {string} [cikAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [cikGt] Filter greater than the value.
         * @param {string} [cikGte] Filter greater than or equal to the value.
         * @param {string} [cikLt] Filter less than the value.
         * @param {string} [cikLte] Filter less than or equal to the value.
         * @param {string} [tickers] Filter for arrays that contain the value.
         * @param {string} [tickersAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickersAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [periodEnd] The last date of the reporting period, representing the specific point in time when the balance sheet snapshot was taken. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDate] The date when the financial statement was filed with the SEC. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {number} [fiscalYear] The fiscal year for the reporting period. Value must be a floating point number.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalQuarter] The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number.
         * @param {number} [fiscalQuarterGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {string} [timeframe] The reporting period type. Possible values include: quarterly, annual.
         * @param {string} [timeframeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [timeframeGt] Filter greater than the value.
         * @param {string} [timeframeGte] Filter greater than or equal to the value.
         * @param {string} [timeframeLt] Filter less than the value.
         * @param {string} [timeframeLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;period_end\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksFinancialsV1BalanceSheets: async (cik?: string, cikAnyOf?: string, cikGt?: string, cikGte?: string, cikLt?: string, cikLte?: string, tickers?: string, tickersAllOf?: string, tickersAnyOf?: string, periodEnd?: string, periodEndGt?: string, periodEndGte?: string, periodEndLt?: string, periodEndLte?: string, filingDate?: string, filingDateGt?: string, filingDateGte?: string, filingDateLt?: string, filingDateLte?: string, fiscalYear?: number, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalQuarter?: number, fiscalQuarterGt?: number, fiscalQuarterGte?: number, fiscalQuarterLt?: number, fiscalQuarterLte?: number, timeframe?: string, timeframeAnyOf?: string, timeframeGt?: string, timeframeGte?: string, timeframeLt?: string, timeframeLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stocks/financials/v1/balance-sheets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (cikAnyOf !== undefined) {
                localVarQueryParameter['cik.any_of'] = cikAnyOf;
            }

            if (cikGt !== undefined) {
                localVarQueryParameter['cik.gt'] = cikGt;
            }

            if (cikGte !== undefined) {
                localVarQueryParameter['cik.gte'] = cikGte;
            }

            if (cikLt !== undefined) {
                localVarQueryParameter['cik.lt'] = cikLt;
            }

            if (cikLte !== undefined) {
                localVarQueryParameter['cik.lte'] = cikLte;
            }

            if (tickers !== undefined) {
                localVarQueryParameter['tickers'] = tickers;
            }

            if (tickersAllOf !== undefined) {
                localVarQueryParameter['tickers.all_of'] = tickersAllOf;
            }

            if (tickersAnyOf !== undefined) {
                localVarQueryParameter['tickers.any_of'] = tickersAnyOf;
            }

            if (periodEnd !== undefined) {
                localVarQueryParameter['period_end'] = periodEnd;
            }

            if (periodEndGt !== undefined) {
                localVarQueryParameter['period_end.gt'] = periodEndGt;
            }

            if (periodEndGte !== undefined) {
                localVarQueryParameter['period_end.gte'] = periodEndGte;
            }

            if (periodEndLt !== undefined) {
                localVarQueryParameter['period_end.lt'] = periodEndLt;
            }

            if (periodEndLte !== undefined) {
                localVarQueryParameter['period_end.lte'] = periodEndLte;
            }

            if (filingDate !== undefined) {
                localVarQueryParameter['filing_date'] = filingDate;
            }

            if (filingDateGt !== undefined) {
                localVarQueryParameter['filing_date.gt'] = filingDateGt;
            }

            if (filingDateGte !== undefined) {
                localVarQueryParameter['filing_date.gte'] = filingDateGte;
            }

            if (filingDateLt !== undefined) {
                localVarQueryParameter['filing_date.lt'] = filingDateLt;
            }

            if (filingDateLte !== undefined) {
                localVarQueryParameter['filing_date.lte'] = filingDateLte;
            }

            if (fiscalYear !== undefined) {
                localVarQueryParameter['fiscal_year'] = fiscalYear;
            }

            if (fiscalYearGt !== undefined) {
                localVarQueryParameter['fiscal_year.gt'] = fiscalYearGt;
            }

            if (fiscalYearGte !== undefined) {
                localVarQueryParameter['fiscal_year.gte'] = fiscalYearGte;
            }

            if (fiscalYearLt !== undefined) {
                localVarQueryParameter['fiscal_year.lt'] = fiscalYearLt;
            }

            if (fiscalYearLte !== undefined) {
                localVarQueryParameter['fiscal_year.lte'] = fiscalYearLte;
            }

            if (fiscalQuarter !== undefined) {
                localVarQueryParameter['fiscal_quarter'] = fiscalQuarter;
            }

            if (fiscalQuarterGt !== undefined) {
                localVarQueryParameter['fiscal_quarter.gt'] = fiscalQuarterGt;
            }

            if (fiscalQuarterGte !== undefined) {
                localVarQueryParameter['fiscal_quarter.gte'] = fiscalQuarterGte;
            }

            if (fiscalQuarterLt !== undefined) {
                localVarQueryParameter['fiscal_quarter.lt'] = fiscalQuarterLt;
            }

            if (fiscalQuarterLte !== undefined) {
                localVarQueryParameter['fiscal_quarter.lte'] = fiscalQuarterLte;
            }

            if (timeframe !== undefined) {
                localVarQueryParameter['timeframe'] = timeframe;
            }

            if (timeframeAnyOf !== undefined) {
                localVarQueryParameter['timeframe.any_of'] = timeframeAnyOf;
            }

            if (timeframeGt !== undefined) {
                localVarQueryParameter['timeframe.gt'] = timeframeGt;
            }

            if (timeframeGte !== undefined) {
                localVarQueryParameter['timeframe.gte'] = timeframeGte;
            }

            if (timeframeLt !== undefined) {
                localVarQueryParameter['timeframe.lt'] = timeframeLt;
            }

            if (timeframeLte !== undefined) {
                localVarQueryParameter['timeframe.lte'] = timeframeLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A comprehensive financial dataset containing quarterly, annual, and trailing twelve-month cash flow statement data for public companies. Includes detailed operating, investing, and financing cash flows with proper TTM calculations that sum all cash flow components over four quarters. TTM records are validated to ensure exactly four distinct quarters spanning 250-400 days for accurate trailing twelve-month cash flow analysis.
         * @param {string} [cik] The company\&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
         * @param {string} [cikAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [cikGt] Filter greater than the value.
         * @param {string} [cikGte] Filter greater than or equal to the value.
         * @param {string} [cikLt] Filter less than the value.
         * @param {string} [cikLte] Filter less than or equal to the value.
         * @param {string} [periodEnd] The last date of the reporting period (formatted as YYYY-MM-DD). Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDate] The date when the financial statement was filed with the SEC. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [tickers] Filter for arrays that contain the value.
         * @param {string} [tickersAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickersAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {number} [fiscalYear] The fiscal year for the reporting period. Value must be a floating point number.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalQuarter] The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number.
         * @param {number} [fiscalQuarterGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {string} [timeframe] The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months.
         * @param {string} [timeframeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [timeframeGt] Filter greater than the value.
         * @param {string} [timeframeGte] Filter greater than or equal to the value.
         * @param {string} [timeframeLt] Filter less than the value.
         * @param {string} [timeframeLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;period_end\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksFinancialsV1CashFlowStatements: async (cik?: string, cikAnyOf?: string, cikGt?: string, cikGte?: string, cikLt?: string, cikLte?: string, periodEnd?: string, periodEndGt?: string, periodEndGte?: string, periodEndLt?: string, periodEndLte?: string, filingDate?: string, filingDateGt?: string, filingDateGte?: string, filingDateLt?: string, filingDateLte?: string, tickers?: string, tickersAllOf?: string, tickersAnyOf?: string, fiscalYear?: number, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalQuarter?: number, fiscalQuarterGt?: number, fiscalQuarterGte?: number, fiscalQuarterLt?: number, fiscalQuarterLte?: number, timeframe?: string, timeframeAnyOf?: string, timeframeGt?: string, timeframeGte?: string, timeframeLt?: string, timeframeLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stocks/financials/v1/cash-flow-statements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (cikAnyOf !== undefined) {
                localVarQueryParameter['cik.any_of'] = cikAnyOf;
            }

            if (cikGt !== undefined) {
                localVarQueryParameter['cik.gt'] = cikGt;
            }

            if (cikGte !== undefined) {
                localVarQueryParameter['cik.gte'] = cikGte;
            }

            if (cikLt !== undefined) {
                localVarQueryParameter['cik.lt'] = cikLt;
            }

            if (cikLte !== undefined) {
                localVarQueryParameter['cik.lte'] = cikLte;
            }

            if (periodEnd !== undefined) {
                localVarQueryParameter['period_end'] = periodEnd;
            }

            if (periodEndGt !== undefined) {
                localVarQueryParameter['period_end.gt'] = periodEndGt;
            }

            if (periodEndGte !== undefined) {
                localVarQueryParameter['period_end.gte'] = periodEndGte;
            }

            if (periodEndLt !== undefined) {
                localVarQueryParameter['period_end.lt'] = periodEndLt;
            }

            if (periodEndLte !== undefined) {
                localVarQueryParameter['period_end.lte'] = periodEndLte;
            }

            if (filingDate !== undefined) {
                localVarQueryParameter['filing_date'] = filingDate;
            }

            if (filingDateGt !== undefined) {
                localVarQueryParameter['filing_date.gt'] = filingDateGt;
            }

            if (filingDateGte !== undefined) {
                localVarQueryParameter['filing_date.gte'] = filingDateGte;
            }

            if (filingDateLt !== undefined) {
                localVarQueryParameter['filing_date.lt'] = filingDateLt;
            }

            if (filingDateLte !== undefined) {
                localVarQueryParameter['filing_date.lte'] = filingDateLte;
            }

            if (tickers !== undefined) {
                localVarQueryParameter['tickers'] = tickers;
            }

            if (tickersAllOf !== undefined) {
                localVarQueryParameter['tickers.all_of'] = tickersAllOf;
            }

            if (tickersAnyOf !== undefined) {
                localVarQueryParameter['tickers.any_of'] = tickersAnyOf;
            }

            if (fiscalYear !== undefined) {
                localVarQueryParameter['fiscal_year'] = fiscalYear;
            }

            if (fiscalYearGt !== undefined) {
                localVarQueryParameter['fiscal_year.gt'] = fiscalYearGt;
            }

            if (fiscalYearGte !== undefined) {
                localVarQueryParameter['fiscal_year.gte'] = fiscalYearGte;
            }

            if (fiscalYearLt !== undefined) {
                localVarQueryParameter['fiscal_year.lt'] = fiscalYearLt;
            }

            if (fiscalYearLte !== undefined) {
                localVarQueryParameter['fiscal_year.lte'] = fiscalYearLte;
            }

            if (fiscalQuarter !== undefined) {
                localVarQueryParameter['fiscal_quarter'] = fiscalQuarter;
            }

            if (fiscalQuarterGt !== undefined) {
                localVarQueryParameter['fiscal_quarter.gt'] = fiscalQuarterGt;
            }

            if (fiscalQuarterGte !== undefined) {
                localVarQueryParameter['fiscal_quarter.gte'] = fiscalQuarterGte;
            }

            if (fiscalQuarterLt !== undefined) {
                localVarQueryParameter['fiscal_quarter.lt'] = fiscalQuarterLt;
            }

            if (fiscalQuarterLte !== undefined) {
                localVarQueryParameter['fiscal_quarter.lte'] = fiscalQuarterLte;
            }

            if (timeframe !== undefined) {
                localVarQueryParameter['timeframe'] = timeframe;
            }

            if (timeframeAnyOf !== undefined) {
                localVarQueryParameter['timeframe.any_of'] = timeframeAnyOf;
            }

            if (timeframeGt !== undefined) {
                localVarQueryParameter['timeframe.gt'] = timeframeGt;
            }

            if (timeframeGte !== undefined) {
                localVarQueryParameter['timeframe.gte'] = timeframeGte;
            }

            if (timeframeLt !== undefined) {
                localVarQueryParameter['timeframe.lt'] = timeframeLt;
            }

            if (timeframeLte !== undefined) {
                localVarQueryParameter['timeframe.lte'] = timeframeLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A comprehensive database of income statement financial data for public companies, including key metrics such as revenue, expenses, and net income for various reporting periods.
         * @param {string} [cik] The company\&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
         * @param {string} [cikAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [cikGt] Filter greater than the value.
         * @param {string} [cikGte] Filter greater than or equal to the value.
         * @param {string} [cikLt] Filter less than the value.
         * @param {string} [cikLte] Filter less than or equal to the value.
         * @param {string} [tickers] Filter for arrays that contain the value.
         * @param {string} [tickersAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickersAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [periodEnd] The last date of the reporting period (formatted as YYYY-MM-DD). Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDate] The date when the financial statement was filed with the SEC. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {number} [fiscalYear] The fiscal year for the reporting period. Value must be a floating point number.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalQuarter] The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number.
         * @param {number} [fiscalQuarterGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {string} [timeframe] The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months.
         * @param {string} [timeframeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [timeframeGt] Filter greater than the value.
         * @param {string} [timeframeGte] Filter greater than or equal to the value.
         * @param {string} [timeframeLt] Filter less than the value.
         * @param {string} [timeframeLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;period_end\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksFinancialsV1IncomeStatements: async (cik?: string, cikAnyOf?: string, cikGt?: string, cikGte?: string, cikLt?: string, cikLte?: string, tickers?: string, tickersAllOf?: string, tickersAnyOf?: string, periodEnd?: string, periodEndGt?: string, periodEndGte?: string, periodEndLt?: string, periodEndLte?: string, filingDate?: string, filingDateGt?: string, filingDateGte?: string, filingDateLt?: string, filingDateLte?: string, fiscalYear?: number, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalQuarter?: number, fiscalQuarterGt?: number, fiscalQuarterGte?: number, fiscalQuarterLt?: number, fiscalQuarterLte?: number, timeframe?: string, timeframeAnyOf?: string, timeframeGt?: string, timeframeGte?: string, timeframeLt?: string, timeframeLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stocks/financials/v1/income-statements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (cikAnyOf !== undefined) {
                localVarQueryParameter['cik.any_of'] = cikAnyOf;
            }

            if (cikGt !== undefined) {
                localVarQueryParameter['cik.gt'] = cikGt;
            }

            if (cikGte !== undefined) {
                localVarQueryParameter['cik.gte'] = cikGte;
            }

            if (cikLt !== undefined) {
                localVarQueryParameter['cik.lt'] = cikLt;
            }

            if (cikLte !== undefined) {
                localVarQueryParameter['cik.lte'] = cikLte;
            }

            if (tickers !== undefined) {
                localVarQueryParameter['tickers'] = tickers;
            }

            if (tickersAllOf !== undefined) {
                localVarQueryParameter['tickers.all_of'] = tickersAllOf;
            }

            if (tickersAnyOf !== undefined) {
                localVarQueryParameter['tickers.any_of'] = tickersAnyOf;
            }

            if (periodEnd !== undefined) {
                localVarQueryParameter['period_end'] = periodEnd;
            }

            if (periodEndGt !== undefined) {
                localVarQueryParameter['period_end.gt'] = periodEndGt;
            }

            if (periodEndGte !== undefined) {
                localVarQueryParameter['period_end.gte'] = periodEndGte;
            }

            if (periodEndLt !== undefined) {
                localVarQueryParameter['period_end.lt'] = periodEndLt;
            }

            if (periodEndLte !== undefined) {
                localVarQueryParameter['period_end.lte'] = periodEndLte;
            }

            if (filingDate !== undefined) {
                localVarQueryParameter['filing_date'] = filingDate;
            }

            if (filingDateGt !== undefined) {
                localVarQueryParameter['filing_date.gt'] = filingDateGt;
            }

            if (filingDateGte !== undefined) {
                localVarQueryParameter['filing_date.gte'] = filingDateGte;
            }

            if (filingDateLt !== undefined) {
                localVarQueryParameter['filing_date.lt'] = filingDateLt;
            }

            if (filingDateLte !== undefined) {
                localVarQueryParameter['filing_date.lte'] = filingDateLte;
            }

            if (fiscalYear !== undefined) {
                localVarQueryParameter['fiscal_year'] = fiscalYear;
            }

            if (fiscalYearGt !== undefined) {
                localVarQueryParameter['fiscal_year.gt'] = fiscalYearGt;
            }

            if (fiscalYearGte !== undefined) {
                localVarQueryParameter['fiscal_year.gte'] = fiscalYearGte;
            }

            if (fiscalYearLt !== undefined) {
                localVarQueryParameter['fiscal_year.lt'] = fiscalYearLt;
            }

            if (fiscalYearLte !== undefined) {
                localVarQueryParameter['fiscal_year.lte'] = fiscalYearLte;
            }

            if (fiscalQuarter !== undefined) {
                localVarQueryParameter['fiscal_quarter'] = fiscalQuarter;
            }

            if (fiscalQuarterGt !== undefined) {
                localVarQueryParameter['fiscal_quarter.gt'] = fiscalQuarterGt;
            }

            if (fiscalQuarterGte !== undefined) {
                localVarQueryParameter['fiscal_quarter.gte'] = fiscalQuarterGte;
            }

            if (fiscalQuarterLt !== undefined) {
                localVarQueryParameter['fiscal_quarter.lt'] = fiscalQuarterLt;
            }

            if (fiscalQuarterLte !== undefined) {
                localVarQueryParameter['fiscal_quarter.lte'] = fiscalQuarterLte;
            }

            if (timeframe !== undefined) {
                localVarQueryParameter['timeframe'] = timeframe;
            }

            if (timeframeAnyOf !== undefined) {
                localVarQueryParameter['timeframe.any_of'] = timeframeAnyOf;
            }

            if (timeframeGt !== undefined) {
                localVarQueryParameter['timeframe.gt'] = timeframeGt;
            }

            if (timeframeGte !== undefined) {
                localVarQueryParameter['timeframe.gte'] = timeframeGte;
            }

            if (timeframeLt !== undefined) {
                localVarQueryParameter['timeframe.lt'] = timeframeLt;
            }

            if (timeframeLte !== undefined) {
                localVarQueryParameter['timeframe.lte'] = timeframeLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A comprehensive financial ratios dataset providing key valuation, profitability, liquidity, and leverage metrics for public companies. Combines data from income statements, balance sheets, and cash flow statements with daily stock prices to calculate ratios on a daily basis. Uses trailing twelve months (TTM) data for income/cash flow metrics and quarterly data for balance sheet items. Fundamental data updates are applied starting from each filing\'s period end date. Market cap calculations use point-in-time shares outstanding for historical accuracy.
         * @param {string} [ticker] Stock ticker symbol for the company.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [cik] Central Index Key (CIK) number assigned by the SEC to identify the company.
         * @param {string} [cikAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [cikGt] Filter greater than the value.
         * @param {string} [cikGte] Filter greater than or equal to the value.
         * @param {string} [cikLt] Filter less than the value.
         * @param {string} [cikLte] Filter less than or equal to the value.
         * @param {number} [price] Stock price used in ratio calculations, typically the closing price for the given date. Value must be a floating point number.
         * @param {number} [priceGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [priceGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [priceLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [priceLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [averageVolume] Average trading volume over the last 30 trading days, providing context for liquidity. Value must be a floating point number.
         * @param {number} [averageVolumeGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [averageVolumeGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [averageVolumeLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [averageVolumeLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [marketCap] Market capitalization, calculated as stock price multiplied by total shares outstanding. Value must be a floating point number.
         * @param {number} [marketCapGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [marketCapGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [marketCapLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [marketCapLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [earningsPerShare] Earnings per share, calculated as net income available to common shareholders divided by weighted shares outstanding. Value must be a floating point number.
         * @param {number} [earningsPerShareGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [earningsPerShareGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [earningsPerShareLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [earningsPerShareLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToEarnings] Price-to-earnings ratio, calculated as stock price divided by earnings per share. Only calculated when earnings per share is positive. Value must be a floating point number.
         * @param {number} [priceToEarningsGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [priceToEarningsGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToEarningsLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [priceToEarningsLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToBook] Price-to-book ratio, calculated as stock price divided by book value per share, comparing market value to book value. Value must be a floating point number.
         * @param {number} [priceToBookGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [priceToBookGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToBookLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [priceToBookLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToSales] Price-to-sales ratio, calculated as stock price divided by revenue per share, measuring valuation relative to sales. Value must be a floating point number.
         * @param {number} [priceToSalesGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [priceToSalesGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToSalesLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [priceToSalesLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToCashFlow] Price-to-cash-flow ratio, calculated as stock price divided by operating cash flow per share. Only calculated when operating cash flow per share is positive. Value must be a floating point number.
         * @param {number} [priceToCashFlowGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [priceToCashFlowGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToCashFlowLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [priceToCashFlowLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToFreeCashFlow] Price-to-free-cash-flow ratio, calculated as stock price divided by free cash flow per share. Only calculated when free cash flow per share is positive. Value must be a floating point number.
         * @param {number} [priceToFreeCashFlowGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [priceToFreeCashFlowGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToFreeCashFlowLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [priceToFreeCashFlowLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [dividendYield] Dividend yield, calculated as annual dividends per share divided by stock price, measuring the income return on investment. Value must be a floating point number.
         * @param {number} [dividendYieldGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [dividendYieldGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [dividendYieldLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [dividendYieldLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [returnOnAssets] Return on assets ratio, calculated as net income divided by total assets, measuring how efficiently a company uses its assets to generate profit. Value must be a floating point number.
         * @param {number} [returnOnAssetsGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [returnOnAssetsGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [returnOnAssetsLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [returnOnAssetsLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [returnOnEquity] Return on equity ratio, calculated as net income divided by total shareholders\&#39; equity, measuring profitability relative to shareholders\&#39; equity. Value must be a floating point number.
         * @param {number} [returnOnEquityGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [returnOnEquityGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [returnOnEquityLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [returnOnEquityLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [debtToEquity] Debt-to-equity ratio, calculated as total debt (current debt plus long-term debt) divided by total shareholders\&#39; equity, measuring financial leverage. Value must be a floating point number.
         * @param {number} [debtToEquityGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [debtToEquityGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [debtToEquityLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [debtToEquityLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [current] Current ratio, calculated as total current assets divided by total current liabilities, measuring short-term liquidity. Value must be a floating point number.
         * @param {number} [currentGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [currentGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [currentLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [currentLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [quick] Quick ratio (acid-test ratio), calculated as (current assets minus inventories) divided by current liabilities, measuring immediate liquidity. Value must be a floating point number.
         * @param {number} [quickGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quickGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quickLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quickLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [cash] Cash ratio, calculated as cash and cash equivalents divided by current liabilities, measuring the most liquid form of liquidity coverage. Value must be a floating point number.
         * @param {number} [cashGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [cashGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [cashLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [cashLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [evToSales] Enterprise value to sales ratio, calculated as enterprise value divided by revenue, measuring company valuation relative to sales. Value must be a floating point number.
         * @param {number} [evToSalesGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [evToSalesGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [evToSalesLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [evToSalesLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [evToEbitda] Enterprise value to EBITDA ratio, calculated as enterprise value divided by EBITDA, measuring company valuation relative to earnings before interest, taxes, depreciation, and amortization. Value must be a floating point number.
         * @param {number} [evToEbitdaGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [evToEbitdaGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [evToEbitdaLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [evToEbitdaLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [enterpriseValue] Enterprise value, calculated as market capitalization plus total debt minus cash and cash equivalents, representing total company value. Value must be a floating point number.
         * @param {number} [enterpriseValueGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [enterpriseValueGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [enterpriseValueLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [enterpriseValueLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [freeCashFlow] Free cash flow, calculated as operating cash flow minus capital expenditures (purchase of property, plant, and equipment). Value must be a floating point number.
         * @param {number} [freeCashFlowGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [freeCashFlowGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [freeCashFlowLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [freeCashFlowLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksFinancialsV1Ratios: async (ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, cik?: string, cikAnyOf?: string, cikGt?: string, cikGte?: string, cikLt?: string, cikLte?: string, price?: number, priceGt?: number, priceGte?: number, priceLt?: number, priceLte?: number, averageVolume?: number, averageVolumeGt?: number, averageVolumeGte?: number, averageVolumeLt?: number, averageVolumeLte?: number, marketCap?: number, marketCapGt?: number, marketCapGte?: number, marketCapLt?: number, marketCapLte?: number, earningsPerShare?: number, earningsPerShareGt?: number, earningsPerShareGte?: number, earningsPerShareLt?: number, earningsPerShareLte?: number, priceToEarnings?: number, priceToEarningsGt?: number, priceToEarningsGte?: number, priceToEarningsLt?: number, priceToEarningsLte?: number, priceToBook?: number, priceToBookGt?: number, priceToBookGte?: number, priceToBookLt?: number, priceToBookLte?: number, priceToSales?: number, priceToSalesGt?: number, priceToSalesGte?: number, priceToSalesLt?: number, priceToSalesLte?: number, priceToCashFlow?: number, priceToCashFlowGt?: number, priceToCashFlowGte?: number, priceToCashFlowLt?: number, priceToCashFlowLte?: number, priceToFreeCashFlow?: number, priceToFreeCashFlowGt?: number, priceToFreeCashFlowGte?: number, priceToFreeCashFlowLt?: number, priceToFreeCashFlowLte?: number, dividendYield?: number, dividendYieldGt?: number, dividendYieldGte?: number, dividendYieldLt?: number, dividendYieldLte?: number, returnOnAssets?: number, returnOnAssetsGt?: number, returnOnAssetsGte?: number, returnOnAssetsLt?: number, returnOnAssetsLte?: number, returnOnEquity?: number, returnOnEquityGt?: number, returnOnEquityGte?: number, returnOnEquityLt?: number, returnOnEquityLte?: number, debtToEquity?: number, debtToEquityGt?: number, debtToEquityGte?: number, debtToEquityLt?: number, debtToEquityLte?: number, current?: number, currentGt?: number, currentGte?: number, currentLt?: number, currentLte?: number, quick?: number, quickGt?: number, quickGte?: number, quickLt?: number, quickLte?: number, cash?: number, cashGt?: number, cashGte?: number, cashLt?: number, cashLte?: number, evToSales?: number, evToSalesGt?: number, evToSalesGte?: number, evToSalesLt?: number, evToSalesLte?: number, evToEbitda?: number, evToEbitdaGt?: number, evToEbitdaGte?: number, evToEbitdaLt?: number, evToEbitdaLte?: number, enterpriseValue?: number, enterpriseValueGt?: number, enterpriseValueGte?: number, enterpriseValueLt?: number, enterpriseValueLte?: number, freeCashFlow?: number, freeCashFlowGt?: number, freeCashFlowGte?: number, freeCashFlowLt?: number, freeCashFlowLte?: number, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stocks/financials/v1/ratios`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (cikAnyOf !== undefined) {
                localVarQueryParameter['cik.any_of'] = cikAnyOf;
            }

            if (cikGt !== undefined) {
                localVarQueryParameter['cik.gt'] = cikGt;
            }

            if (cikGte !== undefined) {
                localVarQueryParameter['cik.gte'] = cikGte;
            }

            if (cikLt !== undefined) {
                localVarQueryParameter['cik.lt'] = cikLt;
            }

            if (cikLte !== undefined) {
                localVarQueryParameter['cik.lte'] = cikLte;
            }

            if (price !== undefined) {
                localVarQueryParameter['price'] = price;
            }

            if (priceGt !== undefined) {
                localVarQueryParameter['price.gt'] = priceGt;
            }

            if (priceGte !== undefined) {
                localVarQueryParameter['price.gte'] = priceGte;
            }

            if (priceLt !== undefined) {
                localVarQueryParameter['price.lt'] = priceLt;
            }

            if (priceLte !== undefined) {
                localVarQueryParameter['price.lte'] = priceLte;
            }

            if (averageVolume !== undefined) {
                localVarQueryParameter['average_volume'] = averageVolume;
            }

            if (averageVolumeGt !== undefined) {
                localVarQueryParameter['average_volume.gt'] = averageVolumeGt;
            }

            if (averageVolumeGte !== undefined) {
                localVarQueryParameter['average_volume.gte'] = averageVolumeGte;
            }

            if (averageVolumeLt !== undefined) {
                localVarQueryParameter['average_volume.lt'] = averageVolumeLt;
            }

            if (averageVolumeLte !== undefined) {
                localVarQueryParameter['average_volume.lte'] = averageVolumeLte;
            }

            if (marketCap !== undefined) {
                localVarQueryParameter['market_cap'] = marketCap;
            }

            if (marketCapGt !== undefined) {
                localVarQueryParameter['market_cap.gt'] = marketCapGt;
            }

            if (marketCapGte !== undefined) {
                localVarQueryParameter['market_cap.gte'] = marketCapGte;
            }

            if (marketCapLt !== undefined) {
                localVarQueryParameter['market_cap.lt'] = marketCapLt;
            }

            if (marketCapLte !== undefined) {
                localVarQueryParameter['market_cap.lte'] = marketCapLte;
            }

            if (earningsPerShare !== undefined) {
                localVarQueryParameter['earnings_per_share'] = earningsPerShare;
            }

            if (earningsPerShareGt !== undefined) {
                localVarQueryParameter['earnings_per_share.gt'] = earningsPerShareGt;
            }

            if (earningsPerShareGte !== undefined) {
                localVarQueryParameter['earnings_per_share.gte'] = earningsPerShareGte;
            }

            if (earningsPerShareLt !== undefined) {
                localVarQueryParameter['earnings_per_share.lt'] = earningsPerShareLt;
            }

            if (earningsPerShareLte !== undefined) {
                localVarQueryParameter['earnings_per_share.lte'] = earningsPerShareLte;
            }

            if (priceToEarnings !== undefined) {
                localVarQueryParameter['price_to_earnings'] = priceToEarnings;
            }

            if (priceToEarningsGt !== undefined) {
                localVarQueryParameter['price_to_earnings.gt'] = priceToEarningsGt;
            }

            if (priceToEarningsGte !== undefined) {
                localVarQueryParameter['price_to_earnings.gte'] = priceToEarningsGte;
            }

            if (priceToEarningsLt !== undefined) {
                localVarQueryParameter['price_to_earnings.lt'] = priceToEarningsLt;
            }

            if (priceToEarningsLte !== undefined) {
                localVarQueryParameter['price_to_earnings.lte'] = priceToEarningsLte;
            }

            if (priceToBook !== undefined) {
                localVarQueryParameter['price_to_book'] = priceToBook;
            }

            if (priceToBookGt !== undefined) {
                localVarQueryParameter['price_to_book.gt'] = priceToBookGt;
            }

            if (priceToBookGte !== undefined) {
                localVarQueryParameter['price_to_book.gte'] = priceToBookGte;
            }

            if (priceToBookLt !== undefined) {
                localVarQueryParameter['price_to_book.lt'] = priceToBookLt;
            }

            if (priceToBookLte !== undefined) {
                localVarQueryParameter['price_to_book.lte'] = priceToBookLte;
            }

            if (priceToSales !== undefined) {
                localVarQueryParameter['price_to_sales'] = priceToSales;
            }

            if (priceToSalesGt !== undefined) {
                localVarQueryParameter['price_to_sales.gt'] = priceToSalesGt;
            }

            if (priceToSalesGte !== undefined) {
                localVarQueryParameter['price_to_sales.gte'] = priceToSalesGte;
            }

            if (priceToSalesLt !== undefined) {
                localVarQueryParameter['price_to_sales.lt'] = priceToSalesLt;
            }

            if (priceToSalesLte !== undefined) {
                localVarQueryParameter['price_to_sales.lte'] = priceToSalesLte;
            }

            if (priceToCashFlow !== undefined) {
                localVarQueryParameter['price_to_cash_flow'] = priceToCashFlow;
            }

            if (priceToCashFlowGt !== undefined) {
                localVarQueryParameter['price_to_cash_flow.gt'] = priceToCashFlowGt;
            }

            if (priceToCashFlowGte !== undefined) {
                localVarQueryParameter['price_to_cash_flow.gte'] = priceToCashFlowGte;
            }

            if (priceToCashFlowLt !== undefined) {
                localVarQueryParameter['price_to_cash_flow.lt'] = priceToCashFlowLt;
            }

            if (priceToCashFlowLte !== undefined) {
                localVarQueryParameter['price_to_cash_flow.lte'] = priceToCashFlowLte;
            }

            if (priceToFreeCashFlow !== undefined) {
                localVarQueryParameter['price_to_free_cash_flow'] = priceToFreeCashFlow;
            }

            if (priceToFreeCashFlowGt !== undefined) {
                localVarQueryParameter['price_to_free_cash_flow.gt'] = priceToFreeCashFlowGt;
            }

            if (priceToFreeCashFlowGte !== undefined) {
                localVarQueryParameter['price_to_free_cash_flow.gte'] = priceToFreeCashFlowGte;
            }

            if (priceToFreeCashFlowLt !== undefined) {
                localVarQueryParameter['price_to_free_cash_flow.lt'] = priceToFreeCashFlowLt;
            }

            if (priceToFreeCashFlowLte !== undefined) {
                localVarQueryParameter['price_to_free_cash_flow.lte'] = priceToFreeCashFlowLte;
            }

            if (dividendYield !== undefined) {
                localVarQueryParameter['dividend_yield'] = dividendYield;
            }

            if (dividendYieldGt !== undefined) {
                localVarQueryParameter['dividend_yield.gt'] = dividendYieldGt;
            }

            if (dividendYieldGte !== undefined) {
                localVarQueryParameter['dividend_yield.gte'] = dividendYieldGte;
            }

            if (dividendYieldLt !== undefined) {
                localVarQueryParameter['dividend_yield.lt'] = dividendYieldLt;
            }

            if (dividendYieldLte !== undefined) {
                localVarQueryParameter['dividend_yield.lte'] = dividendYieldLte;
            }

            if (returnOnAssets !== undefined) {
                localVarQueryParameter['return_on_assets'] = returnOnAssets;
            }

            if (returnOnAssetsGt !== undefined) {
                localVarQueryParameter['return_on_assets.gt'] = returnOnAssetsGt;
            }

            if (returnOnAssetsGte !== undefined) {
                localVarQueryParameter['return_on_assets.gte'] = returnOnAssetsGte;
            }

            if (returnOnAssetsLt !== undefined) {
                localVarQueryParameter['return_on_assets.lt'] = returnOnAssetsLt;
            }

            if (returnOnAssetsLte !== undefined) {
                localVarQueryParameter['return_on_assets.lte'] = returnOnAssetsLte;
            }

            if (returnOnEquity !== undefined) {
                localVarQueryParameter['return_on_equity'] = returnOnEquity;
            }

            if (returnOnEquityGt !== undefined) {
                localVarQueryParameter['return_on_equity.gt'] = returnOnEquityGt;
            }

            if (returnOnEquityGte !== undefined) {
                localVarQueryParameter['return_on_equity.gte'] = returnOnEquityGte;
            }

            if (returnOnEquityLt !== undefined) {
                localVarQueryParameter['return_on_equity.lt'] = returnOnEquityLt;
            }

            if (returnOnEquityLte !== undefined) {
                localVarQueryParameter['return_on_equity.lte'] = returnOnEquityLte;
            }

            if (debtToEquity !== undefined) {
                localVarQueryParameter['debt_to_equity'] = debtToEquity;
            }

            if (debtToEquityGt !== undefined) {
                localVarQueryParameter['debt_to_equity.gt'] = debtToEquityGt;
            }

            if (debtToEquityGte !== undefined) {
                localVarQueryParameter['debt_to_equity.gte'] = debtToEquityGte;
            }

            if (debtToEquityLt !== undefined) {
                localVarQueryParameter['debt_to_equity.lt'] = debtToEquityLt;
            }

            if (debtToEquityLte !== undefined) {
                localVarQueryParameter['debt_to_equity.lte'] = debtToEquityLte;
            }

            if (current !== undefined) {
                localVarQueryParameter['current'] = current;
            }

            if (currentGt !== undefined) {
                localVarQueryParameter['current.gt'] = currentGt;
            }

            if (currentGte !== undefined) {
                localVarQueryParameter['current.gte'] = currentGte;
            }

            if (currentLt !== undefined) {
                localVarQueryParameter['current.lt'] = currentLt;
            }

            if (currentLte !== undefined) {
                localVarQueryParameter['current.lte'] = currentLte;
            }

            if (quick !== undefined) {
                localVarQueryParameter['quick'] = quick;
            }

            if (quickGt !== undefined) {
                localVarQueryParameter['quick.gt'] = quickGt;
            }

            if (quickGte !== undefined) {
                localVarQueryParameter['quick.gte'] = quickGte;
            }

            if (quickLt !== undefined) {
                localVarQueryParameter['quick.lt'] = quickLt;
            }

            if (quickLte !== undefined) {
                localVarQueryParameter['quick.lte'] = quickLte;
            }

            if (cash !== undefined) {
                localVarQueryParameter['cash'] = cash;
            }

            if (cashGt !== undefined) {
                localVarQueryParameter['cash.gt'] = cashGt;
            }

            if (cashGte !== undefined) {
                localVarQueryParameter['cash.gte'] = cashGte;
            }

            if (cashLt !== undefined) {
                localVarQueryParameter['cash.lt'] = cashLt;
            }

            if (cashLte !== undefined) {
                localVarQueryParameter['cash.lte'] = cashLte;
            }

            if (evToSales !== undefined) {
                localVarQueryParameter['ev_to_sales'] = evToSales;
            }

            if (evToSalesGt !== undefined) {
                localVarQueryParameter['ev_to_sales.gt'] = evToSalesGt;
            }

            if (evToSalesGte !== undefined) {
                localVarQueryParameter['ev_to_sales.gte'] = evToSalesGte;
            }

            if (evToSalesLt !== undefined) {
                localVarQueryParameter['ev_to_sales.lt'] = evToSalesLt;
            }

            if (evToSalesLte !== undefined) {
                localVarQueryParameter['ev_to_sales.lte'] = evToSalesLte;
            }

            if (evToEbitda !== undefined) {
                localVarQueryParameter['ev_to_ebitda'] = evToEbitda;
            }

            if (evToEbitdaGt !== undefined) {
                localVarQueryParameter['ev_to_ebitda.gt'] = evToEbitdaGt;
            }

            if (evToEbitdaGte !== undefined) {
                localVarQueryParameter['ev_to_ebitda.gte'] = evToEbitdaGte;
            }

            if (evToEbitdaLt !== undefined) {
                localVarQueryParameter['ev_to_ebitda.lt'] = evToEbitdaLt;
            }

            if (evToEbitdaLte !== undefined) {
                localVarQueryParameter['ev_to_ebitda.lte'] = evToEbitdaLte;
            }

            if (enterpriseValue !== undefined) {
                localVarQueryParameter['enterprise_value'] = enterpriseValue;
            }

            if (enterpriseValueGt !== undefined) {
                localVarQueryParameter['enterprise_value.gt'] = enterpriseValueGt;
            }

            if (enterpriseValueGte !== undefined) {
                localVarQueryParameter['enterprise_value.gte'] = enterpriseValueGte;
            }

            if (enterpriseValueLt !== undefined) {
                localVarQueryParameter['enterprise_value.lt'] = enterpriseValueLt;
            }

            if (enterpriseValueLte !== undefined) {
                localVarQueryParameter['enterprise_value.lte'] = enterpriseValueLte;
            }

            if (freeCashFlow !== undefined) {
                localVarQueryParameter['free_cash_flow'] = freeCashFlow;
            }

            if (freeCashFlowGt !== undefined) {
                localVarQueryParameter['free_cash_flow.gt'] = freeCashFlowGt;
            }

            if (freeCashFlowGte !== undefined) {
                localVarQueryParameter['free_cash_flow.gte'] = freeCashFlowGte;
            }

            if (freeCashFlowLt !== undefined) {
                localVarQueryParameter['free_cash_flow.lt'] = freeCashFlowLt;
            }

            if (freeCashFlowLte !== undefined) {
                localVarQueryParameter['free_cash_flow.lte'] = freeCashFlowLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetStocksMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksMACD: async (stockTicker: string, timestamp?: string, timespan?: GetStocksMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetStocksMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('getStocksMACD', 'stockTicker', stockTicker)
            const localVarPath = `/v1/indicators/macd/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (shortWindow !== undefined) {
                localVarQueryParameter['short_window'] = shortWindow;
            }

            if (longWindow !== undefined) {
                localVarQueryParameter['long_window'] = longWindow;
            }

            if (signalWindow !== undefined) {
                localVarQueryParameter['signal_window'] = signalWindow;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the open, close and afterhours prices of a stock symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksOpenClose: async (stocksTicker: string, date: string, adjusted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('getStocksOpenClose', 'stocksTicker', stocksTicker)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getStocksOpenClose', 'date', date)
            const localVarPath = `/v1/open-close/{stocksTicker}/{date}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get NBBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (NBBO)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetStocksQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetStocksQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksQuotes: async (stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetStocksQuotesOrderEnum, limit?: number, sort?: GetStocksQuotesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('getStocksQuotes', 'stockTicker', stockTicker)
            const localVarPath = `/v3/quotes/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetStocksRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksRSI: async (stockTicker: string, timestamp?: string, timespan?: GetStocksRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('getStocksRSI', 'stockTicker', stockTicker)
            const localVarPath = `/v1/indicators/rsi/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetStocksSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSMA: async (stockTicker: string, timestamp?: string, timespan?: GetStocksSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('getStocksSMA', 'stockTicker', stockTicker)
            const localVarPath = `/v1/indicators/sma/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }

            if (adjusted !== undefined) {
                localVarQueryParameter['adjusted'] = adjusted;
            }

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (seriesType !== undefined) {
                localVarQueryParameter['series_type'] = seriesType;
            }

            if (expandUnderlying !== undefined) {
                localVarQueryParameter['expand_underlying'] = expandUnderlying;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. This output will only include tickers with a trading volume of 10,000 or more. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetStocksSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSnapshotDirection: async (direction: GetStocksSnapshotDirectionDirectionEnum, includeOtc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('getStocksSnapshotDirection', 'direction', direction)
            const localVarPath = `/v2/snapshot/locale/us/markets/stocks/{direction}`
                .replace(`{${"direction"}}`, encodeURIComponent(String(direction)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (includeOtc !== undefined) {
                localVarQueryParameter['include_otc'] = includeOtc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most up-to-date market data for a single traded stock ticker. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary Ticker
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSnapshotTicker: async (stocksTicker: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stocksTicker' is not null or undefined
            assertParamExists('getStocksSnapshotTicker', 'stocksTicker', stocksTicker)
            const localVarPath = `/v2/snapshot/locale/us/markets/stocks/tickers/{stocksTicker}`
                .replace(`{${"stocksTicker"}}`, encodeURIComponent(String(stocksTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most up-to-date market data for all traded stock symbols. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers.
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSnapshotTickers: async (tickers?: Array<string>, includeOtc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/snapshot/locale/us/markets/stocks/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (tickers) {
                localVarQueryParameter['tickers'] = tickers;
            }

            if (includeOtc !== undefined) {
                localVarQueryParameter['include_otc'] = includeOtc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades for a ticker symbol in a given time range.
         * @summary Trades
         * @param {string} stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetStocksTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetStocksTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksTrades: async (stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetStocksTradesOrderEnum, limit?: number, sort?: GetStocksTradesSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockTicker' is not null or undefined
            assertParamExists('getStocksTrades', 'stockTicker', stockTicker)
            const localVarPath = `/v3/trades/{stockTicker}`
                .replace(`{${"stockTicker"}}`, encodeURIComponent(String(stockTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp.gte'] = timestampGte;
            }

            if (timestampGt !== undefined) {
                localVarQueryParameter['timestamp.gt'] = timestampGt;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp.lte'] = timestampLte;
            }

            if (timestampLt !== undefined) {
                localVarQueryParameter['timestamp.lt'] = timestampLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Contains historical dividend payment records for US stocks with split-adjusted amounts and historical adjustment factors for price normalization.
         * @param {string} [ticker] Stock symbol for the company issuing the dividend
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [exDividendDate] Date when the stock begins trading without the dividend value Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [exDividendDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [exDividendDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [exDividendDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [exDividendDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {number} [frequency] How many times per year this dividend is expected to occur. A value of 0 means the distribution is non-recurring or irregular (e.g., special, supplemental, or a one-off dividend). Other possible values include 1 (annual), 2 (semi-annual), 3 (trimester), 4 (quarterly), 12 (monthly), 24 (bi-monthly), 26 (bi-weekly), 52 (weekly), and 365 (daily) depending on the issuer\&#39;s declared or inferred payout cadence. Value must be an integer.
         * @param {number} [frequencyGt] Filter greater than the value. Value must be an integer.
         * @param {number} [frequencyGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [frequencyLt] Filter less than the value. Value must be an integer.
         * @param {number} [frequencyLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [distributionType] Classification describing the nature of this dividend\&#39;s recurrence pattern: recurring (paid on a regular schedule), special (one-time or commemorative), supplemental (extra beyond the regular schedule), irregular (unpredictable or non-recurring), unknown (cannot be classified from available data)
         * @param {string} [distributionTypeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [distributionTypeGt] Filter greater than the value.
         * @param {string} [distributionTypeGte] Filter greater than or equal to the value.
         * @param {string} [distributionTypeLt] Filter less than the value.
         * @param {string} [distributionTypeLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksV1Dividends: async (ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, exDividendDate?: string, exDividendDateGt?: string, exDividendDateGte?: string, exDividendDateLt?: string, exDividendDateLte?: string, frequency?: number, frequencyGt?: number, frequencyGte?: number, frequencyLt?: number, frequencyLte?: number, distributionType?: string, distributionTypeAnyOf?: string, distributionTypeGt?: string, distributionTypeGte?: string, distributionTypeLt?: string, distributionTypeLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stocks/v1/dividends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (exDividendDate !== undefined) {
                localVarQueryParameter['ex_dividend_date'] = exDividendDate;
            }

            if (exDividendDateGt !== undefined) {
                localVarQueryParameter['ex_dividend_date.gt'] = exDividendDateGt;
            }

            if (exDividendDateGte !== undefined) {
                localVarQueryParameter['ex_dividend_date.gte'] = exDividendDateGte;
            }

            if (exDividendDateLt !== undefined) {
                localVarQueryParameter['ex_dividend_date.lt'] = exDividendDateLt;
            }

            if (exDividendDateLte !== undefined) {
                localVarQueryParameter['ex_dividend_date.lte'] = exDividendDateLte;
            }

            if (frequency !== undefined) {
                localVarQueryParameter['frequency'] = frequency;
            }

            if (frequencyGt !== undefined) {
                localVarQueryParameter['frequency.gt'] = frequencyGt;
            }

            if (frequencyGte !== undefined) {
                localVarQueryParameter['frequency.gte'] = frequencyGte;
            }

            if (frequencyLt !== undefined) {
                localVarQueryParameter['frequency.lt'] = frequencyLt;
            }

            if (frequencyLte !== undefined) {
                localVarQueryParameter['frequency.lte'] = frequencyLte;
            }

            if (distributionType !== undefined) {
                localVarQueryParameter['distribution_type'] = distributionType;
            }

            if (distributionTypeAnyOf !== undefined) {
                localVarQueryParameter['distribution_type.any_of'] = distributionTypeAnyOf;
            }

            if (distributionTypeGt !== undefined) {
                localVarQueryParameter['distribution_type.gt'] = distributionTypeGt;
            }

            if (distributionTypeGte !== undefined) {
                localVarQueryParameter['distribution_type.gte'] = distributionTypeGte;
            }

            if (distributionTypeLt !== undefined) {
                localVarQueryParameter['distribution_type.lt'] = distributionTypeLt;
            }

            if (distributionTypeLte !== undefined) {
                localVarQueryParameter['distribution_type.lte'] = distributionTypeLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * US stock exchanges, trading venues, and reporting facilities including exchanges (NYSE, Nasdaq), Trade Reporting Facilities (TRF), Securities Information Processors (SIP), and OTC Reporting Facilities (ORF) for equity trading.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksV1Exchanges: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stocks/v1/exchanges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Comprehensive FINRA short interest data that tracks the short selling metrics for securities on a specific settlement date.
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [daysToCover] Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume. Value must be a floating point number.
         * @param {string} [daysToCoverAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [daysToCoverGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [daysToCoverGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [daysToCoverLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [daysToCoverLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {string} [settlementDate] The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
         * @param {string} [settlementDateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [settlementDateGt] Filter greater than the value.
         * @param {string} [settlementDateGte] Filter greater than or equal to the value.
         * @param {string} [settlementDateLt] Filter less than the value.
         * @param {string} [settlementDateLte] Filter less than or equal to the value.
         * @param {number} [avgDailyVolume] The average daily trading volume for the stock over a specified period, typically used to contextualize short interest. Value must be an integer.
         * @param {string} [avgDailyVolumeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [avgDailyVolumeGt] Filter greater than the value. Value must be an integer.
         * @param {number} [avgDailyVolumeGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [avgDailyVolumeLt] Filter less than the value. Value must be an integer.
         * @param {number} [avgDailyVolumeLte] Filter less than or equal to the value. Value must be an integer.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;10\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksV1ShortInterest: async (ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, daysToCover?: number, daysToCoverAnyOf?: string, daysToCoverGt?: number, daysToCoverGte?: number, daysToCoverLt?: number, daysToCoverLte?: number, settlementDate?: string, settlementDateAnyOf?: string, settlementDateGt?: string, settlementDateGte?: string, settlementDateLt?: string, settlementDateLte?: string, avgDailyVolume?: number, avgDailyVolumeAnyOf?: string, avgDailyVolumeGt?: number, avgDailyVolumeGte?: number, avgDailyVolumeLt?: number, avgDailyVolumeLte?: number, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stocks/v1/short-interest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (daysToCover !== undefined) {
                localVarQueryParameter['days_to_cover'] = daysToCover;
            }

            if (daysToCoverAnyOf !== undefined) {
                localVarQueryParameter['days_to_cover.any_of'] = daysToCoverAnyOf;
            }

            if (daysToCoverGt !== undefined) {
                localVarQueryParameter['days_to_cover.gt'] = daysToCoverGt;
            }

            if (daysToCoverGte !== undefined) {
                localVarQueryParameter['days_to_cover.gte'] = daysToCoverGte;
            }

            if (daysToCoverLt !== undefined) {
                localVarQueryParameter['days_to_cover.lt'] = daysToCoverLt;
            }

            if (daysToCoverLte !== undefined) {
                localVarQueryParameter['days_to_cover.lte'] = daysToCoverLte;
            }

            if (settlementDate !== undefined) {
                localVarQueryParameter['settlement_date'] = settlementDate;
            }

            if (settlementDateAnyOf !== undefined) {
                localVarQueryParameter['settlement_date.any_of'] = settlementDateAnyOf;
            }

            if (settlementDateGt !== undefined) {
                localVarQueryParameter['settlement_date.gt'] = settlementDateGt;
            }

            if (settlementDateGte !== undefined) {
                localVarQueryParameter['settlement_date.gte'] = settlementDateGte;
            }

            if (settlementDateLt !== undefined) {
                localVarQueryParameter['settlement_date.lt'] = settlementDateLt;
            }

            if (settlementDateLte !== undefined) {
                localVarQueryParameter['settlement_date.lte'] = settlementDateLte;
            }

            if (avgDailyVolume !== undefined) {
                localVarQueryParameter['avg_daily_volume'] = avgDailyVolume;
            }

            if (avgDailyVolumeAnyOf !== undefined) {
                localVarQueryParameter['avg_daily_volume.any_of'] = avgDailyVolumeAnyOf;
            }

            if (avgDailyVolumeGt !== undefined) {
                localVarQueryParameter['avg_daily_volume.gt'] = avgDailyVolumeGt;
            }

            if (avgDailyVolumeGte !== undefined) {
                localVarQueryParameter['avg_daily_volume.gte'] = avgDailyVolumeGte;
            }

            if (avgDailyVolumeLt !== undefined) {
                localVarQueryParameter['avg_daily_volume.lt'] = avgDailyVolumeLt;
            }

            if (avgDailyVolumeLte !== undefined) {
                localVarQueryParameter['avg_daily_volume.lte'] = avgDailyVolumeLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Contains short selling volume for different stock tickers, capturing total trading volume, short sale details, and breakdown by different trading platforms.
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [date] The date of trade activity reported in the format YYYY-MM-DD
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [shortVolumeRatio] The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100. Value must be a floating point number.
         * @param {string} [shortVolumeRatioAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [shortVolumeRatioGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [totalVolume] Total reported volume across all venues for the ticker on the given date. Value must be an integer.
         * @param {string} [totalVolumeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [totalVolumeGt] Filter greater than the value. Value must be an integer.
         * @param {number} [totalVolumeGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [totalVolumeLt] Filter less than the value. Value must be an integer.
         * @param {number} [totalVolumeLte] Filter less than or equal to the value. Value must be an integer.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;10\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksV1ShortVolume: async (ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, shortVolumeRatio?: number, shortVolumeRatioAnyOf?: string, shortVolumeRatioGt?: number, shortVolumeRatioGte?: number, shortVolumeRatioLt?: number, shortVolumeRatioLte?: number, totalVolume?: number, totalVolumeAnyOf?: string, totalVolumeGt?: number, totalVolumeGte?: number, totalVolumeLt?: number, totalVolumeLte?: number, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stocks/v1/short-volume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (shortVolumeRatio !== undefined) {
                localVarQueryParameter['short_volume_ratio'] = shortVolumeRatio;
            }

            if (shortVolumeRatioAnyOf !== undefined) {
                localVarQueryParameter['short_volume_ratio.any_of'] = shortVolumeRatioAnyOf;
            }

            if (shortVolumeRatioGt !== undefined) {
                localVarQueryParameter['short_volume_ratio.gt'] = shortVolumeRatioGt;
            }

            if (shortVolumeRatioGte !== undefined) {
                localVarQueryParameter['short_volume_ratio.gte'] = shortVolumeRatioGte;
            }

            if (shortVolumeRatioLt !== undefined) {
                localVarQueryParameter['short_volume_ratio.lt'] = shortVolumeRatioLt;
            }

            if (shortVolumeRatioLte !== undefined) {
                localVarQueryParameter['short_volume_ratio.lte'] = shortVolumeRatioLte;
            }

            if (totalVolume !== undefined) {
                localVarQueryParameter['total_volume'] = totalVolume;
            }

            if (totalVolumeAnyOf !== undefined) {
                localVarQueryParameter['total_volume.any_of'] = totalVolumeAnyOf;
            }

            if (totalVolumeGt !== undefined) {
                localVarQueryParameter['total_volume.gt'] = totalVolumeGt;
            }

            if (totalVolumeGte !== undefined) {
                localVarQueryParameter['total_volume.gte'] = totalVolumeGte;
            }

            if (totalVolumeLt !== undefined) {
                localVarQueryParameter['total_volume.lt'] = totalVolumeLt;
            }

            if (totalVolumeLte !== undefined) {
                localVarQueryParameter['total_volume.lte'] = totalVolumeLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Contains historical stock split and reverse split events for US equities with historical adjustment factors for price normalization.
         * @param {string} [ticker] Stock symbol for the company that executed the split
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [executionDate] Date when the stock split was applied and shares adjusted Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [executionDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [executionDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [executionDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [executionDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [adjustmentType] Classification of the share-change event. Possible values include: forward_split (share count increases), reverse_split (share count decreases), stock_dividend (shares issued as a dividend)
         * @param {string} [adjustmentTypeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [adjustmentTypeGt] Filter greater than the value.
         * @param {string} [adjustmentTypeGte] Filter greater than or equal to the value.
         * @param {string} [adjustmentTypeLt] Filter less than the value.
         * @param {string} [adjustmentTypeLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;execution_date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksV1Splits: async (ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, executionDate?: string, executionDateGt?: string, executionDateGte?: string, executionDateLt?: string, executionDateLte?: string, adjustmentType?: string, adjustmentTypeAnyOf?: string, adjustmentTypeGt?: string, adjustmentTypeGte?: string, adjustmentTypeLt?: string, adjustmentTypeLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stocks/v1/splits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (executionDate !== undefined) {
                localVarQueryParameter['execution_date'] = executionDate;
            }

            if (executionDateGt !== undefined) {
                localVarQueryParameter['execution_date.gt'] = executionDateGt;
            }

            if (executionDateGte !== undefined) {
                localVarQueryParameter['execution_date.gte'] = executionDateGte;
            }

            if (executionDateLt !== undefined) {
                localVarQueryParameter['execution_date.lt'] = executionDateLt;
            }

            if (executionDateLte !== undefined) {
                localVarQueryParameter['execution_date.lte'] = executionDateLte;
            }

            if (adjustmentType !== undefined) {
                localVarQueryParameter['adjustment_type'] = adjustmentType;
            }

            if (adjustmentTypeAnyOf !== undefined) {
                localVarQueryParameter['adjustment_type.any_of'] = adjustmentTypeAnyOf;
            }

            if (adjustmentTypeGt !== undefined) {
                localVarQueryParameter['adjustment_type.gt'] = adjustmentTypeGt;
            }

            if (adjustmentTypeGte !== undefined) {
                localVarQueryParameter['adjustment_type.gte'] = adjustmentTypeGte;
            }

            if (adjustmentTypeLt !== undefined) {
                localVarQueryParameter['adjustment_type.lt'] = adjustmentTypeLt;
            }

            if (adjustmentTypeLte !== undefined) {
                localVarQueryParameter['adjustment_type.lte'] = adjustmentTypeLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single ticker supported by Massive.com. This response will have detailed information about the ticker and the company behind it.
         * @summary Ticker Details v3
         * @param {string} ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [date] Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker: async (ticker: string, date?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getTicker', 'ticker', ticker)
            const localVarPath = `/v3/reference/tickers/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Contains corporate events and announcements for publicly traded companies, including earnings releases, conferences, dividends, and business updates sourced from TMX.
         * @param {string} [date] Scheduled date of the corporate event, formatted as YYYY-MM-DD.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [type] The normalized type of corporate event. Possible values include: analyst_day, business_update, capital_markets_day, conference, dividend, earnings_announcement_date, earnings_conference_call, earnings_results_announcement, forum, interim_statement, other_interim_announcement, production_update, research_and_development_day, seminar, shareholder_meeting, sales_update, stock_split, summit, service_level_update, tradeshow, company_travel, and workshop.
         * @param {string} [typeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [typeGt] Filter greater than the value.
         * @param {string} [typeGte] Filter greater than or equal to the value.
         * @param {string} [typeLt] Filter less than the value.
         * @param {string} [typeLte] Filter less than or equal to the value.
         * @param {string} [status] The current status of the event. Possible values include: approved, canceled, confirmed, historical, pending_approval, postponed, and unconfirmed.
         * @param {string} [statusAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [statusGt] Filter greater than the value.
         * @param {string} [statusGte] Filter greater than or equal to the value.
         * @param {string} [statusLt] Filter less than the value.
         * @param {string} [statusLte] Filter less than or equal to the value.
         * @param {string} [ticker] The company\&#39;s stock symbol.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [isin] Standard international identifier for the company\&#39;s common stock.
         * @param {string} [isinAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [isinGt] Filter greater than the value.
         * @param {string} [isinGte] Filter greater than or equal to the value.
         * @param {string} [isinLt] Filter less than the value.
         * @param {string} [isinLte] Filter less than or equal to the value.
         * @param {string} [tradingVenue] MIC (Market Identifier Code) of the exchange where the company\&#39;s stock is listed.
         * @param {string} [tradingVenueAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tradingVenueGt] Filter greater than the value.
         * @param {string} [tradingVenueGte] Filter greater than or equal to the value.
         * @param {string} [tradingVenueLt] Filter less than the value.
         * @param {string} [tradingVenueLte] Filter less than or equal to the value.
         * @param {number} [tmxCompanyId] Unique numeric identifier for the company used by TMX. Value must be an integer.
         * @param {number} [tmxCompanyIdGt] Filter greater than the value. Value must be an integer.
         * @param {number} [tmxCompanyIdGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [tmxCompanyIdLt] Filter less than the value. Value must be an integer.
         * @param {number} [tmxCompanyIdLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [tmxRecordId] The unique alphanumeric identifier for the event record used by TMX.
         * @param {string} [tmxRecordIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tmxRecordIdGt] Filter greater than the value.
         * @param {string} [tmxRecordIdGte] Filter greater than or equal to the value.
         * @param {string} [tmxRecordIdLt] Filter less than the value.
         * @param {string} [tmxRecordIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTmxV1CorporateEvents: async (date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, type?: string, typeAnyOf?: string, typeGt?: string, typeGte?: string, typeLt?: string, typeLte?: string, status?: string, statusAnyOf?: string, statusGt?: string, statusGte?: string, statusLt?: string, statusLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, isin?: string, isinAnyOf?: string, isinGt?: string, isinGte?: string, isinLt?: string, isinLte?: string, tradingVenue?: string, tradingVenueAnyOf?: string, tradingVenueGt?: string, tradingVenueGte?: string, tradingVenueLt?: string, tradingVenueLte?: string, tmxCompanyId?: number, tmxCompanyIdGt?: number, tmxCompanyIdGte?: number, tmxCompanyIdLt?: number, tmxCompanyIdLte?: number, tmxRecordId?: string, tmxRecordIdAnyOf?: string, tmxRecordIdGt?: string, tmxRecordIdGte?: string, tmxRecordIdLt?: string, tmxRecordIdLte?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tmx/v1/corporate-events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (dateAnyOf !== undefined) {
                localVarQueryParameter['date.any_of'] = dateAnyOf;
            }

            if (dateGt !== undefined) {
                localVarQueryParameter['date.gt'] = dateGt;
            }

            if (dateGte !== undefined) {
                localVarQueryParameter['date.gte'] = dateGte;
            }

            if (dateLt !== undefined) {
                localVarQueryParameter['date.lt'] = dateLt;
            }

            if (dateLte !== undefined) {
                localVarQueryParameter['date.lte'] = dateLte;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (typeAnyOf !== undefined) {
                localVarQueryParameter['type.any_of'] = typeAnyOf;
            }

            if (typeGt !== undefined) {
                localVarQueryParameter['type.gt'] = typeGt;
            }

            if (typeGte !== undefined) {
                localVarQueryParameter['type.gte'] = typeGte;
            }

            if (typeLt !== undefined) {
                localVarQueryParameter['type.lt'] = typeLt;
            }

            if (typeLte !== undefined) {
                localVarQueryParameter['type.lte'] = typeLte;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (statusAnyOf !== undefined) {
                localVarQueryParameter['status.any_of'] = statusAnyOf;
            }

            if (statusGt !== undefined) {
                localVarQueryParameter['status.gt'] = statusGt;
            }

            if (statusGte !== undefined) {
                localVarQueryParameter['status.gte'] = statusGte;
            }

            if (statusLt !== undefined) {
                localVarQueryParameter['status.lt'] = statusLt;
            }

            if (statusLte !== undefined) {
                localVarQueryParameter['status.lte'] = statusLte;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (tickerAnyOf !== undefined) {
                localVarQueryParameter['ticker.any_of'] = tickerAnyOf;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (isin !== undefined) {
                localVarQueryParameter['isin'] = isin;
            }

            if (isinAnyOf !== undefined) {
                localVarQueryParameter['isin.any_of'] = isinAnyOf;
            }

            if (isinGt !== undefined) {
                localVarQueryParameter['isin.gt'] = isinGt;
            }

            if (isinGte !== undefined) {
                localVarQueryParameter['isin.gte'] = isinGte;
            }

            if (isinLt !== undefined) {
                localVarQueryParameter['isin.lt'] = isinLt;
            }

            if (isinLte !== undefined) {
                localVarQueryParameter['isin.lte'] = isinLte;
            }

            if (tradingVenue !== undefined) {
                localVarQueryParameter['trading_venue'] = tradingVenue;
            }

            if (tradingVenueAnyOf !== undefined) {
                localVarQueryParameter['trading_venue.any_of'] = tradingVenueAnyOf;
            }

            if (tradingVenueGt !== undefined) {
                localVarQueryParameter['trading_venue.gt'] = tradingVenueGt;
            }

            if (tradingVenueGte !== undefined) {
                localVarQueryParameter['trading_venue.gte'] = tradingVenueGte;
            }

            if (tradingVenueLt !== undefined) {
                localVarQueryParameter['trading_venue.lt'] = tradingVenueLt;
            }

            if (tradingVenueLte !== undefined) {
                localVarQueryParameter['trading_venue.lte'] = tradingVenueLte;
            }

            if (tmxCompanyId !== undefined) {
                localVarQueryParameter['tmx_company_id'] = tmxCompanyId;
            }

            if (tmxCompanyIdGt !== undefined) {
                localVarQueryParameter['tmx_company_id.gt'] = tmxCompanyIdGt;
            }

            if (tmxCompanyIdGte !== undefined) {
                localVarQueryParameter['tmx_company_id.gte'] = tmxCompanyIdGte;
            }

            if (tmxCompanyIdLt !== undefined) {
                localVarQueryParameter['tmx_company_id.lt'] = tmxCompanyIdLt;
            }

            if (tmxCompanyIdLte !== undefined) {
                localVarQueryParameter['tmx_company_id.lte'] = tmxCompanyIdLte;
            }

            if (tmxRecordId !== undefined) {
                localVarQueryParameter['tmx_record_id'] = tmxRecordId;
            }

            if (tmxRecordIdAnyOf !== undefined) {
                localVarQueryParameter['tmx_record_id.any_of'] = tmxRecordIdAnyOf;
            }

            if (tmxRecordIdGt !== undefined) {
                localVarQueryParameter['tmx_record_id.gt'] = tmxRecordIdGt;
            }

            if (tmxRecordIdGte !== undefined) {
                localVarQueryParameter['tmx_record_id.gte'] = tmxRecordIdGte;
            }

            if (tmxRecordIdLt !== undefined) {
                localVarQueryParameter['tmx_record_id.lt'] = tmxRecordIdLt;
            }

            if (tmxRecordIdLte !== undefined) {
                localVarQueryParameter['tmx_record_id.lte'] = tmxRecordIdLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all conditions that Massive uses.
         * @summary Conditions
         * @param {ListConditionsAssetClassEnum} [assetClass] Filter for conditions within a given asset class.
         * @param {ListConditionsDataTypeEnum} [dataType] Filter by data type.
         * @param {number} [id] Filter for conditions with a given ID.
         * @param {ListConditionsSipEnum} [sip] Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned.
         * @param {ListConditionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListConditionsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConditions: async (assetClass?: ListConditionsAssetClassEnum, dataType?: ListConditionsDataTypeEnum, id?: number, sip?: ListConditionsSipEnum, order?: ListConditionsOrderEnum, limit?: number, sort?: ListConditionsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/conditions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (assetClass !== undefined) {
                localVarQueryParameter['asset_class'] = assetClass;
            }

            if (dataType !== undefined) {
                localVarQueryParameter['data_type'] = dataType;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (sip !== undefined) {
                localVarQueryParameter['sip'] = sip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
         * @summary Dividends v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [exDividendDate] Query by ex-dividend date with the format YYYY-MM-DD.
         * @param {string} [recordDate] Query by record date with the format YYYY-MM-DD.
         * @param {string} [declarationDate] Query by declaration date with the format YYYY-MM-DD.
         * @param {string} [payDate] Query by pay date with the format YYYY-MM-DD.
         * @param {ListDividendsFrequencyEnum} [frequency] Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
         * @param {number} [cashAmount] Query by the cash amount of the dividend.
         * @param {ListDividendsDividendTypeEnum} [dividendType] Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [exDividendDateGte] Range by ex_dividend_date.
         * @param {string} [exDividendDateGt] Range by ex_dividend_date.
         * @param {string} [exDividendDateLte] Range by ex_dividend_date.
         * @param {string} [exDividendDateLt] Range by ex_dividend_date.
         * @param {string} [recordDateGte] Range by record_date.
         * @param {string} [recordDateGt] Range by record_date.
         * @param {string} [recordDateLte] Range by record_date.
         * @param {string} [recordDateLt] Range by record_date.
         * @param {string} [declarationDateGte] Range by declaration_date.
         * @param {string} [declarationDateGt] Range by declaration_date.
         * @param {string} [declarationDateLte] Range by declaration_date.
         * @param {string} [declarationDateLt] Range by declaration_date.
         * @param {string} [payDateGte] Range by pay_date.
         * @param {string} [payDateGt] Range by pay_date.
         * @param {string} [payDateLte] Range by pay_date.
         * @param {string} [payDateLt] Range by pay_date.
         * @param {number} [cashAmountGte] Range by cash_amount.
         * @param {number} [cashAmountGt] Range by cash_amount.
         * @param {number} [cashAmountLte] Range by cash_amount.
         * @param {number} [cashAmountLt] Range by cash_amount.
         * @param {ListDividendsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListDividendsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDividends: async (ticker?: string, exDividendDate?: string, recordDate?: string, declarationDate?: string, payDate?: string, frequency?: ListDividendsFrequencyEnum, cashAmount?: number, dividendType?: ListDividendsDividendTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, exDividendDateGte?: string, exDividendDateGt?: string, exDividendDateLte?: string, exDividendDateLt?: string, recordDateGte?: string, recordDateGt?: string, recordDateLte?: string, recordDateLt?: string, declarationDateGte?: string, declarationDateGt?: string, declarationDateLte?: string, declarationDateLt?: string, payDateGte?: string, payDateGt?: string, payDateLte?: string, payDateLt?: string, cashAmountGte?: number, cashAmountGt?: number, cashAmountLte?: number, cashAmountLt?: number, order?: ListDividendsOrderEnum, limit?: number, sort?: ListDividendsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/dividends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (exDividendDate !== undefined) {
                localVarQueryParameter['ex_dividend_date'] = (exDividendDate as any instanceof Date) ?
                    (exDividendDate as any).toISOString().substring(0,10) :
                    exDividendDate;
            }

            if (recordDate !== undefined) {
                localVarQueryParameter['record_date'] = (recordDate as any instanceof Date) ?
                    (recordDate as any).toISOString().substring(0,10) :
                    recordDate;
            }

            if (declarationDate !== undefined) {
                localVarQueryParameter['declaration_date'] = (declarationDate as any instanceof Date) ?
                    (declarationDate as any).toISOString().substring(0,10) :
                    declarationDate;
            }

            if (payDate !== undefined) {
                localVarQueryParameter['pay_date'] = (payDate as any instanceof Date) ?
                    (payDate as any).toISOString().substring(0,10) :
                    payDate;
            }

            if (frequency !== undefined) {
                localVarQueryParameter['frequency'] = frequency;
            }

            if (cashAmount !== undefined) {
                localVarQueryParameter['cash_amount'] = cashAmount;
            }

            if (dividendType !== undefined) {
                localVarQueryParameter['dividend_type'] = dividendType;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (exDividendDateGte !== undefined) {
                localVarQueryParameter['ex_dividend_date.gte'] = (exDividendDateGte as any instanceof Date) ?
                    (exDividendDateGte as any).toISOString().substring(0,10) :
                    exDividendDateGte;
            }

            if (exDividendDateGt !== undefined) {
                localVarQueryParameter['ex_dividend_date.gt'] = (exDividendDateGt as any instanceof Date) ?
                    (exDividendDateGt as any).toISOString().substring(0,10) :
                    exDividendDateGt;
            }

            if (exDividendDateLte !== undefined) {
                localVarQueryParameter['ex_dividend_date.lte'] = (exDividendDateLte as any instanceof Date) ?
                    (exDividendDateLte as any).toISOString().substring(0,10) :
                    exDividendDateLte;
            }

            if (exDividendDateLt !== undefined) {
                localVarQueryParameter['ex_dividend_date.lt'] = (exDividendDateLt as any instanceof Date) ?
                    (exDividendDateLt as any).toISOString().substring(0,10) :
                    exDividendDateLt;
            }

            if (recordDateGte !== undefined) {
                localVarQueryParameter['record_date.gte'] = (recordDateGte as any instanceof Date) ?
                    (recordDateGte as any).toISOString().substring(0,10) :
                    recordDateGte;
            }

            if (recordDateGt !== undefined) {
                localVarQueryParameter['record_date.gt'] = (recordDateGt as any instanceof Date) ?
                    (recordDateGt as any).toISOString().substring(0,10) :
                    recordDateGt;
            }

            if (recordDateLte !== undefined) {
                localVarQueryParameter['record_date.lte'] = (recordDateLte as any instanceof Date) ?
                    (recordDateLte as any).toISOString().substring(0,10) :
                    recordDateLte;
            }

            if (recordDateLt !== undefined) {
                localVarQueryParameter['record_date.lt'] = (recordDateLt as any instanceof Date) ?
                    (recordDateLt as any).toISOString().substring(0,10) :
                    recordDateLt;
            }

            if (declarationDateGte !== undefined) {
                localVarQueryParameter['declaration_date.gte'] = (declarationDateGte as any instanceof Date) ?
                    (declarationDateGte as any).toISOString().substring(0,10) :
                    declarationDateGte;
            }

            if (declarationDateGt !== undefined) {
                localVarQueryParameter['declaration_date.gt'] = (declarationDateGt as any instanceof Date) ?
                    (declarationDateGt as any).toISOString().substring(0,10) :
                    declarationDateGt;
            }

            if (declarationDateLte !== undefined) {
                localVarQueryParameter['declaration_date.lte'] = (declarationDateLte as any instanceof Date) ?
                    (declarationDateLte as any).toISOString().substring(0,10) :
                    declarationDateLte;
            }

            if (declarationDateLt !== undefined) {
                localVarQueryParameter['declaration_date.lt'] = (declarationDateLt as any instanceof Date) ?
                    (declarationDateLt as any).toISOString().substring(0,10) :
                    declarationDateLt;
            }

            if (payDateGte !== undefined) {
                localVarQueryParameter['pay_date.gte'] = (payDateGte as any instanceof Date) ?
                    (payDateGte as any).toISOString().substring(0,10) :
                    payDateGte;
            }

            if (payDateGt !== undefined) {
                localVarQueryParameter['pay_date.gt'] = (payDateGt as any instanceof Date) ?
                    (payDateGt as any).toISOString().substring(0,10) :
                    payDateGt;
            }

            if (payDateLte !== undefined) {
                localVarQueryParameter['pay_date.lte'] = (payDateLte as any instanceof Date) ?
                    (payDateLte as any).toISOString().substring(0,10) :
                    payDateLte;
            }

            if (payDateLt !== undefined) {
                localVarQueryParameter['pay_date.lt'] = (payDateLt as any instanceof Date) ?
                    (payDateLt as any).toISOString().substring(0,10) :
                    payDateLt;
            }

            if (cashAmountGte !== undefined) {
                localVarQueryParameter['cash_amount.gte'] = cashAmountGte;
            }

            if (cashAmountGt !== undefined) {
                localVarQueryParameter['cash_amount.gt'] = cashAmountGt;
            }

            if (cashAmountLte !== undefined) {
                localVarQueryParameter['cash_amount.lte'] = cashAmountLte;
            }

            if (cashAmountLt !== undefined) {
                localVarQueryParameter['cash_amount.lt'] = cashAmountLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all exchanges that Massive knows about.
         * @summary Exchanges
         * @param {ListExchangesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListExchangesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExchanges: async (assetClass?: ListExchangesAssetClassEnum, locale?: ListExchangesLocaleEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/exchanges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (assetClass !== undefined) {
                localVarQueryParameter['asset_class'] = assetClass;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\">here</a>.
         * @summary Stock Financials vX
         * @param {string} [ticker] Query by company ticker.
         * @param {string} [cik] Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number
         * @param {string} [companyName] Query by company name.
         * @param {string} [sic] Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;)
         * @param {string} [filingDate] Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01
         * @param {string} [periodOfReportDate] The period of report for the filing with financials data in YYYY-MM-DD format.
         * @param {ListFinancialsTimeframeEnum} [timeframe] Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4
         * @param {boolean} [includeSources] Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default.
         * @param {string} [companyNameSearch] Search by company_name.
         * @param {string} [filingDateGte] Search by filing_date.
         * @param {string} [filingDateGt] Search by filing_date.
         * @param {string} [filingDateLte] Search by filing_date.
         * @param {string} [filingDateLt] Search by filing_date.
         * @param {string} [periodOfReportDateGte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateGt] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLt] Search by period_of_report_date.
         * @param {ListFinancialsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 100.
         * @param {ListFinancialsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFinancials: async (ticker?: string, cik?: string, companyName?: string, sic?: string, filingDate?: string, periodOfReportDate?: string, timeframe?: ListFinancialsTimeframeEnum, includeSources?: boolean, companyNameSearch?: string, filingDateGte?: string, filingDateGt?: string, filingDateLte?: string, filingDateLt?: string, periodOfReportDateGte?: string, periodOfReportDateGt?: string, periodOfReportDateLte?: string, periodOfReportDateLt?: string, order?: ListFinancialsOrderEnum, limit?: number, sort?: ListFinancialsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vX/reference/financials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (companyName !== undefined) {
                localVarQueryParameter['company_name'] = companyName;
            }

            if (sic !== undefined) {
                localVarQueryParameter['sic'] = sic;
            }

            if (filingDate !== undefined) {
                localVarQueryParameter['filing_date'] = (filingDate as any instanceof Date) ?
                    (filingDate as any).toISOString().substring(0,10) :
                    filingDate;
            }

            if (periodOfReportDate !== undefined) {
                localVarQueryParameter['period_of_report_date'] = (periodOfReportDate as any instanceof Date) ?
                    (periodOfReportDate as any).toISOString().substring(0,10) :
                    periodOfReportDate;
            }

            if (timeframe !== undefined) {
                localVarQueryParameter['timeframe'] = timeframe;
            }

            if (includeSources !== undefined) {
                localVarQueryParameter['include_sources'] = includeSources;
            }

            if (companyNameSearch !== undefined) {
                localVarQueryParameter['company_name.search'] = companyNameSearch;
            }

            if (filingDateGte !== undefined) {
                localVarQueryParameter['filing_date.gte'] = (filingDateGte as any instanceof Date) ?
                    (filingDateGte as any).toISOString().substring(0,10) :
                    filingDateGte;
            }

            if (filingDateGt !== undefined) {
                localVarQueryParameter['filing_date.gt'] = (filingDateGt as any instanceof Date) ?
                    (filingDateGt as any).toISOString().substring(0,10) :
                    filingDateGt;
            }

            if (filingDateLte !== undefined) {
                localVarQueryParameter['filing_date.lte'] = (filingDateLte as any instanceof Date) ?
                    (filingDateLte as any).toISOString().substring(0,10) :
                    filingDateLte;
            }

            if (filingDateLt !== undefined) {
                localVarQueryParameter['filing_date.lt'] = (filingDateLt as any instanceof Date) ?
                    (filingDateLt as any).toISOString().substring(0,10) :
                    filingDateLt;
            }

            if (periodOfReportDateGte !== undefined) {
                localVarQueryParameter['period_of_report_date.gte'] = (periodOfReportDateGte as any instanceof Date) ?
                    (periodOfReportDateGte as any).toISOString().substring(0,10) :
                    periodOfReportDateGte;
            }

            if (periodOfReportDateGt !== undefined) {
                localVarQueryParameter['period_of_report_date.gt'] = (periodOfReportDateGt as any instanceof Date) ?
                    (periodOfReportDateGt as any).toISOString().substring(0,10) :
                    periodOfReportDateGt;
            }

            if (periodOfReportDateLte !== undefined) {
                localVarQueryParameter['period_of_report_date.lte'] = (periodOfReportDateLte as any instanceof Date) ?
                    (periodOfReportDateLte as any).toISOString().substring(0,10) :
                    periodOfReportDateLte;
            }

            if (periodOfReportDateLt !== undefined) {
                localVarQueryParameter['period_of_report_date.lt'] = (periodOfReportDateLt as any instanceof Date) ?
                    (periodOfReportDateLt as any).toISOString().substring(0,10) :
                    periodOfReportDateLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
         * @summary IPOs
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, TSLA represents Tesla Inc.
         * @param {string} [usCode] Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
         * @param {string} [isin] Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world.
         * @param {string} [listingDate] Specify a listing date. This is the first trading date for the newly listed entity.
         * @param {ListIPOsIpoStatusEnum} [ipoStatus] Specify an IPO status.
         * @param {string} [listingDateGte] Range by listing_date.
         * @param {string} [listingDateGt] Range by listing_date.
         * @param {string} [listingDateLte] Range by listing_date.
         * @param {string} [listingDateLt] Range by listing_date.
         * @param {ListIPOsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListIPOsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIPOs: async (ticker?: string, usCode?: string, isin?: string, listingDate?: string, ipoStatus?: ListIPOsIpoStatusEnum, listingDateGte?: string, listingDateGt?: string, listingDateLte?: string, listingDateLt?: string, order?: ListIPOsOrderEnum, limit?: number, sort?: ListIPOsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vX/reference/ipos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (usCode !== undefined) {
                localVarQueryParameter['us_code'] = usCode;
            }

            if (isin !== undefined) {
                localVarQueryParameter['isin'] = isin;
            }

            if (listingDate !== undefined) {
                localVarQueryParameter['listing_date'] = (listingDate as any instanceof Date) ?
                    (listingDate as any).toISOString().substring(0,10) :
                    listingDate;
            }

            if (ipoStatus !== undefined) {
                localVarQueryParameter['ipo_status'] = ipoStatus;
            }

            if (listingDateGte !== undefined) {
                localVarQueryParameter['listing_date.gte'] = (listingDateGte as any instanceof Date) ?
                    (listingDateGte as any).toISOString().substring(0,10) :
                    listingDateGte;
            }

            if (listingDateGt !== undefined) {
                localVarQueryParameter['listing_date.gt'] = (listingDateGt as any instanceof Date) ?
                    (listingDateGt as any).toISOString().substring(0,10) :
                    listingDateGt;
            }

            if (listingDateLte !== undefined) {
                localVarQueryParameter['listing_date.lte'] = (listingDateLte as any instanceof Date) ?
                    (listingDateLte as any).toISOString().substring(0,10) :
                    listingDateLte;
            }

            if (listingDateLt !== undefined) {
                localVarQueryParameter['listing_date.lt'] = (listingDateLt as any instanceof Date) ?
                    (listingDateLt as any).toISOString().substring(0,10) :
                    listingDateLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
         * @summary Ticker News
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtc] Return results published on, before, or after this date.
         * @param {string} [tickerGte] Search by ticker.
         * @param {string} [tickerGt] Search by ticker.
         * @param {string} [tickerLte] Search by ticker.
         * @param {string} [tickerLt] Search by ticker.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGt] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLt] Search by published_utc.
         * @param {ListNewsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListNewsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNews: async (ticker?: string, publishedUtc?: ListNewsPublishedUtcParameter, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, publishedUtcGte?: ListNewsPublishedUtcParameter, publishedUtcGt?: ListNewsPublishedUtcParameter, publishedUtcLte?: ListNewsPublishedUtcParameter, publishedUtcLt?: ListNewsPublishedUtcParameter, order?: ListNewsOrderEnum, limit?: number, sort?: ListNewsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/reference/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (publishedUtc !== undefined) {
                for (const [key, value] of Object.entries(publishedUtc)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (publishedUtcGte !== undefined) {
                for (const [key, value] of Object.entries(publishedUtcGte)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (publishedUtcGt !== undefined) {
                for (const [key, value] of Object.entries(publishedUtcGt)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (publishedUtcLte !== undefined) {
                for (const [key, value] of Object.entries(publishedUtcLte)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (publishedUtcLt !== undefined) {
                for (const [key, value] of Object.entries(publishedUtcLt)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query for historical options contracts. This provides both active and expired options contracts.
         * @summary Options Contracts
         * @param {string} [underlyingTicker] Query for contracts relating to an underlying stock ticker.
         * @param {string} [ticker] This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://massive.com/docs/rest/options/contracts/contract-overview).
         * @param {ListOptionsContractsContractTypeEnum} [contractType] Query by the type of contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {string} [asOf] Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {boolean} [expired] Query for expired contracts. Default is false.
         * @param {string} [underlyingTickerGte] Range by underlying_ticker.
         * @param {string} [underlyingTickerGt] Range by underlying_ticker.
         * @param {string} [underlyingTickerLte] Range by underlying_ticker.
         * @param {string} [underlyingTickerLt] Range by underlying_ticker.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {ListOptionsContractsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListOptionsContractsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOptionsContracts: async (underlyingTicker?: string, ticker?: string, contractType?: ListOptionsContractsContractTypeEnum, expirationDate?: string, asOf?: string, strikePrice?: number, expired?: boolean, underlyingTickerGte?: string, underlyingTickerGt?: string, underlyingTickerLte?: string, underlyingTickerLt?: string, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, order?: ListOptionsContractsOrderEnum, limit?: number, sort?: ListOptionsContractsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/options/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (underlyingTicker !== undefined) {
                localVarQueryParameter['underlying_ticker'] = underlyingTicker;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contract_type'] = contractType;
            }

            if (expirationDate !== undefined) {
                localVarQueryParameter['expiration_date'] = expirationDate;
            }

            if (asOf !== undefined) {
                localVarQueryParameter['as_of'] = asOf;
            }

            if (strikePrice !== undefined) {
                localVarQueryParameter['strike_price'] = strikePrice;
            }

            if (expired !== undefined) {
                localVarQueryParameter['expired'] = expired;
            }

            if (underlyingTickerGte !== undefined) {
                localVarQueryParameter['underlying_ticker.gte'] = underlyingTickerGte;
            }

            if (underlyingTickerGt !== undefined) {
                localVarQueryParameter['underlying_ticker.gt'] = underlyingTickerGt;
            }

            if (underlyingTickerLte !== undefined) {
                localVarQueryParameter['underlying_ticker.lte'] = underlyingTickerLte;
            }

            if (underlyingTickerLt !== undefined) {
                localVarQueryParameter['underlying_ticker.lt'] = underlyingTickerLt;
            }

            if (expirationDateGte !== undefined) {
                localVarQueryParameter['expiration_date.gte'] = expirationDateGte;
            }

            if (expirationDateGt !== undefined) {
                localVarQueryParameter['expiration_date.gt'] = expirationDateGt;
            }

            if (expirationDateLte !== undefined) {
                localVarQueryParameter['expiration_date.lte'] = expirationDateLte;
            }

            if (expirationDateLt !== undefined) {
                localVarQueryParameter['expiration_date.lt'] = expirationDateLt;
            }

            if (strikePriceGte !== undefined) {
                localVarQueryParameter['strike_price.gte'] = strikePriceGte;
            }

            if (strikePriceGt !== undefined) {
                localVarQueryParameter['strike_price.gt'] = strikePriceGt;
            }

            if (strikePriceLte !== undefined) {
                localVarQueryParameter['strike_price.lte'] = strikePriceLte;
            }

            if (strikePriceLt !== undefined) {
                localVarQueryParameter['strike_price.lt'] = strikePriceLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
         * @summary Stock Splits v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [executionDate] Query by execution date with the format YYYY-MM-DD.
         * @param {boolean | null} [reverseSplit] Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [executionDateGte] Range by execution_date.
         * @param {string} [executionDateGt] Range by execution_date.
         * @param {string} [executionDateLte] Range by execution_date.
         * @param {string} [executionDateLt] Range by execution_date.
         * @param {ListStockSplitsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListStockSplitsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStockSplits: async (ticker?: string, executionDate?: string, reverseSplit?: boolean | null, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, executionDateGte?: string, executionDateGt?: string, executionDateLte?: string, executionDateLt?: string, order?: ListStockSplitsOrderEnum, limit?: number, sort?: ListStockSplitsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/splits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (executionDate !== undefined) {
                localVarQueryParameter['execution_date'] = (executionDate as any instanceof Date) ?
                    (executionDate as any).toISOString().substring(0,10) :
                    executionDate;
            }

            if (reverseSplit !== undefined) {
                localVarQueryParameter['reverse_split'] = reverseSplit;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (executionDateGte !== undefined) {
                localVarQueryParameter['execution_date.gte'] = (executionDateGte as any instanceof Date) ?
                    (executionDateGte as any).toISOString().substring(0,10) :
                    executionDateGte;
            }

            if (executionDateGt !== undefined) {
                localVarQueryParameter['execution_date.gt'] = (executionDateGt as any instanceof Date) ?
                    (executionDateGt as any).toISOString().substring(0,10) :
                    executionDateGt;
            }

            if (executionDateLte !== undefined) {
                localVarQueryParameter['execution_date.lte'] = (executionDateLte as any instanceof Date) ?
                    (executionDateLte as any).toISOString().substring(0,10) :
                    executionDateLte;
            }

            if (executionDateLt !== undefined) {
                localVarQueryParameter['execution_date.lt'] = (executionDateLt as any instanceof Date) ?
                    (executionDateLt as any).toISOString().substring(0,10) :
                    executionDateLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all ticker types that Massive.com has.
         * @summary Ticker Types
         * @param {ListTickerTypesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListTickerTypesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickerTypes: async (assetClass?: ListTickerTypesAssetClassEnum, locale?: ListTickerTypesLocaleEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/tickers/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (assetClass !== undefined) {
                localVarQueryParameter['asset_class'] = assetClass;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query all ticker symbols which are supported by Massive.com. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
         * @summary Tickers
         * @param {string} [ticker] Specify a ticker symbol. Defaults to empty string which queries all tickers.
         * @param {ListTickersTypeEnum} [type] Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://massive.com/docs/rest/stocks/tickers/ticker-types). Defaults to empty string which queries all types.
         * @param {ListTickersMarketEnum} [market] Filter by market type. By default all markets are included.
         * @param {string} [exchange] Specify the asset\&#39;s primary exchange Market Identifier Code (MIC) according to [ISO 10383](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges.
         * @param {string} [cusip] Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
         * @param {string} [cik] Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs.
         * @param {string} [date] Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date.
         * @param {string} [search] Search for terms within the ticker and/or company name.
         * @param {boolean} [active] Specify if the tickers returned should be actively traded on the queried date. Default is true.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {ListTickersOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 1000.
         * @param {ListTickersSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickers: async (ticker?: string, type?: ListTickersTypeEnum, market?: ListTickersMarketEnum, exchange?: string, cusip?: string, cik?: string, date?: string, search?: string, active?: boolean, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: ListTickersOrderEnum, limit?: number, sort?: ListTickersSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/reference/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (market !== undefined) {
                localVarQueryParameter['market'] = market;
            }

            if (exchange !== undefined) {
                localVarQueryParameter['exchange'] = exchange;
            }

            if (cusip !== undefined) {
                localVarQueryParameter['cusip'] = cusip;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (tickerGte !== undefined) {
                localVarQueryParameter['ticker.gte'] = tickerGte;
            }

            if (tickerGt !== undefined) {
                localVarQueryParameter['ticker.gt'] = tickerGt;
            }

            if (tickerLte !== undefined) {
                localVarQueryParameter['ticker.lte'] = tickerLte;
            }

            if (tickerLt !== undefined) {
                localVarQueryParameter['ticker.lt'] = tickerLt;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker Full Book (L2)
         * @param {string} ticker The cryptocurrency ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deprecatedGetCryptoSnapshotTickerBook(ticker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeprecatedGetCryptoSnapshotTickerBook200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deprecatedGetCryptoSnapshotTickerBook(ticker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deprecatedGetCryptoSnapshotTickerBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get historic trade ticks for a cryptocurrency pair. 
         * @summary Historic Crypto Trades
         * @param {string} from The \&quot;from\&quot; symbol of the crypto pair.
         * @param {string} to The \&quot;to\&quot; symbol of the crypto pair.
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deprecatedGetHistoricCryptoTrades(from: string, to: string, date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeprecatedGetHistoricCryptoTrades200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deprecatedGetHistoricCryptoTrades(from, to, date, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deprecatedGetHistoricCryptoTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get historic ticks for a forex currency pair. 
         * @summary Historic Forex Ticks
         * @param {string} from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
         * @param {string} to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
         * @param {string} date The date/day of the historic ticks to retrieve.
         * @param {number} [offset] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [limit] Limit the size of the response, max 10000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deprecatedGetHistoricForexQuotes(from: string, to: string, date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeprecatedGetHistoricForexQuotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deprecatedGetHistoricForexQuotes(from, to, date, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deprecatedGetHistoricForexQuotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get NBBO quotes for a given ticker symbol on a specified date. 
         * @summary Quotes (NBBO)
         * @param {string} ticker The ticker symbol we want quotes for.
         * @param {string} date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deprecatedGetHistoricStocksQuotes(ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeprecatedGetHistoricStocksQuotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deprecatedGetHistoricStocksQuotes(ticker, date, timestamp, timestampLimit, reverse, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deprecatedGetHistoricStocksQuotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a given ticker symbol on a specified date. 
         * @summary Trades
         * @param {string} ticker The ticker symbol we want trades for.
         * @param {string} date The date/day of the trades to retrieve in the format YYYY-MM-DD.
         * @param {number} [timestamp] The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
         * @param {number} [timestampLimit] The maximum timestamp allowed in the results. 
         * @param {boolean} [reverse] Reverse the order of the results. 
         * @param {number} [limit] Limit the size of the response, max 50000 and default 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deprecatedGetHistoricStocksTrades(ticker: string, date: string, timestamp?: number, timestampLimit?: number, reverse?: boolean, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<DeprecatedGetHistoricStocksTrades200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deprecatedGetHistoricStocksTrades(ticker, date, timestamp, timestampLimit, reverse, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deprecatedGetHistoricStocksTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A comprehensive database of financial analyst insights and ratings for various publicly traded companies, capturing detailed information about analyst recommendations and price targets.
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company being rated.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedGt] Filter greater than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedLt] Filter less than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [firm] The name of the research firm or investment bank issuing the rating.
         * @param {string} [firmAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [firmGt] Filter greater than the value.
         * @param {string} [firmGte] Filter greater than or equal to the value.
         * @param {string} [firmLt] Filter less than the value.
         * @param {string} [firmLte] Filter less than or equal to the value.
         * @param {string} [ratingAction] The description of the change in rating from the firm\&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
         * @param {string} [ratingActionAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [ratingActionGt] Filter greater than the value.
         * @param {string} [ratingActionGte] Filter greater than or equal to the value.
         * @param {string} [ratingActionLt] Filter less than the value.
         * @param {string} [ratingActionLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] The identifer used by Benzinga for the firm record.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaRatingId] The identifier used by Benzinga for the rating record.
         * @param {string} [benzingaRatingIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaRatingIdGt] Filter greater than the value.
         * @param {string} [benzingaRatingIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaRatingIdLt] Filter less than the value.
         * @param {string} [benzingaRatingIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;last_updated\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1AnalystInsights(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, lastUpdated?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, firm?: string, firmAnyOf?: string, firmGt?: string, firmGte?: string, firmLt?: string, firmLte?: string, ratingAction?: string, ratingActionAnyOf?: string, ratingActionGt?: string, ratingActionGte?: string, ratingActionLt?: string, ratingActionLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, benzingaRatingId?: string, benzingaRatingIdAnyOf?: string, benzingaRatingIdGt?: string, benzingaRatingIdGte?: string, benzingaRatingIdLt?: string, benzingaRatingIdLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1AnalystInsights200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1AnalystInsights(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, lastUpdated, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, firm, firmAnyOf, firmGt, firmGte, firmLt, firmLte, ratingAction, ratingActionAnyOf, ratingActionGt, ratingActionGte, ratingActionLt, ratingActionLte, benzingaFirmId, benzingaFirmIdAnyOf, benzingaFirmIdGt, benzingaFirmIdGte, benzingaFirmIdLt, benzingaFirmIdLte, benzingaRatingId, benzingaRatingIdAnyOf, benzingaRatingIdGt, benzingaRatingIdGte, benzingaRatingIdLt, benzingaRatingIdLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1AnalystInsights']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A comprehensive database of financial analysts, containing detailed performance metrics and identification information for individual analysts across various financial firms.
         * @param {string} [benzingaId] The identifier used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] The unique identifier assigned by Benzinga to the research firm or investment bank.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {string} [firmName] The name of the research firm or investment bank issuing the ratings.
         * @param {string} [firmNameAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [firmNameGt] Filter greater than the value.
         * @param {string} [firmNameGte] Filter greater than or equal to the value.
         * @param {string} [firmNameLt] Filter less than the value.
         * @param {string} [firmNameLte] Filter less than or equal to the value.
         * @param {string} [fullName] The full name of the analyst associated with the ratings.
         * @param {string} [fullNameAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fullNameGt] Filter greater than the value.
         * @param {string} [fullNameGte] Filter greater than or equal to the value.
         * @param {string} [fullNameLt] Filter less than the value.
         * @param {string} [fullNameLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;full_name\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1Analysts(benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, firmName?: string, firmNameAnyOf?: string, firmNameGt?: string, firmNameGte?: string, firmNameLt?: string, firmNameLte?: string, fullName?: string, fullNameAnyOf?: string, fullNameGt?: string, fullNameGte?: string, fullNameLt?: string, fullNameLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1Analysts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1Analysts(benzingaId, benzingaIdAnyOf, benzingaIdGt, benzingaIdGte, benzingaIdLt, benzingaIdLte, benzingaFirmId, benzingaFirmIdAnyOf, benzingaFirmIdGt, benzingaFirmIdGte, benzingaFirmIdLt, benzingaFirmIdLte, firmName, firmNameAnyOf, firmNameGt, firmNameGte, firmNameLt, firmNameLte, fullName, fullNameAnyOf, fullNameGt, fullNameGte, fullNameLt, fullNameLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1Analysts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A comprehensive financial consensus ratings table that aggregates analyst recommendations and price targets for individual stock tickers, capturing detailed rating breakdowns and statistical insights.
         * @param {string} ticker The requested ticker.
         * @param {string} [date] The date range to aggregate analyst ratings over. For example, date.gte&#x3D;2024-10-01 and date.lt&#x3D;2025-01-01 for ratings published in Q4 2024. By default, all ratings are aggregated regardless of date.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1ConsensusRatings(ticker: string, date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1ConsensusRatings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1ConsensusRatings(ticker, date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1ConsensusRatings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This table contains earnings data from Benzinga, tracking both actual and estimated financial metrics for publicly traded companies. It includes EPS and revenue figures with surprise calculations, along with metadata like fiscal periods, company identifiers, and reporting timestamps.
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company reporting earnings.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedGt] Filter greater than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedLt] Filter less than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateStatus] Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed.
         * @param {string} [dateStatusAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateStatusGt] Filter greater than the value.
         * @param {string} [dateStatusGte] Filter greater than or equal to the value.
         * @param {string} [dateStatusLt] Filter less than the value.
         * @param {string} [dateStatusLte] Filter less than or equal to the value.
         * @param {number} [epsSurprisePercent] The percentage difference between the actual and estimated EPS. Value must be a floating point number.
         * @param {string} [epsSurprisePercentAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [epsSurprisePercentGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [epsSurprisePercentLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercent] The percentage difference between the actual and estimated revenue. Value must be a floating point number.
         * @param {string} [revenueSurprisePercentAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [revenueSurprisePercentLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalYear] The fiscal year in which the earnings period falls. Value must be an integer.
         * @param {string} [fiscalYearAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be an integer.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be an integer.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [fiscalPeriod] The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY.
         * @param {string} [fiscalPeriodAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fiscalPeriodGt] Filter greater than the value.
         * @param {string} [fiscalPeriodGte] Filter greater than or equal to the value.
         * @param {string} [fiscalPeriodLt] Filter less than the value.
         * @param {string} [fiscalPeriodLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;last_updated\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1Earnings(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, dateStatus?: string, dateStatusAnyOf?: string, dateStatusGt?: string, dateStatusGte?: string, dateStatusLt?: string, dateStatusLte?: string, epsSurprisePercent?: number, epsSurprisePercentAnyOf?: string, epsSurprisePercentGt?: number, epsSurprisePercentGte?: number, epsSurprisePercentLt?: number, epsSurprisePercentLte?: number, revenueSurprisePercent?: number, revenueSurprisePercentAnyOf?: string, revenueSurprisePercentGt?: number, revenueSurprisePercentGte?: number, revenueSurprisePercentLt?: number, revenueSurprisePercentLte?: number, fiscalYear?: number, fiscalYearAnyOf?: string, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalPeriod?: string, fiscalPeriodAnyOf?: string, fiscalPeriodGt?: string, fiscalPeriodGte?: string, fiscalPeriodLt?: string, fiscalPeriodLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1Earnings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1Earnings(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, importance, importanceAnyOf, importanceGt, importanceGte, importanceLt, importanceLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, dateStatus, dateStatusAnyOf, dateStatusGt, dateStatusGte, dateStatusLt, dateStatusLte, epsSurprisePercent, epsSurprisePercentAnyOf, epsSurprisePercentGt, epsSurprisePercentGte, epsSurprisePercentLt, epsSurprisePercentLte, revenueSurprisePercent, revenueSurprisePercentAnyOf, revenueSurprisePercentGt, revenueSurprisePercentGte, revenueSurprisePercentLt, revenueSurprisePercentLte, fiscalYear, fiscalYearAnyOf, fiscalYearGt, fiscalYearGte, fiscalYearLt, fiscalYearLte, fiscalPeriod, fiscalPeriodAnyOf, fiscalPeriodGt, fiscalPeriodGte, fiscalPeriodLt, fiscalPeriodLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1Earnings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A comprehensive database of financial firms, tracking unique identifiers, names, and basic metadata for various financial institutions and research firms.
         * @param {string} [benzingaId] The identifer used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;name\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1Firms(benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1Firms200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1Firms(benzingaId, benzingaIdAnyOf, benzingaIdGt, benzingaIdGte, benzingaIdLt, benzingaIdLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1Firms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A comprehensive database of financial guidance and earnings estimates for various companies, capturing key metrics related to earnings per share (EPS) and revenue projections across different fiscal periods.
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the guidance was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company issuing guidance.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [positioning] Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are \&#39;primary\&#39; (the emphasized figure) and \&#39;secondary\&#39; (a supporting or alternate figure)
         * @param {string} [positioningAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [positioningGt] Filter greater than the value.
         * @param {string} [positioningGte] Filter greater than or equal to the value.
         * @param {string} [positioningLt] Filter less than the value.
         * @param {string} [positioningLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {string} [importanceAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {number} [fiscalYear] The fiscal year corresponding to the period for which the guidance is issued. Value must be an integer.
         * @param {string} [fiscalYearAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be an integer.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be an integer.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [fiscalPeriod] The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4.
         * @param {string} [fiscalPeriodAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [fiscalPeriodGt] Filter greater than the value.
         * @param {string} [fiscalPeriodGte] Filter greater than or equal to the value.
         * @param {string} [fiscalPeriodLt] Filter less than the value.
         * @param {string} [fiscalPeriodLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1Guidance(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, positioning?: string, positioningAnyOf?: string, positioningGt?: string, positioningGte?: string, positioningLt?: string, positioningLte?: string, importance?: number, importanceAnyOf?: string, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, fiscalYear?: number, fiscalYearAnyOf?: string, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalPeriod?: string, fiscalPeriodAnyOf?: string, fiscalPeriodGt?: string, fiscalPeriodGte?: string, fiscalPeriodLt?: string, fiscalPeriodLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1Guidance200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1Guidance(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, positioning, positioningAnyOf, positioningGt, positioningGte, positioningLt, positioningLte, importance, importanceAnyOf, importanceGt, importanceGte, importanceLt, importanceLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, fiscalYear, fiscalYearAnyOf, fiscalYearGt, fiscalYearGte, fiscalYearLt, fiscalYearLte, fiscalPeriod, fiscalPeriodAnyOf, fiscalPeriodGt, fiscalPeriodGte, fiscalPeriodLt, fiscalPeriodLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1Guidance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A comprehensive news article database from Benzinga, containing detailed information about financial news articles including metadata, content, and associated financial information.
         * @param {string} [published] The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
         * @param {string} [publishedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [publishedGt] Filter greater than the value.
         * @param {string} [publishedGte] Filter greater than or equal to the value.
         * @param {string} [publishedLt] Filter less than the value.
         * @param {string} [publishedLte] Filter less than or equal to the value.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system.
         * @param {string} [lastUpdatedAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [lastUpdatedGt] Filter greater than the value.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value.
         * @param {string} [lastUpdatedLt] Filter less than the value.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value.
         * @param {string} [tickers] Filter for arrays that contain the value.
         * @param {string} [tickersAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickersAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [channels] Filter for arrays that contain the value.
         * @param {string} [channelsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [channelsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tags] Filter for arrays that contain the value.
         * @param {string} [tagsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tagsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [author] The name of the journalist or entity that authored the news article.
         * @param {string} [authorAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [authorGt] Filter greater than the value.
         * @param {string} [authorGte] Filter greater than or equal to the value.
         * @param {string} [authorLt] Filter less than the value.
         * @param {string} [authorLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;published\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1News(published?: string, publishedAnyOf?: string, publishedGt?: string, publishedGte?: string, publishedLt?: string, publishedLte?: string, lastUpdated?: string, lastUpdatedAnyOf?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, tickers?: string, tickersAllOf?: string, tickersAnyOf?: string, channels?: string, channelsAllOf?: string, channelsAnyOf?: string, tags?: string, tagsAllOf?: string, tagsAnyOf?: string, author?: string, authorAnyOf?: string, authorGt?: string, authorGte?: string, authorLt?: string, authorLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1News200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1News(published, publishedAnyOf, publishedGt, publishedGte, publishedLt, publishedLte, lastUpdated, lastUpdatedAnyOf, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, tickers, tickersAllOf, tickersAnyOf, channels, channelsAllOf, channelsAnyOf, tags, tagsAllOf, tagsAnyOf, author, authorAnyOf, authorGt, authorGte, authorLt, authorLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1News']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This table contains analyst ratings and price target data from investment firms, tracking rating changes (upgrades, downgrades, initiates coverage, etc.) and price target adjustments for publicly traded companies. Each record includes the analyst details, company information, current and previous ratings/targets, and metadata like timestamps and Benzinga identifiers.
         * @param {string} [date] The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [ticker] The stock symbol of the company being rated.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [importance] A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
         * @param {number} [importanceGt] Filter greater than the value. Value must be an integer.
         * @param {number} [importanceGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [importanceLt] Filter less than the value. Value must be an integer.
         * @param {number} [importanceLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [lastUpdated] The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedGt] Filter greater than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedGte] Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedLt] Filter less than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastUpdatedLte] Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [ratingAction] The description of the change in rating from the firm\&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
         * @param {string} [ratingActionAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [ratingActionGt] Filter greater than the value.
         * @param {string} [ratingActionGte] Filter greater than or equal to the value.
         * @param {string} [ratingActionLt] Filter less than the value.
         * @param {string} [ratingActionLte] Filter less than or equal to the value.
         * @param {string} [priceTargetAction] The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
         * @param {string} [priceTargetActionAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [priceTargetActionGt] Filter greater than the value.
         * @param {string} [priceTargetActionGte] Filter greater than or equal to the value.
         * @param {string} [priceTargetActionLt] Filter less than the value.
         * @param {string} [priceTargetActionLte] Filter less than or equal to the value.
         * @param {string} [benzingaId] The identifer used by Benzinga for this record.
         * @param {string} [benzingaIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaIdGt] Filter greater than the value.
         * @param {string} [benzingaIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaIdLt] Filter less than the value.
         * @param {string} [benzingaIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaAnalystId] The identifer used by Benzinga for this analyst.
         * @param {string} [benzingaAnalystIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaAnalystIdGt] Filter greater than the value.
         * @param {string} [benzingaAnalystIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaAnalystIdLt] Filter less than the value.
         * @param {string} [benzingaAnalystIdLte] Filter less than or equal to the value.
         * @param {string} [benzingaFirmId] The identifer used by Benzinga for this firm.
         * @param {string} [benzingaFirmIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [benzingaFirmIdGt] Filter greater than the value.
         * @param {string} [benzingaFirmIdGte] Filter greater than or equal to the value.
         * @param {string} [benzingaFirmIdLt] Filter less than the value.
         * @param {string} [benzingaFirmIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;last_updated\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV1Ratings(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, importance?: number, importanceGt?: number, importanceGte?: number, importanceLt?: number, importanceLte?: number, lastUpdated?: string, lastUpdatedGt?: string, lastUpdatedGte?: string, lastUpdatedLt?: string, lastUpdatedLte?: string, ratingAction?: string, ratingActionAnyOf?: string, ratingActionGt?: string, ratingActionGte?: string, ratingActionLt?: string, ratingActionLte?: string, priceTargetAction?: string, priceTargetActionAnyOf?: string, priceTargetActionGt?: string, priceTargetActionGte?: string, priceTargetActionLt?: string, priceTargetActionLte?: string, benzingaId?: string, benzingaIdAnyOf?: string, benzingaIdGt?: string, benzingaIdGte?: string, benzingaIdLt?: string, benzingaIdLte?: string, benzingaAnalystId?: string, benzingaAnalystIdAnyOf?: string, benzingaAnalystIdGt?: string, benzingaAnalystIdGte?: string, benzingaAnalystIdLt?: string, benzingaAnalystIdLte?: string, benzingaFirmId?: string, benzingaFirmIdAnyOf?: string, benzingaFirmIdGt?: string, benzingaFirmIdGte?: string, benzingaFirmIdLt?: string, benzingaFirmIdLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV1Ratings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV1Ratings(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, importance, importanceGt, importanceGte, importanceLt, importanceLte, lastUpdated, lastUpdatedGt, lastUpdatedGte, lastUpdatedLt, lastUpdatedLte, ratingAction, ratingActionAnyOf, ratingActionGt, ratingActionGte, ratingActionLt, ratingActionLte, priceTargetAction, priceTargetActionAnyOf, priceTargetActionGt, priceTargetActionGte, priceTargetActionLt, priceTargetActionLte, benzingaId, benzingaIdAnyOf, benzingaIdGt, benzingaIdGte, benzingaIdLt, benzingaIdLte, benzingaAnalystId, benzingaAnalystIdAnyOf, benzingaAnalystIdGt, benzingaAnalystIdGte, benzingaAnalystIdLt, benzingaAnalystIdLte, benzingaFirmId, benzingaFirmIdAnyOf, benzingaFirmIdGt, benzingaFirmIdGte, benzingaFirmIdLt, benzingaFirmIdLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV1Ratings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A comprehensive news article database from Benzinga, containing detailed information about financial news articles including metadata, content, and associated financial information.
         * @param {string} [published] The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [publishedGt] Filter greater than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [publishedGte] Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [publishedLt] Filter less than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [publishedLte] Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [channels] Filter for arrays that contain the value.
         * @param {string} [channelsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [channelsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tags] Filter for arrays that contain the value.
         * @param {string} [tagsAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tagsAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [author] The name of the journalist or entity that authored the news article.
         * @param {string} [authorAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [authorGt] Filter greater than the value.
         * @param {string} [authorGte] Filter greater than or equal to the value.
         * @param {string} [authorLt] Filter less than the value.
         * @param {string} [authorLte] Filter less than or equal to the value.
         * @param {string} [stocks] Filter for arrays that contain the value.
         * @param {string} [stocksAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [stocksAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickers] Filter for arrays that contain the value.
         * @param {string} [tickersAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickersAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;published\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenzingaV2News(published?: string, publishedGt?: string, publishedGte?: string, publishedLt?: string, publishedLte?: string, channels?: string, channelsAllOf?: string, channelsAnyOf?: string, tags?: string, tagsAllOf?: string, tagsAnyOf?: string, author?: string, authorAnyOf?: string, authorGt?: string, authorGte?: string, authorLt?: string, authorLte?: string, stocks?: string, stocksAllOf?: string, stocksAnyOf?: string, tickers?: string, tickersAllOf?: string, tickersAnyOf?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetBenzingaV2News200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenzingaV2News(published, publishedGt, publishedGte, publishedLt, publishedLte, channels, channelsAllOf, channelsAnyOf, tags, tagsAllOf, tagsAnyOf, author, authorAnyOf, authorGt, authorGte, authorLt, authorLte, stocks, stocksAllOf, stocksAnyOf, tickers, tickersAllOf, tickersAnyOf, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBenzingaV2News']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetCryptoAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetCryptoAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoAggregates(cryptoTicker: string, multiplier: number, timespan: GetCryptoAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetCryptoAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoAggregates(cryptoTicker, multiplier, timespan, from, to, adjusted, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} cryptoTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoEMA(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoEMATimespanEnum, window?: number, seriesType?: GetCryptoEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoEMA(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoEMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} cryptoTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetCryptoMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate MACD data. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoMACD(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoMACDTimespanEnum, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetCryptoMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoMACD(cryptoTicker, timestamp, timespan, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoMACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the open, close prices of a cryptocurrency symbol on a certain day. 
         * @summary Daily Open/Close
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoOpenClose(from: string, to: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoOpenClose200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoOpenClose(from, to, date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoOpenClose']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} cryptoTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoRSI(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoRSITimespanEnum, window?: number, seriesType?: GetCryptoRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoRSI(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoRSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} cryptoTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetCryptoSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetCryptoSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetCryptoSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoSMA(cryptoTicker: string, timestamp?: string, timespan?: GetCryptoSMATimespanEnum, window?: number, seriesType?: GetCryptoSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetCryptoSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoSMA(cryptoTicker, timestamp, timespan, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoSMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current top 20 gainers or losers of the day in cryptocurrency markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetCryptoSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoSnapshotDirection(direction: GetCryptoSnapshotDirectionDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSnapshotDirection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoSnapshotDirection(direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoSnapshotDirection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker Ticker of the snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoSnapshotTicker(ticker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSnapshotTicker200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoSnapshotTicker(ticker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoSnapshotTicker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoSnapshotTickers(tickers?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSnapshotTickers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoSnapshotTickers(tickers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoSnapshotTickers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a crypto ticker symbol in a given time range.
         * @summary Trades
         * @param {string} cryptoTicker The ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetCryptoTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetCryptoTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoTrades(cryptoTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetCryptoTradesOrderEnum, limit?: number, sort?: GetCryptoTradesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoTrades200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoTrades(cryptoTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Global cryptocurrency exchanges and digital asset trading platforms, including major centralized exchanges (Coinbase, Binance, Bitfinex, etc.) that facilitate trading of cryptocurrencies and digital tokens worldwide.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCryptoV1Exchanges(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoV1Exchanges200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCryptoV1Exchanges(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCryptoV1Exchanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
         * @summary Real-time Currency Conversion
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {number} [amount] The amount to convert, with a decimal.
         * @param {GetCurrencyConversionPrecisionEnum} [precision] The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrencyConversion(from: string, to: string, amount?: number, precision?: GetCurrencyConversionPrecisionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCurrencyConversion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrencyConversion(from, to, amount, precision, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCurrencyConversion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ETF Global analytics data containing risk scores, reward metrics, and quantitative analysis for ETF composite tickers.
         * @param {string} [compositeTicker] The stock ticker symbol used to identify this ETF product on exchanges.
         * @param {string} [compositeTickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [compositeTickerGt] Filter greater than the value.
         * @param {string} [compositeTickerGte] Filter greater than or equal to the value.
         * @param {string} [compositeTickerLt] Filter less than the value.
         * @param {string} [compositeTickerLte] Filter less than or equal to the value.
         * @param {string} [processedDate] The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDate] The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {number} [riskTotalScore] ETF Global\&#39;s proprietary Red Diamond overall risk assessment score for the ETF. Value must be a floating point number.
         * @param {number} [riskTotalScoreGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [riskTotalScoreGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [riskTotalScoreLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [riskTotalScoreLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [rewardScore] ETF Global\&#39;s proprietary Green Diamond score measuring the potential reward and return prospects of the ETF. Value must be a floating point number.
         * @param {number} [rewardScoreGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [rewardScoreGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [rewardScoreLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [rewardScoreLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [quantTotalScore] ETF Global\&#39;s comprehensive quantitative analysis score combining all quantitative factors. Value must be a floating point number.
         * @param {number} [quantTotalScoreGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quantTotalScoreGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quantTotalScoreLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quantTotalScoreLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {string} [quantGrade] Letter grade summarizing the ETF\&#39;s overall quantitative assessment, where A &#x3D; 71-100, B &#x3D; 56-70, etc.
         * @param {string} [quantGradeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [quantGradeGt] Filter greater than the value.
         * @param {string} [quantGradeGte] Filter greater than or equal to the value.
         * @param {string} [quantGradeLt] Filter less than the value.
         * @param {string} [quantGradeLte] Filter less than or equal to the value.
         * @param {number} [quantCompositeTechnical] Combined technical analysis score aggregating short, intermediate, and long-term technical factors. Value must be a floating point number.
         * @param {number} [quantCompositeTechnicalGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quantCompositeTechnicalGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeTechnicalLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quantCompositeTechnicalLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeSentiment] Overall market sentiment score combining put/call ratios, short interest, and implied volatility. Value must be a floating point number.
         * @param {number} [quantCompositeSentimentGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quantCompositeSentimentGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeSentimentLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quantCompositeSentimentLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeBehavioral] Behavioral analysis score measuring investor psychology and market behavior patterns. Value must be a floating point number.
         * @param {number} [quantCompositeBehavioralGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quantCompositeBehavioralGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeBehavioralLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quantCompositeBehavioralLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeFundamental] Overall fundamental analysis score combining P/E, P/CF, P/B, and dividend yield metrics. Value must be a floating point number.
         * @param {number} [quantCompositeFundamentalGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quantCompositeFundamentalGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeFundamentalLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quantCompositeFundamentalLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeGlobal] Overall global theme score combining sector and country analysis for macro investment views. Value must be a floating point number.
         * @param {number} [quantCompositeGlobalGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quantCompositeGlobalGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeGlobalLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quantCompositeGlobalLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeQuality] Overall quality assessment score combining liquidity, diversification, and issuing firm factors. Value must be a floating point number.
         * @param {number} [quantCompositeQualityGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quantCompositeQualityGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quantCompositeQualityLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quantCompositeQualityLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEtfGlobalV1Analytics(compositeTicker?: string, compositeTickerAnyOf?: string, compositeTickerGt?: string, compositeTickerGte?: string, compositeTickerLt?: string, compositeTickerLte?: string, processedDate?: string, processedDateGt?: string, processedDateGte?: string, processedDateLt?: string, processedDateLte?: string, effectiveDate?: string, effectiveDateGt?: string, effectiveDateGte?: string, effectiveDateLt?: string, effectiveDateLte?: string, riskTotalScore?: number, riskTotalScoreGt?: number, riskTotalScoreGte?: number, riskTotalScoreLt?: number, riskTotalScoreLte?: number, rewardScore?: number, rewardScoreGt?: number, rewardScoreGte?: number, rewardScoreLt?: number, rewardScoreLte?: number, quantTotalScore?: number, quantTotalScoreGt?: number, quantTotalScoreGte?: number, quantTotalScoreLt?: number, quantTotalScoreLte?: number, quantGrade?: string, quantGradeAnyOf?: string, quantGradeGt?: string, quantGradeGte?: string, quantGradeLt?: string, quantGradeLte?: string, quantCompositeTechnical?: number, quantCompositeTechnicalGt?: number, quantCompositeTechnicalGte?: number, quantCompositeTechnicalLt?: number, quantCompositeTechnicalLte?: number, quantCompositeSentiment?: number, quantCompositeSentimentGt?: number, quantCompositeSentimentGte?: number, quantCompositeSentimentLt?: number, quantCompositeSentimentLte?: number, quantCompositeBehavioral?: number, quantCompositeBehavioralGt?: number, quantCompositeBehavioralGte?: number, quantCompositeBehavioralLt?: number, quantCompositeBehavioralLte?: number, quantCompositeFundamental?: number, quantCompositeFundamentalGt?: number, quantCompositeFundamentalGte?: number, quantCompositeFundamentalLt?: number, quantCompositeFundamentalLte?: number, quantCompositeGlobal?: number, quantCompositeGlobalGt?: number, quantCompositeGlobalGte?: number, quantCompositeGlobalLt?: number, quantCompositeGlobalLte?: number, quantCompositeQuality?: number, quantCompositeQualityGt?: number, quantCompositeQualityGte?: number, quantCompositeQualityLt?: number, quantCompositeQualityLte?: number, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetEtfGlobalV1Analytics200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEtfGlobalV1Analytics(compositeTicker, compositeTickerAnyOf, compositeTickerGt, compositeTickerGte, compositeTickerLt, compositeTickerLte, processedDate, processedDateGt, processedDateGte, processedDateLt, processedDateLte, effectiveDate, effectiveDateGt, effectiveDateGte, effectiveDateLt, effectiveDateLte, riskTotalScore, riskTotalScoreGt, riskTotalScoreGte, riskTotalScoreLt, riskTotalScoreLte, rewardScore, rewardScoreGt, rewardScoreGte, rewardScoreLt, rewardScoreLte, quantTotalScore, quantTotalScoreGt, quantTotalScoreGte, quantTotalScoreLt, quantTotalScoreLte, quantGrade, quantGradeAnyOf, quantGradeGt, quantGradeGte, quantGradeLt, quantGradeLte, quantCompositeTechnical, quantCompositeTechnicalGt, quantCompositeTechnicalGte, quantCompositeTechnicalLt, quantCompositeTechnicalLte, quantCompositeSentiment, quantCompositeSentimentGt, quantCompositeSentimentGte, quantCompositeSentimentLt, quantCompositeSentimentLte, quantCompositeBehavioral, quantCompositeBehavioralGt, quantCompositeBehavioralGte, quantCompositeBehavioralLt, quantCompositeBehavioralLte, quantCompositeFundamental, quantCompositeFundamentalGt, quantCompositeFundamentalGte, quantCompositeFundamentalLt, quantCompositeFundamentalLte, quantCompositeGlobal, quantCompositeGlobalGt, quantCompositeGlobalGte, quantCompositeGlobalLt, quantCompositeGlobalLte, quantCompositeQuality, quantCompositeQualityGt, quantCompositeQualityGte, quantCompositeQualityLt, quantCompositeQualityLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEtfGlobalV1Analytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ETF Global constituents data containing detailed information about the securities held within ETFs, including weights, market values, and security identifiers.
         * @param {string} [compositeTicker] The stock ticker symbol of the ETF that holds these constituent securities.
         * @param {string} [compositeTickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [compositeTickerGt] Filter greater than the value.
         * @param {string} [compositeTickerGte] Filter greater than or equal to the value.
         * @param {string} [compositeTickerLt] Filter less than the value.
         * @param {string} [compositeTickerLte] Filter less than or equal to the value.
         * @param {string} [constituentTicker] The stock ticker symbol of the individual security held within the ETF.
         * @param {string} [constituentTickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [constituentTickerGt] Filter greater than the value.
         * @param {string} [constituentTickerGte] Filter greater than or equal to the value.
         * @param {string} [constituentTickerLt] Filter less than the value.
         * @param {string} [constituentTickerLte] Filter less than or equal to the value.
         * @param {string} [effectiveDate] The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDate] The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [usCode] A unique identifier code for the constituent security in US markets.
         * @param {string} [usCodeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [usCodeGt] Filter greater than the value.
         * @param {string} [usCodeGte] Filter greater than or equal to the value.
         * @param {string} [usCodeLt] Filter less than the value.
         * @param {string} [usCodeLte] Filter less than or equal to the value.
         * @param {string} [isin] The International Securities Identification Number, a global standard for identifying securities.
         * @param {string} [isinAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [isinGt] Filter greater than the value.
         * @param {string} [isinGte] Filter greater than or equal to the value.
         * @param {string} [isinLt] Filter less than the value.
         * @param {string} [isinLte] Filter less than or equal to the value.
         * @param {string} [figi] The Financial Instrument Global Identifier, an open standard for uniquely identifying financial instruments.
         * @param {string} [figiAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [figiGt] Filter greater than the value.
         * @param {string} [figiGte] Filter greater than or equal to the value.
         * @param {string} [figiLt] Filter less than the value.
         * @param {string} [figiLte] Filter less than or equal to the value.
         * @param {string} [sedol] The Stock Exchange Daily Official List code, primarily used for securities trading in the UK.
         * @param {string} [sedolAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [sedolGt] Filter greater than the value.
         * @param {string} [sedolGte] Filter greater than or equal to the value.
         * @param {string} [sedolLt] Filter less than the value.
         * @param {string} [sedolLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEtfGlobalV1Constituents(compositeTicker?: string, compositeTickerAnyOf?: string, compositeTickerGt?: string, compositeTickerGte?: string, compositeTickerLt?: string, compositeTickerLte?: string, constituentTicker?: string, constituentTickerAnyOf?: string, constituentTickerGt?: string, constituentTickerGte?: string, constituentTickerLt?: string, constituentTickerLte?: string, effectiveDate?: string, effectiveDateGt?: string, effectiveDateGte?: string, effectiveDateLt?: string, effectiveDateLte?: string, processedDate?: string, processedDateGt?: string, processedDateGte?: string, processedDateLt?: string, processedDateLte?: string, usCode?: string, usCodeAnyOf?: string, usCodeGt?: string, usCodeGte?: string, usCodeLt?: string, usCodeLte?: string, isin?: string, isinAnyOf?: string, isinGt?: string, isinGte?: string, isinLt?: string, isinLte?: string, figi?: string, figiAnyOf?: string, figiGt?: string, figiGte?: string, figiLt?: string, figiLte?: string, sedol?: string, sedolAnyOf?: string, sedolGt?: string, sedolGte?: string, sedolLt?: string, sedolLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetEtfGlobalV1Constituents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEtfGlobalV1Constituents(compositeTicker, compositeTickerAnyOf, compositeTickerGt, compositeTickerGte, compositeTickerLt, compositeTickerLte, constituentTicker, constituentTickerAnyOf, constituentTickerGt, constituentTickerGte, constituentTickerLt, constituentTickerLte, effectiveDate, effectiveDateGt, effectiveDateGte, effectiveDateLt, effectiveDateLte, processedDate, processedDateGt, processedDateGte, processedDateLt, processedDateLte, usCode, usCodeAnyOf, usCodeGt, usCodeGte, usCodeLt, usCodeLte, isin, isinAnyOf, isinGt, isinGte, isinLt, isinLte, figi, figiAnyOf, figiGt, figiGte, figiLt, figiLte, sedol, sedolAnyOf, sedolGt, sedolGte, sedolLt, sedolLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEtfGlobalV1Constituents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ETF Global fund flow data containing information about ETF share movements, net asset values, and fund flow metrics.
         * @param {string} [processedDate] The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDate] The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [compositeTicker] The stock ticker symbol used to identify this ETF on exchanges.
         * @param {string} [compositeTickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [compositeTickerGt] Filter greater than the value.
         * @param {string} [compositeTickerGte] Filter greater than or equal to the value.
         * @param {string} [compositeTickerLt] Filter less than the value.
         * @param {string} [compositeTickerLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEtfGlobalV1FundFlows(processedDate?: string, processedDateGt?: string, processedDateGte?: string, processedDateLt?: string, processedDateLte?: string, effectiveDate?: string, effectiveDateGt?: string, effectiveDateGte?: string, effectiveDateLt?: string, effectiveDateLte?: string, compositeTicker?: string, compositeTickerAnyOf?: string, compositeTickerGt?: string, compositeTickerGte?: string, compositeTickerLt?: string, compositeTickerLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetEtfGlobalV1FundFlows200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEtfGlobalV1FundFlows(processedDate, processedDateGt, processedDateGte, processedDateLt, processedDateLte, effectiveDate, effectiveDateGt, effectiveDateGte, effectiveDateLt, effectiveDateLte, compositeTicker, compositeTickerAnyOf, compositeTickerGt, compositeTickerGte, compositeTickerLt, compositeTickerLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEtfGlobalV1FundFlows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ETF Global industry profile data containing comprehensive ETF metadata including financial metrics, operational details, and exposure information.
         * @param {string} [processedDate] The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDate] The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [compositeTicker] The stock ticker symbol used to identify this ETF product on exchanges.
         * @param {string} [compositeTickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [compositeTickerGt] Filter greater than the value.
         * @param {string} [compositeTickerGte] Filter greater than or equal to the value.
         * @param {string} [compositeTickerLt] Filter less than the value.
         * @param {string} [compositeTickerLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEtfGlobalV1Profiles(processedDate?: string, processedDateGt?: string, processedDateGte?: string, processedDateLt?: string, processedDateLte?: string, effectiveDate?: string, effectiveDateGt?: string, effectiveDateGte?: string, effectiveDateLt?: string, effectiveDateLte?: string, compositeTicker?: string, compositeTickerAnyOf?: string, compositeTickerGt?: string, compositeTickerGte?: string, compositeTickerLt?: string, compositeTickerLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetEtfGlobalV1Profiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEtfGlobalV1Profiles(processedDate, processedDateGt, processedDateGte, processedDateLt, processedDateLte, effectiveDate, effectiveDateGt, effectiveDateGte, effectiveDateLt, effectiveDateLte, compositeTicker, compositeTickerAnyOf, compositeTickerGt, compositeTickerGte, compositeTickerLt, compositeTickerLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEtfGlobalV1Profiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ETF Global taxonomy data containing detailed classification and categorization information for ETFs including investment strategy, methodology, and structural characteristics.
         * @param {string} [processedDate] The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [processedDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDate] The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [effectiveDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [compositeTicker] The stock ticker symbol used to identify this ETF product on exchanges.
         * @param {string} [compositeTickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [compositeTickerGt] Filter greater than the value.
         * @param {string} [compositeTickerGte] Filter greater than or equal to the value.
         * @param {string} [compositeTickerLt] Filter less than the value.
         * @param {string} [compositeTickerLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEtfGlobalV1Taxonomies(processedDate?: string, processedDateGt?: string, processedDateGte?: string, processedDateLt?: string, processedDateLte?: string, effectiveDate?: string, effectiveDateGt?: string, effectiveDateGte?: string, effectiveDateLt?: string, effectiveDateLte?: string, compositeTicker?: string, compositeTickerAnyOf?: string, compositeTickerGt?: string, compositeTickerGte?: string, compositeTickerLt?: string, compositeTickerLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetEtfGlobalV1Taxonomies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEtfGlobalV1Taxonomies(processedDate, processedDateGt, processedDateGte, processedDateLt, processedDateLte, effectiveDate, effectiveDateGt, effectiveDateGte, effectiveDateLt, effectiveDateLte, compositeTicker, compositeTickerAnyOf, compositeTickerGt, compositeTickerGte, compositeTickerLt, compositeTickerLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEtfGlobalV1Taxonomies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
         * @summary Ticker Events
         * @param {string} id Identifier of an asset, which can be a Ticker, CUSIP, or Composite FIGI. Specify a case-sensitive  ticker symbol (e.g. AAPL for Apple Inc). When provided a ticker, events for the entity currently  represented by that ticker are returned. To find events for entities previously associated with a  ticker, obtain the relevant identifier using the [Ticker Details Endpoint](https://massive.com/docs/rest/stocks/tickers/ticker-overview).
         * @param {string} [types] A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(id: string, types?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(id, types, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A table tracking inflation and price indices, including Consumer Price Index (CPI) and Personal Consumption Expenditures (PCE) metrics over time.
         * @param {string} [date] Calendar date of the observation (YYYYMMDD).
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFedV1Inflation(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFedV1Inflation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFedV1Inflation(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFedV1Inflation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A table tracking inflation expectations from both market-based and economic model perspectives across different time horizons.
         * @param {string} [date] Calendar date of the observation (YYYYMMDD).
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFedV1InflationExpectations(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFedV1InflationExpectations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFedV1InflationExpectations(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFedV1InflationExpectations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A record of U.S. Treasury bond yields across various maturity periods, tracking historical interest rates from short-term to long-term government securities.
         * @param {string} [date] Calendar date of the yield observation (YYYY-MM-DD).
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFedV1TreasuryYields(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFedV1TreasuryYields200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFedV1TreasuryYields(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFedV1TreasuryYields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for a forex pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetForexAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetForexAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexAggregates(forexTicker: string, multiplier: number, timespan: GetForexAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetForexAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexAggregates(forexTicker, multiplier, timespan, from, to, adjusted, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} fxTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetForexEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexEMA(fxTicker: string, timestamp?: string, timespan?: GetForexEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexEMA(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexEMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} fxTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetForexMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexMACD(fxTicker: string, timestamp?: string, timespan?: GetForexMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetForexMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexMACD(fxTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexMACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get BBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (BBO)
         * @param {string} fxTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetForexQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetForexQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexQuotes(fxTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetForexQuotesOrderEnum, limit?: number, sort?: GetForexQuotesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetForexQuotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexQuotes(fxTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexQuotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} fxTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetForexRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexRSI(fxTicker: string, timestamp?: string, timespan?: GetForexRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexRSI(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexRSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} fxTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetForexSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetForexSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetForexSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexSMA(fxTicker: string, timestamp?: string, timespan?: GetForexSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetForexSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetForexSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexSMA(fxTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexSMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current top 20 gainers or losers of the day in forex markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetForexSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexSnapshotDirection(direction: GetForexSnapshotDirectionDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetForexSnapshotTickers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexSnapshotDirection(direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexSnapshotDirection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded currency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {string} ticker The forex ticker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexSnapshotTicker(ticker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetForexSnapshotTicker200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexSnapshotTicker(ticker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexSnapshotTicker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded forex symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexSnapshotTickers(tickers?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetForexSnapshotTickers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexSnapshotTickers(tickers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexSnapshotTickers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Global foreign exchange (FX) trading venues and market infrastructure, including electronic trading platforms, banks, and other institutions facilitating currency pair trading worldwide.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForexV1Exchanges(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetForexV1Exchanges200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForexV1Exchanges(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getForexV1Exchanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregates for a contract in a given time range.
         * @summary Aggregates
         * @param {string} ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
         * @param {string} [resolution] This sets the size of the aggregate windows. It accepts custom values that specify the granularity and the duration of the window. For example: 15mins, 30secs, 12hours, or 7days. There are maximum allowable candle sizes. For example, you can request \&quot;1min\&quot; to \&quot;59mins\&quot;, but after that you will need to use \&quot;1hr\&quot;. If you make a request for a candle size that is not supported, we will return a 400 \&quot;Bad Request - resolution value is not allowed.\&quot;
         * @param {string} [windowStart] Specifies the start time of the aggregate (OHLC) candles you want returned (YYYY-MM-DD date or nanosecond Unix timestamp). How it works - If not provided, the API returns the most recent candles available, up to the limit you set. - If provided, the value determines which candle(s) to return. The timestamp or date is snapped to the start time of the matching candle interval. - You can use comparison operators to form ranges:   - &#x60;window_start.gte&#x60;  greater than or equal to   - &#x60;window_start.gt&#x60;  greater than   - &#x60;window_start.lte&#x60;  less than or equal to   - &#x60;window_start.lt&#x60;  less than  Examples 1. Most recent minute candles    &#x60;/vX/aggs/ESU5?resolution&#x3D;1min&amp;limit&#x3D;5&#x60;  2. Daily candle for August 5, 2025    &#x60;/vX/aggs/ESU5?resolution&#x3D;1day&amp;window_start&#x3D;2025-08-05&#x60;  3. Daily candles from July 131, 2025    &#x60;/vX/aggs/ESU5?resolution&#x3D;1day&amp;window_start.gte&#x3D;2025-07-01&amp;window_start.lte&#x3D;2025-07-31&#x60;  4. 1,000 one-second candles after a specific timestamp    &#x60;/vX/aggs/ESU5?resolution&#x3D;1sec&amp;window_start.gt&#x3D;1751409877000000000&amp;limit&#x3D;1000&#x60;
         * @param {number} [limit] The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1).
         * @param {string} [windowStartGte] Range by window_start.
         * @param {string} [windowStartGt] Range by window_start.
         * @param {string} [windowStartLte] Range by window_start.
         * @param {string} [windowStartLt] Range by window_start.
         * @param {GetFuturesAggregatesSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesAggregates(ticker: string, resolution?: string, windowStart?: string, limit?: number, windowStartGte?: string, windowStartGt?: string, windowStartLte?: string, windowStartLt?: string, sort?: GetFuturesAggregatesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFuturesAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesAggregates(ticker, resolution, windowStart, limit, windowStartGte, windowStartGt, windowStartLte, windowStartLt, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFuturesAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The Contract Details endpoint returns the details for a single contract at a specific point in time.
         * @summary Contract Details
         * @param {string} ticker The ticker symbol of the contract to retrieve.
         * @param {string} [asOf] The point-in-time of the data to be retrieved. Note that the contract data returned for a given date represents the state of that contract on that day. A date in the format YYYY-MM-DD (default&#x3D;today).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesContractDetails(ticker: string, asOf?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFuturesContractDetails200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesContractDetails(ticker, asOf, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFuturesContractDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The Contracts endpoint returns a list of futures contracts. This endpoint can be used to query for contracts based on a variety of parameters, including the contract\'s ticker, product code, first trade date, last trade date, and whether or not the contract was active on a given date.
         * @summary Contracts
         * @param {string} [productCode] A unique identifier for the Product a Contract belongs to. Note that multiple contracts can belong to the same product.
         * @param {string} [firstTradeDate] The first day that a contract was tradeable. A date with the format YYYY-MM-DD.
         * @param {string} [lastTradeDate] The last day that the contract was tradeable. A date with the format YYYY-MM-DD.
         * @param {string} [asOf] Specify the point-in-time for which you want to retrieve information. Note that the contract data returned for a given date is the state of that contract as of that day. A date in the format YYYY-MM-DD (default&#x3D;today).
         * @param {GetFuturesContractsActiveEnum} [active] Filter for contracts based on whether or not they were tradeable at the given point in time. For example, if the date queried is greater-than or equal-to a contract\&#39;s \&#39;first_trade_date\&#39; and less-than-or-equal-to its \&#39;last_trade_date\&#39;, then the contract was active. If the date queried is greater-than-or-equal-to the contract\&#39;s \&#39;last_trade_date\&#39; or less-than-or-equal-to its \&#39;first_trade_date\&#39;, then the contract was inactive.
         * @param {GetFuturesContractsTypeEnum} [type] The type of contract, one of \&quot;all\&quot;, \&quot;single\&quot;, or \&quot;combo\&quot; (default&#x3D;all).
         * @param {number} [limit] The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1).
         * @param {GetFuturesContractsSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesContracts(productCode?: string, firstTradeDate?: string, lastTradeDate?: string, asOf?: string, active?: GetFuturesContractsActiveEnum, type?: GetFuturesContractsTypeEnum, limit?: number, sort?: GetFuturesContractsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFuturesContracts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesContracts(productCode, firstTradeDate, lastTradeDate, asOf, active, type, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFuturesContracts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The Trading-Date Based Futures Schedules API provides detailed trading schedules for all products on a specific day. This API allows you to retrieve detailed information about trading sessions, including market events like preopen, open, and closed, along with their precise timestamps.
         * @summary Daily Schedules
         * @param {string} [sessionEndDate] The session end date for the schedules (also known as the trading date). This is the day in CT for which the user wants to retrieve data. If left blank, this value defaults to \&#39;today\&#39; in Central Time. e.g. If a request is made from Pacific Time on \&#39;2025-01-01\&#39; at 11:00 pm with no \&#39;session_end_date\&#39; a default value of &#x60;2025-01-02&#x60; will be used.
         * @param {string} [tradingVenue] The trading venue (MIC) of the exchange for the schedules.
         * @param {number} [limit] The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1).
         * @param {GetFuturesDailySchedulesSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesDailySchedules(sessionEndDate?: string, tradingVenue?: string, limit?: number, sort?: GetFuturesDailySchedulesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFuturesDailySchedules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesDailySchedules(sessionEndDate, tradingVenue, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFuturesDailySchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The market status endpoint returns the current status of the futures market for the given product code(s).
         * @summary Market Status
         * @param {string} [productCodeAnyOf] The product code(s) to return market statuses for.  Multiple product codes can be specified by separating them with a comma. Currently, the limit is 250 product codes.
         * @param {string} [productCode] The product code to return market statuses for.
         * @param {number} [limit] The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1).
         * @param {GetFuturesMarketStatusesSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesMarketStatuses(productCodeAnyOf?: string, productCode?: string, limit?: number, sort?: GetFuturesMarketStatusesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFuturesMarketStatuses200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesMarketStatuses(productCodeAnyOf, productCode, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFuturesMarketStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The Product Details endpoint returns the details for a single product as of a specific day.
         * @summary Product Details
         * @param {string} productCode The unique identifier for a product.
         * @param {GetFuturesProductDetailsTypeEnum} [type] The type of product to return. One of \&quot;single\&quot; or \&quot;combo\&quot; (default&#x3D;single).
         * @param {string} [asOf] A date string in the format YYYY-MM-DD. Note that the data returned is the state of this product\&#39;s data at that point-in-time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesProductDetails(productCode: string, type?: GetFuturesProductDetailsTypeEnum, asOf?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFuturesProductDetails200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesProductDetails(productCode, type, asOf, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFuturesProductDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The Product-Specific Futures Schedules API provides detailed trading schedules for a specific futures product. This API allows you to query schedules for a single product across a range of dates. Users can access comprehensive information about trading sessions, including market events such as preopen, open, and closed, along with their precise timestamps.
         * @summary Product Schedules
         * @param {string} productCode The product code for the futures product.
         * @param {string} [sessionEndDate] The date on which the schedule\&#39;s trading day ended (sometimes referred to as trading date). Defaults to today. Formatted as &#x60;YYYY-MM-DD&#x60;. Note that although there is no time component the day is assumed to be that day in Central Time.
         * @param {number} [limit] The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1).
         * @param {string} [sessionEndDateGte] Range by session_end_date.
         * @param {string} [sessionEndDateGt] Range by session_end_date.
         * @param {string} [sessionEndDateLte] Range by session_end_date.
         * @param {string} [sessionEndDateLt] Range by session_end_date.
         * @param {GetFuturesProductSchedulesSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesProductSchedules(productCode: string, sessionEndDate?: string, limit?: number, sessionEndDateGte?: string, sessionEndDateGt?: string, sessionEndDateLte?: string, sessionEndDateLt?: string, sort?: GetFuturesProductSchedulesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFuturesProductSchedules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesProductSchedules(productCode, sessionEndDate, limit, sessionEndDateGte, sessionEndDateGt, sessionEndDateLte, sessionEndDateLt, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFuturesProductSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The Products endpoint returns a list of futures products. This endpoint can be used to query for products based on a variety of parameters, including by the product\'s name, exchange, sector, sub-sector, asset class, asset sub-class, and type.
         * @summary Products
         * @param {string} [name] Search for products by Product Name. This parameter supports an exact match, while a name-contains search can be performed using the &#x60;name.search&#x60; parameter. Note that the search is case-sensitive.
         * @param {string} [asOf] A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day (default&#x3D;today).
         * @param {string} [tradingVenue] The trading venue (MIC) for the exchange on which the products trades.
         * @param {GetFuturesProductsSectorEnum} [sector] The sector to which the products belong.
         * @param {GetFuturesProductsSubSectorEnum} [subSector] The sub-sector to which the products belong.
         * @param {GetFuturesProductsAssetClassEnum} [assetClass] The asset class to which the products belong.
         * @param {GetFuturesProductsAssetSubClassEnum} [assetSubClass] The asset sub-class to which the products belong.
         * @param {GetFuturesProductsTypeEnum} [type] The type of products to return. One of \&quot;all\&quot;, \&quot;single\&quot;, or \&quot;combo\&quot; (default&#x3D;all).
         * @param {number} [limit] The number of results to return per page (default&#x3D;100, maximum&#x3D;1000, minimum&#x3D;1).
         * @param {string} [nameSearch] Search by name.
         * @param {GetFuturesProductsSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesProducts(name?: string, asOf?: string, tradingVenue?: string, sector?: GetFuturesProductsSectorEnum, subSector?: GetFuturesProductsSubSectorEnum, assetClass?: GetFuturesProductsAssetClassEnum, assetSubClass?: GetFuturesProductsAssetSubClassEnum, type?: GetFuturesProductsTypeEnum, limit?: number, nameSearch?: string, sort?: GetFuturesProductsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFuturesProducts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesProducts(name, asOf, tradingVenue, sector, subSector, assetClass, assetSubClass, type, limit, nameSearch, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFuturesProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get quotes for a contract in a given time range.
         * @summary Quotes
         * @param {string} ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [sessionEndDate] Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
         * @param {number} [limit] The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1).
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {string} [sessionEndDateGte] Range by session_end_date.
         * @param {string} [sessionEndDateGt] Range by session_end_date.
         * @param {string} [sessionEndDateLte] Range by session_end_date.
         * @param {string} [sessionEndDateLt] Range by session_end_date.
         * @param {GetFuturesQuotesSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesQuotes(ticker: string, timestamp?: string, sessionEndDate?: string, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, sessionEndDateGte?: string, sessionEndDateGt?: string, sessionEndDateLte?: string, sessionEndDateLt?: string, sort?: GetFuturesQuotesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFuturesQuotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesQuotes(ticker, timestamp, sessionEndDate, limit, timestampGte, timestampGt, timestampLte, timestampLt, sessionEndDateGte, sessionEndDateGt, sessionEndDateLte, sessionEndDateLt, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFuturesQuotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a contract in a given time range.
         * @summary Trades
         * @param {string} ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [sessionEndDate] Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
         * @param {number} [limit] The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1).
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {string} [sessionEndDateGte] Range by session_end_date.
         * @param {string} [sessionEndDateGt] Range by session_end_date.
         * @param {string} [sessionEndDateLte] Range by session_end_date.
         * @param {string} [sessionEndDateLt] Range by session_end_date.
         * @param {GetFuturesTradesSortEnum} [sort] Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesTrades(ticker: string, timestamp?: string, sessionEndDate?: string, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, sessionEndDateGte?: string, sessionEndDateGt?: string, sessionEndDateLte?: string, sessionEndDateLt?: string, sort?: GetFuturesTradesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFuturesTrades200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesTrades(ticker, timestamp, sessionEndDate, limit, timestampGte, timestampGt, timestampLte, timestampLt, sessionEndDateGte, sessionEndDateGt, sessionEndDateLte, sessionEndDateLt, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFuturesTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information about a specific futures contract identified by its ticker. The response includes comprehensive attributes such as active status, trade dates, days to maturity, exchange code, order quantity limits, settlement date, tick sizes, and other key metrics. Users can specify a point-in-time (as_of) to view the contract\'s state on a particular date, supporting informed trading decisions and historical analysis.  Use Cases: Contract specification, historical product checks, system integration, trading decision support.
         * @summary futures_contracts_v1 API
         * @param {string} [date] A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day (default&#x3D;today). Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [productCode] The unique identifier for the product.
         * @param {string} [productCodeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [productCodeGt] Filter greater than the value.
         * @param {string} [productCodeGte] Filter greater than or equal to the value.
         * @param {string} [productCodeLt] Filter less than the value.
         * @param {string} [productCodeLte] Filter less than or equal to the value.
         * @param {string} [ticker] The ticker for the contract.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [active] The contract is still trading. Value must be \&#39;true\&#39;, \&#39;false\&#39;, \&#39;1\&#39; or \&#39;0\&#39;.
         * @param {string} [type] The type of product, one of \&#39;single\&#39; or \&#39;combo\&#39;.
         * @param {string} [typeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [typeGt] Filter greater than the value.
         * @param {string} [typeGte] Filter greater than or equal to the value.
         * @param {string} [typeLt] Filter less than the value.
         * @param {string} [typeLte] Filter less than or equal to the value.
         * @param {string} [firstTradeDate] The first date the contract trades. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [firstTradeDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [firstTradeDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [firstTradeDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [firstTradeDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastTradeDate] The last date the contract trades. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastTradeDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastTradeDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastTradeDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [lastTradeDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;1000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;product_code\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesVXContractsNew(date?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, productCode?: string, productCodeAnyOf?: string, productCodeGt?: string, productCodeGte?: string, productCodeLt?: string, productCodeLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, active?: string, type?: string, typeAnyOf?: string, typeGt?: string, typeGte?: string, typeLt?: string, typeLte?: string, firstTradeDate?: string, firstTradeDateGt?: string, firstTradeDateGte?: string, firstTradeDateLt?: string, firstTradeDateLte?: string, lastTradeDate?: string, lastTradeDateGt?: string, lastTradeDateGte?: string, lastTradeDateLt?: string, lastTradeDateLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFuturesVXContractsNew200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesVXContractsNew(date, dateGt, dateGte, dateLt, dateLte, productCode, productCodeAnyOf, productCodeGt, productCodeGte, productCodeLt, productCodeLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, active, type, typeAnyOf, typeGt, typeGte, typeLt, typeLte, firstTradeDate, firstTradeDateGt, firstTradeDateGte, firstTradeDateLt, firstTradeDateLte, lastTradeDate, lastTradeDateGt, lastTradeDateGte, lastTradeDateLt, lastTradeDateLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFuturesVXContractsNew']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * US futures exchanges and trading venues including major derivatives exchanges (CME, CBOT, NYMEX, COMEX) and other futures market infrastructure for commodity, financial, and other derivative contract trading.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesVXExchanges(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFuturesVXExchanges200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesVXExchanges(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFuturesVXExchanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information about a single futures product as of a specified date, including its asset class, exchange code, full product name, settlement details, pricing quotation, sector classifications, and unit of measure. Optional parameters such as product type (single or combo) and as_of allow you to capture the products state on a specific day, providing essential context for trading decisions and system integrations.  Use Cases: Product specification, historical product checks, risk management, trading system integration.
         * @summary futures_products_v1 API
         * @param {string} [name] The full name of the product.
         * @param {string} [nameAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [nameGt] Filter greater than the value.
         * @param {string} [nameGte] Filter greater than or equal to the value.
         * @param {string} [nameLt] Filter less than the value.
         * @param {string} [nameLte] Filter less than or equal to the value.
         * @param {string} [productCode] The unique identifier for the product.
         * @param {string} [productCodeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [productCodeGt] Filter greater than the value.
         * @param {string} [productCodeGte] Filter greater than or equal to the value.
         * @param {string} [productCodeLt] Filter less than the value.
         * @param {string} [productCodeLte] Filter less than or equal to the value.
         * @param {string} [date] A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day (default&#x3D;today). Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [dateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [sector] The sector to which the product belongs.
         * @param {string} [sectorAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [sectorGt] Filter greater than the value.
         * @param {string} [sectorGte] Filter greater than or equal to the value.
         * @param {string} [sectorLt] Filter less than the value.
         * @param {string} [sectorLte] Filter less than or equal to the value.
         * @param {string} [subSector] The sub-sector to which the product belongs.
         * @param {string} [subSectorAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [subSectorGt] Filter greater than the value.
         * @param {string} [subSectorGte] Filter greater than or equal to the value.
         * @param {string} [subSectorLt] Filter less than the value.
         * @param {string} [subSectorLte] Filter less than or equal to the value.
         * @param {string} [assetClass] The asset class to which the product belongs.
         * @param {string} [assetClassAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [assetClassGt] Filter greater than the value.
         * @param {string} [assetClassGte] Filter greater than or equal to the value.
         * @param {string} [assetClassLt] Filter less than the value.
         * @param {string} [assetClassLte] Filter less than or equal to the value.
         * @param {string} [assetSubClass] The asset sub-class to which the product belongs.
         * @param {string} [assetSubClassAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [assetSubClassGt] Filter greater than the value.
         * @param {string} [assetSubClassGte] Filter greater than or equal to the value.
         * @param {string} [assetSubClassLt] Filter less than the value.
         * @param {string} [assetSubClassLte] Filter less than or equal to the value.
         * @param {string} [type] The type of product, one of \&#39;single\&#39; or \&#39;combo\&#39;.
         * @param {string} [typeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [typeGt] Filter greater than the value.
         * @param {string} [typeGte] Filter greater than or equal to the value.
         * @param {string} [typeLt] Filter less than the value.
         * @param {string} [typeLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesVXProductsNew(name?: string, nameAnyOf?: string, nameGt?: string, nameGte?: string, nameLt?: string, nameLte?: string, productCode?: string, productCodeAnyOf?: string, productCodeGt?: string, productCodeGte?: string, productCodeLt?: string, productCodeLte?: string, date?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, sector?: string, sectorAnyOf?: string, sectorGt?: string, sectorGte?: string, sectorLt?: string, sectorLte?: string, subSector?: string, subSectorAnyOf?: string, subSectorGt?: string, subSectorGte?: string, subSectorLt?: string, subSectorLte?: string, assetClass?: string, assetClassAnyOf?: string, assetClassGt?: string, assetClassGte?: string, assetClassLt?: string, assetClassLte?: string, assetSubClass?: string, assetSubClassAnyOf?: string, assetSubClassGt?: string, assetSubClassGte?: string, assetSubClassLt?: string, assetSubClassLte?: string, type?: string, typeAnyOf?: string, typeGt?: string, typeGte?: string, typeLt?: string, typeLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFuturesVXProductsNew200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesVXProductsNew(name, nameAnyOf, nameGt, nameGte, nameLt, nameLte, productCode, productCodeAnyOf, productCodeGt, productCodeGte, productCodeLt, productCodeLte, date, dateGt, dateGte, dateLt, dateLte, sector, sectorAnyOf, sectorGt, sectorGte, sectorLt, sectorLte, subSector, subSectorAnyOf, subSectorGt, subSectorGte, subSectorLt, subSectorLte, assetClass, assetClassAnyOf, assetClassGt, assetClassGte, assetClassLt, assetClassLte, assetSubClass, assetSubClassAnyOf, assetSubClassGt, assetSubClassGte, assetSubClassLt, assetSubClassLte, type, typeAnyOf, typeGt, typeGte, typeLt, typeLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFuturesVXProductsNew']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a snapshot of the most recent futures contract data.
         * @summary futures_snapshot_v1 API
         * @param {string} [productCode] The code for the contracts\&#39; underlying product.
         * @param {string} [productCodeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [productCodeGt] Filter greater than the value.
         * @param {string} [productCodeGte] Filter greater than or equal to the value.
         * @param {string} [productCodeLt] Filter less than the value.
         * @param {string} [productCodeLte] Filter less than or equal to the value.
         * @param {string} [ticker] The futures contract identifier, including the base symbol and contract expiration (e.g., ESZ24 for the December 2024 S&amp;P 500 E-mini contract).
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuturesVXSnapshot(productCode?: string, productCodeAnyOf?: string, productCodeGt?: string, productCodeGte?: string, productCodeLt?: string, productCodeLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetFuturesVXSnapshot200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuturesVXSnapshot(productCode, productCodeAnyOf, productCodeGt, productCodeGte, productCodeLt, productCodeLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getFuturesVXSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupedCryptoAggregates(date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetGroupedCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupedCryptoAggregates(date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGroupedCryptoAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupedForexAggregates(date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetGroupedCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupedForexAggregates(date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGroupedForexAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
         * @summary Grouped Daily (Bars)
         * @param {string} date The beginning date for the aggregate window.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupedStocksAggregates(date: string, adjusted?: boolean, includeOtc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetGroupedStocksAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupedStocksAggregates(date, adjusted, includeOtc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGroupedStocksAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for an index over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetIndicesAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicesAggregates(indicesTicker: string, multiplier: number, timespan: GetIndicesAggregatesTimespanEnum, from: string, to: string, sort?: GetIndicesAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPreviousIndicesAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicesAggregates(indicesTicker, multiplier, timespan, from, to, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIndicesAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} indicesTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetIndicesEMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicesEMA(indicesTicker: string, timestamp?: string, timespan?: GetIndicesEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicesEMA(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIndicesEMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} indicesTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetIndicesMACDSeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close values to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicesMACD(indicesTicker: string, timestamp?: string, timespan?: GetIndicesMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetIndicesMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicesMACD(indicesTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIndicesMACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the open, close and afterhours values of a index symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicesOpenClose(indicesTicker: string, date: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetIndicesOpenClose200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicesOpenClose(indicesTicker, date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIndicesOpenClose']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} indicesTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetIndicesRSISeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close values to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicesRSI(indicesTicker: string, timestamp?: string, timespan?: GetIndicesRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicesRSI(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIndicesRSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} indicesTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetIndicesSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetIndicesSMASeriesTypeEnum} [seriesType] The value in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetIndicesSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicesSMA(indicesTicker: string, timestamp?: string, timespan?: GetIndicesSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetIndicesSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetIndicesSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicesSMA(indicesTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIndicesSMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Snapshot of indices data for said tickers
         * @summary Indices Snapshot
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {GetIndicesSnapshotOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetIndicesSnapshotSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicesSnapshot(tickerAnyOf?: string, ticker?: string, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: GetIndicesSnapshotOrderEnum, limit?: number, sort?: GetIndicesSnapshotSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetIndicesSnapshot200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicesSnapshot(tickerAnyOf, ticker, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIndicesSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the last trade tick for a cryptocurrency pair.
         * @summary Last Trade for a Crypto Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastCryptoTrade(from: string, to: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetLastCryptoTrade200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastCryptoTrade(from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLastCryptoTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the last quote tick for a forex currency pair.
         * @summary Last Quote for a Currency Pair
         * @param {string} from The \&quot;from\&quot; symbol of the pair.
         * @param {string} to The \&quot;to\&quot; symbol of the pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastCurrencyQuote(from: string, to: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetLastCurrencyQuote200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastCurrencyQuote(from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLastCurrencyQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most recent trade for a given options contract.
         * @summary Last Trade
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastOptionsTrade(optionsTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetLastOptionsTrade200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastOptionsTrade(optionsTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLastOptionsTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most recent NBBO (Quote) tick for a given stock.
         * @summary Last Quote
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastStocksQuote(stocksTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetLastStocksQuote200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastStocksQuote(stocksTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLastStocksQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most recent trade for a given stock.
         * @summary Last Trade
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastStocksTrade(stocksTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetLastOptionsTrade200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastStocksTrade(stocksTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLastStocksTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get upcoming market holidays and their open/close times.
         * @summary Market Holidays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketHolidays(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<Array<GetMarketHolidays200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketHolidays(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMarketHolidays']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current trading status of the exchanges and overall financial markets.
         * @summary Market Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetMarketStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMarketStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the snapshot of an option contract for a stock equity.
         * @summary Option Contract
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {string} optionContract The option contract identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionContract(underlyingAsset: string, optionContract: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionContract200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionContract(underlyingAsset, optionContract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for an option contract over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetOptionsAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetOptionsAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsAggregates(optionsTicker: string, multiplier: number, timespan: GetOptionsAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetOptionsAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsAggregates(optionsTicker, multiplier, timespan, from, to, adjusted, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the snapshot of all options contracts for an underlying ticker.
         * @summary Options Chain
         * @param {string} underlyingAsset The underlying ticker symbol of the option contract.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {GetOptionsChainContractTypeEnum} [contractType] Query by the type of contract.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {GetOptionsChainOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetOptionsChainSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsChain(underlyingAsset: string, strikePrice?: number, expirationDate?: string, contractType?: GetOptionsChainContractTypeEnum, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, order?: GetOptionsChainOrderEnum, limit?: number, sort?: GetOptionsChainSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionsChain200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsChain(underlyingAsset, strikePrice, expirationDate, contractType, strikePriceGte, strikePriceGt, strikePriceLte, strikePriceLt, expirationDateGte, expirationDateGt, expirationDateLte, expirationDateLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsChain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an options contract
         * @summary Options Contract
         * @param {string} optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://massive.com/blog/how-to-read-a-stock-options-ticker/).
         * @param {string} [asOf] Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsContract(optionsTicker: string, asOf?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionsContract200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsContract(optionsTicker, asOf, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} optionsTicker The ticker symbol for which to get exponential moving average (EMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetOptionsEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsEMA(optionsTicker: string, timestamp?: string, timespan?: GetOptionsEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsEMA(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsEMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} optionsTicker The ticker symbol for which to get MACD data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetOptionsMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsMACD(optionsTicker: string, timestamp?: string, timespan?: GetOptionsMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetOptionsMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsMACD(optionsTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsMACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the open, close and afterhours prices of an options contract on a certain date. 
         * @summary Daily Open/Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsOpenClose(optionsTicker: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionsOpenClose200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsOpenClose(optionsTicker, date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsOpenClose']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get quotes for an options ticker symbol in a given time range.
         * @summary Quotes
         * @param {string} optionsTicker The ticker symbol to get quotes for.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetOptionsQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetOptionsQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsQuotes(optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetOptionsQuotesOrderEnum, limit?: number, sort?: GetOptionsQuotesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionsQuotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsQuotes(optionsTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsQuotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} optionsTicker The ticker symbol for which to get relative strength index (RSI) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetOptionsRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsRSI(optionsTicker: string, timestamp?: string, timespan?: GetOptionsRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsRSI(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsRSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} optionsTicker The ticker symbol for which to get simple moving average (SMA) data.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetOptionsSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetOptionsSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetOptionsSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsSMA(optionsTicker: string, timestamp?: string, timespan?: GetOptionsSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetOptionsSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetOptionsSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsSMA(optionsTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsSMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for an options ticker symbol in a given time range.
         * @summary Trades
         * @param {string} optionsTicker The options ticker symbol to get trades for.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetOptionsTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetOptionsTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsTrades(optionsTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetOptionsTradesOrderEnum, limit?: number, sort?: GetOptionsTradesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionsTrades200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsTrades(optionsTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * US options exchanges and trading venues including traditional options exchanges (CBOE, ISE, etc.), Securities Information Processors (SIP), and other options market infrastructure for derivatives trading.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsV1Exchanges(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionsV1Exchanges200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsV1Exchanges(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getOptionsV1Exchanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
         * @summary Previous Close
         * @param {string} cryptoTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreviousCryptoAggregates(cryptoTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPreviousCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreviousCryptoAggregates(cryptoTicker, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getPreviousCryptoAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified forex pair. 
         * @summary Previous Close
         * @param {string} forexTicker The ticker symbol of the currency pair.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreviousForexAggregates(forexTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPreviousForexAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreviousForexAggregates(forexTicker, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getPreviousForexAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified index. 
         * @summary Previous Close
         * @param {string} indicesTicker The ticker symbol of Index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreviousIndicesAggregates(indicesTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetPreviousIndicesAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreviousIndicesAggregates(indicesTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getPreviousIndicesAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified option contract. 
         * @summary Previous Close
         * @param {string} optionsTicker The ticker symbol of the options contract.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreviousOptionsAggregates(optionsTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreviousOptionsAggregates(optionsTicker, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getPreviousOptionsAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified stock ticker. 
         * @summary Previous Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreviousStocksAggregates(stocksTicker: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreviousStocksAggregates(stocksTicker, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getPreviousStocksAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of tickers related to the queried ticker based on News and Returns data.
         * @summary Related Companies
         * @param {string} ticker The ticker symbol to search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelatedCompanies(ticker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetRelatedCompanies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelatedCompanies(ticker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRelatedCompanies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
         * @summary Summaries
         * @param {string} [tickerAnyOf] Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://massive.com/docs/rest/stocks/tickers/all-tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnapshotSummary(tickerAnyOf?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetSnapshotSummary200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnapshotSummary(tickerAnyOf, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSnapshotSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get snapshots for assets of all types
         * @summary Universal Snapshot
         * @param {string} [ticker] Search a range of tickers lexicographically.
         * @param {GetSnapshotsTypeEnum} [type] Query by the type of asset.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [tickerAnyOf] Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. 
         * @param {GetSnapshotsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 250.
         * @param {GetSnapshotsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnapshots(ticker?: string, type?: GetSnapshotsTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, tickerAnyOf?: string, order?: GetSnapshotsOrderEnum, limit?: number, sort?: GetSnapshotsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetSnapshots200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnapshots(ticker, type, tickerGte, tickerGt, tickerLte, tickerLt, tickerAnyOf, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSnapshots']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregate bars for a stock over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {number} multiplier The size of the timespan multiplier.
         * @param {GetStocksAggregatesTimespanEnum} timespan The size of the time window.
         * @param {string} from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {string} to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {GetStocksAggregatesSortEnum} [sort] Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
         * @param {number} [limit] Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksAggregates(stocksTicker: string, multiplier: number, timespan: GetStocksAggregatesTimespanEnum, from: string, to: string, adjusted?: boolean, sort?: GetStocksAggregatesSortEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksAggregates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksAggregates(stocksTicker, multiplier, timespan, from, to, adjusted, sort, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksAggregates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksEMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetStocksEMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksEMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksEMA(stockTicker: string, timestamp?: string, timespan?: GetStocksEMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksEMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksEMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoEMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksEMA(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksEMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A comprehensive financial dataset containing quarterly and annual balance sheet data for public companies. Includes detailed asset, liability, and equity positions representing the company\'s financial position at specific points in time. Balance sheet data represents point-in-time snapshots rather than cumulative flows, showing what the company owns, owes, and shareholders\' equity as of each period end date.
         * @param {string} [cik] The company\&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a company\&#39;s CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
         * @param {string} [cikAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [cikGt] Filter greater than the value.
         * @param {string} [cikGte] Filter greater than or equal to the value.
         * @param {string} [cikLt] Filter less than the value.
         * @param {string} [cikLte] Filter less than or equal to the value.
         * @param {string} [tickers] Filter for arrays that contain the value.
         * @param {string} [tickersAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickersAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [periodEnd] The last date of the reporting period, representing the specific point in time when the balance sheet snapshot was taken. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDate] The date when the financial statement was filed with the SEC. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {number} [fiscalYear] The fiscal year for the reporting period. Value must be a floating point number.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalQuarter] The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number.
         * @param {number} [fiscalQuarterGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {string} [timeframe] The reporting period type. Possible values include: quarterly, annual.
         * @param {string} [timeframeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [timeframeGt] Filter greater than the value.
         * @param {string} [timeframeGte] Filter greater than or equal to the value.
         * @param {string} [timeframeLt] Filter less than the value.
         * @param {string} [timeframeLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;period_end\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksFinancialsV1BalanceSheets(cik?: string, cikAnyOf?: string, cikGt?: string, cikGte?: string, cikLt?: string, cikLte?: string, tickers?: string, tickersAllOf?: string, tickersAnyOf?: string, periodEnd?: string, periodEndGt?: string, periodEndGte?: string, periodEndLt?: string, periodEndLte?: string, filingDate?: string, filingDateGt?: string, filingDateGte?: string, filingDateLt?: string, filingDateLte?: string, fiscalYear?: number, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalQuarter?: number, fiscalQuarterGt?: number, fiscalQuarterGte?: number, fiscalQuarterLt?: number, fiscalQuarterLte?: number, timeframe?: string, timeframeAnyOf?: string, timeframeGt?: string, timeframeGte?: string, timeframeLt?: string, timeframeLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksFinancialsV1BalanceSheets200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksFinancialsV1BalanceSheets(cik, cikAnyOf, cikGt, cikGte, cikLt, cikLte, tickers, tickersAllOf, tickersAnyOf, periodEnd, periodEndGt, periodEndGte, periodEndLt, periodEndLte, filingDate, filingDateGt, filingDateGte, filingDateLt, filingDateLte, fiscalYear, fiscalYearGt, fiscalYearGte, fiscalYearLt, fiscalYearLte, fiscalQuarter, fiscalQuarterGt, fiscalQuarterGte, fiscalQuarterLt, fiscalQuarterLte, timeframe, timeframeAnyOf, timeframeGt, timeframeGte, timeframeLt, timeframeLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksFinancialsV1BalanceSheets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A comprehensive financial dataset containing quarterly, annual, and trailing twelve-month cash flow statement data for public companies. Includes detailed operating, investing, and financing cash flows with proper TTM calculations that sum all cash flow components over four quarters. TTM records are validated to ensure exactly four distinct quarters spanning 250-400 days for accurate trailing twelve-month cash flow analysis.
         * @param {string} [cik] The company\&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
         * @param {string} [cikAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [cikGt] Filter greater than the value.
         * @param {string} [cikGte] Filter greater than or equal to the value.
         * @param {string} [cikLt] Filter less than the value.
         * @param {string} [cikLte] Filter less than or equal to the value.
         * @param {string} [periodEnd] The last date of the reporting period (formatted as YYYY-MM-DD). Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDate] The date when the financial statement was filed with the SEC. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [tickers] Filter for arrays that contain the value.
         * @param {string} [tickersAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickersAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {number} [fiscalYear] The fiscal year for the reporting period. Value must be a floating point number.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalQuarter] The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number.
         * @param {number} [fiscalQuarterGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {string} [timeframe] The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months.
         * @param {string} [timeframeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [timeframeGt] Filter greater than the value.
         * @param {string} [timeframeGte] Filter greater than or equal to the value.
         * @param {string} [timeframeLt] Filter less than the value.
         * @param {string} [timeframeLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;period_end\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksFinancialsV1CashFlowStatements(cik?: string, cikAnyOf?: string, cikGt?: string, cikGte?: string, cikLt?: string, cikLte?: string, periodEnd?: string, periodEndGt?: string, periodEndGte?: string, periodEndLt?: string, periodEndLte?: string, filingDate?: string, filingDateGt?: string, filingDateGte?: string, filingDateLt?: string, filingDateLte?: string, tickers?: string, tickersAllOf?: string, tickersAnyOf?: string, fiscalYear?: number, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalQuarter?: number, fiscalQuarterGt?: number, fiscalQuarterGte?: number, fiscalQuarterLt?: number, fiscalQuarterLte?: number, timeframe?: string, timeframeAnyOf?: string, timeframeGt?: string, timeframeGte?: string, timeframeLt?: string, timeframeLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksFinancialsV1CashFlowStatements200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksFinancialsV1CashFlowStatements(cik, cikAnyOf, cikGt, cikGte, cikLt, cikLte, periodEnd, periodEndGt, periodEndGte, periodEndLt, periodEndLte, filingDate, filingDateGt, filingDateGte, filingDateLt, filingDateLte, tickers, tickersAllOf, tickersAnyOf, fiscalYear, fiscalYearGt, fiscalYearGte, fiscalYearLt, fiscalYearLte, fiscalQuarter, fiscalQuarterGt, fiscalQuarterGte, fiscalQuarterLt, fiscalQuarterLte, timeframe, timeframeAnyOf, timeframeGt, timeframeGte, timeframeLt, timeframeLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksFinancialsV1CashFlowStatements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A comprehensive database of income statement financial data for public companies, including key metrics such as revenue, expenses, and net income for various reporting periods.
         * @param {string} [cik] The company\&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
         * @param {string} [cikAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [cikGt] Filter greater than the value.
         * @param {string} [cikGte] Filter greater than or equal to the value.
         * @param {string} [cikLt] Filter less than the value.
         * @param {string} [cikLte] Filter less than or equal to the value.
         * @param {string} [tickers] Filter for arrays that contain the value.
         * @param {string} [tickersAllOf] Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickersAnyOf] Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [periodEnd] The last date of the reporting period (formatted as YYYY-MM-DD). Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [periodEndLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDate] The date when the financial statement was filed with the SEC. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [filingDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {number} [fiscalYear] The fiscal year for the reporting period. Value must be a floating point number.
         * @param {number} [fiscalYearGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [fiscalYearGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalYearLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [fiscalYearLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalQuarter] The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number.
         * @param {number} [fiscalQuarterGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [fiscalQuarterLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {string} [timeframe] The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months.
         * @param {string} [timeframeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [timeframeGt] Filter greater than the value.
         * @param {string} [timeframeGte] Filter greater than or equal to the value.
         * @param {string} [timeframeLt] Filter less than the value.
         * @param {string} [timeframeLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;period_end\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksFinancialsV1IncomeStatements(cik?: string, cikAnyOf?: string, cikGt?: string, cikGte?: string, cikLt?: string, cikLte?: string, tickers?: string, tickersAllOf?: string, tickersAnyOf?: string, periodEnd?: string, periodEndGt?: string, periodEndGte?: string, periodEndLt?: string, periodEndLte?: string, filingDate?: string, filingDateGt?: string, filingDateGte?: string, filingDateLt?: string, filingDateLte?: string, fiscalYear?: number, fiscalYearGt?: number, fiscalYearGte?: number, fiscalYearLt?: number, fiscalYearLte?: number, fiscalQuarter?: number, fiscalQuarterGt?: number, fiscalQuarterGte?: number, fiscalQuarterLt?: number, fiscalQuarterLte?: number, timeframe?: string, timeframeAnyOf?: string, timeframeGt?: string, timeframeGte?: string, timeframeLt?: string, timeframeLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksFinancialsV1IncomeStatements200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksFinancialsV1IncomeStatements(cik, cikAnyOf, cikGt, cikGte, cikLt, cikLte, tickers, tickersAllOf, tickersAnyOf, periodEnd, periodEndGt, periodEndGte, periodEndLt, periodEndLte, filingDate, filingDateGt, filingDateGte, filingDateLt, filingDateLte, fiscalYear, fiscalYearGt, fiscalYearGte, fiscalYearLt, fiscalYearLte, fiscalQuarter, fiscalQuarterGt, fiscalQuarterGte, fiscalQuarterLt, fiscalQuarterLte, timeframe, timeframeAnyOf, timeframeGt, timeframeGte, timeframeLt, timeframeLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksFinancialsV1IncomeStatements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A comprehensive financial ratios dataset providing key valuation, profitability, liquidity, and leverage metrics for public companies. Combines data from income statements, balance sheets, and cash flow statements with daily stock prices to calculate ratios on a daily basis. Uses trailing twelve months (TTM) data for income/cash flow metrics and quarterly data for balance sheet items. Fundamental data updates are applied starting from each filing\'s period end date. Market cap calculations use point-in-time shares outstanding for historical accuracy.
         * @param {string} [ticker] Stock ticker symbol for the company.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [cik] Central Index Key (CIK) number assigned by the SEC to identify the company.
         * @param {string} [cikAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [cikGt] Filter greater than the value.
         * @param {string} [cikGte] Filter greater than or equal to the value.
         * @param {string} [cikLt] Filter less than the value.
         * @param {string} [cikLte] Filter less than or equal to the value.
         * @param {number} [price] Stock price used in ratio calculations, typically the closing price for the given date. Value must be a floating point number.
         * @param {number} [priceGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [priceGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [priceLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [priceLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [averageVolume] Average trading volume over the last 30 trading days, providing context for liquidity. Value must be a floating point number.
         * @param {number} [averageVolumeGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [averageVolumeGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [averageVolumeLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [averageVolumeLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [marketCap] Market capitalization, calculated as stock price multiplied by total shares outstanding. Value must be a floating point number.
         * @param {number} [marketCapGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [marketCapGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [marketCapLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [marketCapLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [earningsPerShare] Earnings per share, calculated as net income available to common shareholders divided by weighted shares outstanding. Value must be a floating point number.
         * @param {number} [earningsPerShareGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [earningsPerShareGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [earningsPerShareLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [earningsPerShareLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToEarnings] Price-to-earnings ratio, calculated as stock price divided by earnings per share. Only calculated when earnings per share is positive. Value must be a floating point number.
         * @param {number} [priceToEarningsGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [priceToEarningsGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToEarningsLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [priceToEarningsLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToBook] Price-to-book ratio, calculated as stock price divided by book value per share, comparing market value to book value. Value must be a floating point number.
         * @param {number} [priceToBookGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [priceToBookGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToBookLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [priceToBookLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToSales] Price-to-sales ratio, calculated as stock price divided by revenue per share, measuring valuation relative to sales. Value must be a floating point number.
         * @param {number} [priceToSalesGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [priceToSalesGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToSalesLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [priceToSalesLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToCashFlow] Price-to-cash-flow ratio, calculated as stock price divided by operating cash flow per share. Only calculated when operating cash flow per share is positive. Value must be a floating point number.
         * @param {number} [priceToCashFlowGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [priceToCashFlowGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToCashFlowLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [priceToCashFlowLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToFreeCashFlow] Price-to-free-cash-flow ratio, calculated as stock price divided by free cash flow per share. Only calculated when free cash flow per share is positive. Value must be a floating point number.
         * @param {number} [priceToFreeCashFlowGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [priceToFreeCashFlowGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [priceToFreeCashFlowLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [priceToFreeCashFlowLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [dividendYield] Dividend yield, calculated as annual dividends per share divided by stock price, measuring the income return on investment. Value must be a floating point number.
         * @param {number} [dividendYieldGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [dividendYieldGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [dividendYieldLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [dividendYieldLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [returnOnAssets] Return on assets ratio, calculated as net income divided by total assets, measuring how efficiently a company uses its assets to generate profit. Value must be a floating point number.
         * @param {number} [returnOnAssetsGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [returnOnAssetsGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [returnOnAssetsLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [returnOnAssetsLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [returnOnEquity] Return on equity ratio, calculated as net income divided by total shareholders\&#39; equity, measuring profitability relative to shareholders\&#39; equity. Value must be a floating point number.
         * @param {number} [returnOnEquityGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [returnOnEquityGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [returnOnEquityLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [returnOnEquityLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [debtToEquity] Debt-to-equity ratio, calculated as total debt (current debt plus long-term debt) divided by total shareholders\&#39; equity, measuring financial leverage. Value must be a floating point number.
         * @param {number} [debtToEquityGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [debtToEquityGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [debtToEquityLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [debtToEquityLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [current] Current ratio, calculated as total current assets divided by total current liabilities, measuring short-term liquidity. Value must be a floating point number.
         * @param {number} [currentGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [currentGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [currentLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [currentLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [quick] Quick ratio (acid-test ratio), calculated as (current assets minus inventories) divided by current liabilities, measuring immediate liquidity. Value must be a floating point number.
         * @param {number} [quickGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [quickGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [quickLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [quickLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [cash] Cash ratio, calculated as cash and cash equivalents divided by current liabilities, measuring the most liquid form of liquidity coverage. Value must be a floating point number.
         * @param {number} [cashGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [cashGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [cashLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [cashLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [evToSales] Enterprise value to sales ratio, calculated as enterprise value divided by revenue, measuring company valuation relative to sales. Value must be a floating point number.
         * @param {number} [evToSalesGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [evToSalesGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [evToSalesLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [evToSalesLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [evToEbitda] Enterprise value to EBITDA ratio, calculated as enterprise value divided by EBITDA, measuring company valuation relative to earnings before interest, taxes, depreciation, and amortization. Value must be a floating point number.
         * @param {number} [evToEbitdaGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [evToEbitdaGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [evToEbitdaLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [evToEbitdaLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [enterpriseValue] Enterprise value, calculated as market capitalization plus total debt minus cash and cash equivalents, representing total company value. Value must be a floating point number.
         * @param {number} [enterpriseValueGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [enterpriseValueGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [enterpriseValueLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [enterpriseValueLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [freeCashFlow] Free cash flow, calculated as operating cash flow minus capital expenditures (purchase of property, plant, and equipment). Value must be a floating point number.
         * @param {number} [freeCashFlowGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [freeCashFlowGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [freeCashFlowLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [freeCashFlowLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksFinancialsV1Ratios(ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, cik?: string, cikAnyOf?: string, cikGt?: string, cikGte?: string, cikLt?: string, cikLte?: string, price?: number, priceGt?: number, priceGte?: number, priceLt?: number, priceLte?: number, averageVolume?: number, averageVolumeGt?: number, averageVolumeGte?: number, averageVolumeLt?: number, averageVolumeLte?: number, marketCap?: number, marketCapGt?: number, marketCapGte?: number, marketCapLt?: number, marketCapLte?: number, earningsPerShare?: number, earningsPerShareGt?: number, earningsPerShareGte?: number, earningsPerShareLt?: number, earningsPerShareLte?: number, priceToEarnings?: number, priceToEarningsGt?: number, priceToEarningsGte?: number, priceToEarningsLt?: number, priceToEarningsLte?: number, priceToBook?: number, priceToBookGt?: number, priceToBookGte?: number, priceToBookLt?: number, priceToBookLte?: number, priceToSales?: number, priceToSalesGt?: number, priceToSalesGte?: number, priceToSalesLt?: number, priceToSalesLte?: number, priceToCashFlow?: number, priceToCashFlowGt?: number, priceToCashFlowGte?: number, priceToCashFlowLt?: number, priceToCashFlowLte?: number, priceToFreeCashFlow?: number, priceToFreeCashFlowGt?: number, priceToFreeCashFlowGte?: number, priceToFreeCashFlowLt?: number, priceToFreeCashFlowLte?: number, dividendYield?: number, dividendYieldGt?: number, dividendYieldGte?: number, dividendYieldLt?: number, dividendYieldLte?: number, returnOnAssets?: number, returnOnAssetsGt?: number, returnOnAssetsGte?: number, returnOnAssetsLt?: number, returnOnAssetsLte?: number, returnOnEquity?: number, returnOnEquityGt?: number, returnOnEquityGte?: number, returnOnEquityLt?: number, returnOnEquityLte?: number, debtToEquity?: number, debtToEquityGt?: number, debtToEquityGte?: number, debtToEquityLt?: number, debtToEquityLte?: number, current?: number, currentGt?: number, currentGte?: number, currentLt?: number, currentLte?: number, quick?: number, quickGt?: number, quickGte?: number, quickLt?: number, quickLte?: number, cash?: number, cashGt?: number, cashGte?: number, cashLt?: number, cashLte?: number, evToSales?: number, evToSalesGt?: number, evToSalesGte?: number, evToSalesLt?: number, evToSalesLte?: number, evToEbitda?: number, evToEbitdaGt?: number, evToEbitdaGte?: number, evToEbitdaLt?: number, evToEbitdaLte?: number, enterpriseValue?: number, enterpriseValueGt?: number, enterpriseValueGte?: number, enterpriseValueLt?: number, enterpriseValueLte?: number, freeCashFlow?: number, freeCashFlowGt?: number, freeCashFlowGte?: number, freeCashFlowLt?: number, freeCashFlowLte?: number, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksFinancialsV1Ratios200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksFinancialsV1Ratios(ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, cik, cikAnyOf, cikGt, cikGte, cikLt, cikLte, price, priceGt, priceGte, priceLt, priceLte, averageVolume, averageVolumeGt, averageVolumeGte, averageVolumeLt, averageVolumeLte, marketCap, marketCapGt, marketCapGte, marketCapLt, marketCapLte, earningsPerShare, earningsPerShareGt, earningsPerShareGte, earningsPerShareLt, earningsPerShareLte, priceToEarnings, priceToEarningsGt, priceToEarningsGte, priceToEarningsLt, priceToEarningsLte, priceToBook, priceToBookGt, priceToBookGte, priceToBookLt, priceToBookLte, priceToSales, priceToSalesGt, priceToSalesGte, priceToSalesLt, priceToSalesLte, priceToCashFlow, priceToCashFlowGt, priceToCashFlowGte, priceToCashFlowLt, priceToCashFlowLte, priceToFreeCashFlow, priceToFreeCashFlowGt, priceToFreeCashFlowGte, priceToFreeCashFlowLt, priceToFreeCashFlowLte, dividendYield, dividendYieldGt, dividendYieldGte, dividendYieldLt, dividendYieldLte, returnOnAssets, returnOnAssetsGt, returnOnAssetsGte, returnOnAssetsLt, returnOnAssetsLte, returnOnEquity, returnOnEquityGt, returnOnEquityGte, returnOnEquityLt, returnOnEquityLte, debtToEquity, debtToEquityGt, debtToEquityGte, debtToEquityLt, debtToEquityLte, current, currentGt, currentGte, currentLt, currentLte, quick, quickGt, quickGte, quickLt, quickLte, cash, cashGt, cashGte, cashLt, cashLte, evToSales, evToSalesGt, evToSalesGte, evToSalesLt, evToSalesLte, evToEbitda, evToEbitdaGt, evToEbitdaGte, evToEbitdaLt, evToEbitdaLte, enterpriseValue, enterpriseValueGt, enterpriseValueGte, enterpriseValueLt, enterpriseValueLte, freeCashFlow, freeCashFlowGt, freeCashFlowGte, freeCashFlowLt, freeCashFlowLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksFinancialsV1Ratios']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksMACDTimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [shortWindow] The short window size used to calculate MACD data.
         * @param {number} [longWindow] The long window size used to calculate MACD data.
         * @param {number} [signalWindow] The window size used to calculate the MACD signal line.
         * @param {GetStocksMACDSeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksMACDOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksMACD(stockTicker: string, timestamp?: string, timespan?: GetStocksMACDTimespanEnum, adjusted?: boolean, shortWindow?: number, longWindow?: number, signalWindow?: number, seriesType?: GetStocksMACDSeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksMACDOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoMACD200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksMACD(stockTicker, timestamp, timespan, adjusted, shortWindow, longWindow, signalWindow, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksMACD']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the open, close and afterhours prices of a stock symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} date The date of the requested open/close in the format YYYY-MM-DD.
         * @param {boolean} [adjusted] Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksOpenClose(stocksTicker: string, date: string, adjusted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetOptionsOpenClose200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksOpenClose(stocksTicker, date, adjusted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksOpenClose']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get NBBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (NBBO)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetStocksQuotesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetStocksQuotesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksQuotes(stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetStocksQuotesOrderEnum, limit?: number, sort?: GetStocksQuotesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksQuotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksQuotes(stockTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksQuotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksRSITimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the relative strength index (RSI).
         * @param {GetStocksRSISeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksRSIOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksRSI(stockTicker: string, timestamp?: string, timespan?: GetStocksRSITimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksRSISeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksRSIOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoRSI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksRSI(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksRSI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {string} stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
         * @param {GetStocksSMATimespanEnum} [timespan] The size of the aggregate time window.
         * @param {boolean} [adjusted] Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
         * @param {number} [window] The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
         * @param {GetStocksSMASeriesTypeEnum} [seriesType] The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
         * @param {boolean} [expandUnderlying] Whether or not to include the aggregates used to calculate this indicator in the response.
         * @param {GetStocksSMAOrderEnum} [order] The order in which to return the results, ordered by timestamp.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 5000
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksSMA(stockTicker: string, timestamp?: string, timespan?: GetStocksSMATimespanEnum, adjusted?: boolean, window?: number, seriesType?: GetStocksSMASeriesTypeEnum, expandUnderlying?: boolean, order?: GetStocksSMAOrderEnum, limit?: number, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetCryptoSMA200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksSMA(stockTicker, timestamp, timespan, adjusted, window, seriesType, expandUnderlying, order, limit, timestampGte, timestampGt, timestampLte, timestampLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksSMA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. This output will only include tickers with a trading volume of 10,000 or more. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {GetStocksSnapshotDirectionDirectionEnum} direction The direction of the snapshot results to return. 
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksSnapshotDirection(direction: GetStocksSnapshotDirectionDirectionEnum, includeOtc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksSnapshotDirection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksSnapshotDirection(direction, includeOtc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksSnapshotDirection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most up-to-date market data for a single traded stock ticker. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary Ticker
         * @param {string} stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksSnapshotTicker(stocksTicker: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksSnapshotTicker200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksSnapshotTicker(stocksTicker, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksSnapshotTicker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most up-to-date market data for all traded stock symbols. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {Array<string>} [tickers] A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers.
         * @param {boolean} [includeOtc] Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksSnapshotTickers(tickers?: Array<string>, includeOtc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksSnapshotTickers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksSnapshotTickers(tickers, includeOtc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksSnapshotTickers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades for a ticker symbol in a given time range.
         * @summary Trades
         * @param {string} stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [timestamp] Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
         * @param {string} [timestampGte] Range by timestamp.
         * @param {string} [timestampGt] Range by timestamp.
         * @param {string} [timestampLte] Range by timestamp.
         * @param {string} [timestampLt] Range by timestamp.
         * @param {GetStocksTradesOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 1000 and max is 50000.
         * @param {GetStocksTradesSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksTrades(stockTicker: string, timestamp?: string, timestampGte?: string, timestampGt?: string, timestampLte?: string, timestampLt?: string, order?: GetStocksTradesOrderEnum, limit?: number, sort?: GetStocksTradesSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksTrades200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksTrades(stockTicker, timestamp, timestampGte, timestampGt, timestampLte, timestampLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Contains historical dividend payment records for US stocks with split-adjusted amounts and historical adjustment factors for price normalization.
         * @param {string} [ticker] Stock symbol for the company issuing the dividend
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [exDividendDate] Date when the stock begins trading without the dividend value Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [exDividendDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [exDividendDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [exDividendDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [exDividendDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {number} [frequency] How many times per year this dividend is expected to occur. A value of 0 means the distribution is non-recurring or irregular (e.g., special, supplemental, or a one-off dividend). Other possible values include 1 (annual), 2 (semi-annual), 3 (trimester), 4 (quarterly), 12 (monthly), 24 (bi-monthly), 26 (bi-weekly), 52 (weekly), and 365 (daily) depending on the issuer\&#39;s declared or inferred payout cadence. Value must be an integer.
         * @param {number} [frequencyGt] Filter greater than the value. Value must be an integer.
         * @param {number} [frequencyGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [frequencyLt] Filter less than the value. Value must be an integer.
         * @param {number} [frequencyLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [distributionType] Classification describing the nature of this dividend\&#39;s recurrence pattern: recurring (paid on a regular schedule), special (one-time or commemorative), supplemental (extra beyond the regular schedule), irregular (unpredictable or non-recurring), unknown (cannot be classified from available data)
         * @param {string} [distributionTypeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [distributionTypeGt] Filter greater than the value.
         * @param {string} [distributionTypeGte] Filter greater than or equal to the value.
         * @param {string} [distributionTypeLt] Filter less than the value.
         * @param {string} [distributionTypeLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksV1Dividends(ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, exDividendDate?: string, exDividendDateGt?: string, exDividendDateGte?: string, exDividendDateLt?: string, exDividendDateLte?: string, frequency?: number, frequencyGt?: number, frequencyGte?: number, frequencyLt?: number, frequencyLte?: number, distributionType?: string, distributionTypeAnyOf?: string, distributionTypeGt?: string, distributionTypeGte?: string, distributionTypeLt?: string, distributionTypeLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksV1Dividends200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksV1Dividends(ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, exDividendDate, exDividendDateGt, exDividendDateGte, exDividendDateLt, exDividendDateLte, frequency, frequencyGt, frequencyGte, frequencyLt, frequencyLte, distributionType, distributionTypeAnyOf, distributionTypeGt, distributionTypeGte, distributionTypeLt, distributionTypeLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksV1Dividends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * US stock exchanges, trading venues, and reporting facilities including exchanges (NYSE, Nasdaq), Trade Reporting Facilities (TRF), Securities Information Processors (SIP), and OTC Reporting Facilities (ORF) for equity trading.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksV1Exchanges(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksV1Exchanges200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksV1Exchanges(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksV1Exchanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Comprehensive FINRA short interest data that tracks the short selling metrics for securities on a specific settlement date.
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {number} [daysToCover] Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume. Value must be a floating point number.
         * @param {string} [daysToCoverAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [daysToCoverGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [daysToCoverGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [daysToCoverLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [daysToCoverLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {string} [settlementDate] The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
         * @param {string} [settlementDateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [settlementDateGt] Filter greater than the value.
         * @param {string} [settlementDateGte] Filter greater than or equal to the value.
         * @param {string} [settlementDateLt] Filter less than the value.
         * @param {string} [settlementDateLte] Filter less than or equal to the value.
         * @param {number} [avgDailyVolume] The average daily trading volume for the stock over a specified period, typically used to contextualize short interest. Value must be an integer.
         * @param {string} [avgDailyVolumeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [avgDailyVolumeGt] Filter greater than the value. Value must be an integer.
         * @param {number} [avgDailyVolumeGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [avgDailyVolumeLt] Filter less than the value. Value must be an integer.
         * @param {number} [avgDailyVolumeLte] Filter less than or equal to the value. Value must be an integer.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;10\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksV1ShortInterest(ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, daysToCover?: number, daysToCoverAnyOf?: string, daysToCoverGt?: number, daysToCoverGte?: number, daysToCoverLt?: number, daysToCoverLte?: number, settlementDate?: string, settlementDateAnyOf?: string, settlementDateGt?: string, settlementDateGte?: string, settlementDateLt?: string, settlementDateLte?: string, avgDailyVolume?: number, avgDailyVolumeAnyOf?: string, avgDailyVolumeGt?: number, avgDailyVolumeGte?: number, avgDailyVolumeLt?: number, avgDailyVolumeLte?: number, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksV1ShortInterest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksV1ShortInterest(ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, daysToCover, daysToCoverAnyOf, daysToCoverGt, daysToCoverGte, daysToCoverLt, daysToCoverLte, settlementDate, settlementDateAnyOf, settlementDateGt, settlementDateGte, settlementDateLt, settlementDateLte, avgDailyVolume, avgDailyVolumeAnyOf, avgDailyVolumeGt, avgDailyVolumeGte, avgDailyVolumeLt, avgDailyVolumeLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksV1ShortInterest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Contains short selling volume for different stock tickers, capturing total trading volume, short sale details, and breakdown by different trading platforms.
         * @param {string} [ticker] The primary ticker symbol for the stock.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [date] The date of trade activity reported in the format YYYY-MM-DD
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {number} [shortVolumeRatio] The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100. Value must be a floating point number.
         * @param {string} [shortVolumeRatioAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
         * @param {number} [shortVolumeRatioGt] Filter greater than the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioGte] Filter greater than or equal to the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioLt] Filter less than the value. Value must be a floating point number.
         * @param {number} [shortVolumeRatioLte] Filter less than or equal to the value. Value must be a floating point number.
         * @param {number} [totalVolume] Total reported volume across all venues for the ticker on the given date. Value must be an integer.
         * @param {string} [totalVolumeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
         * @param {number} [totalVolumeGt] Filter greater than the value. Value must be an integer.
         * @param {number} [totalVolumeGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [totalVolumeLt] Filter less than the value. Value must be an integer.
         * @param {number} [totalVolumeLte] Filter less than or equal to the value. Value must be an integer.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;10\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksV1ShortVolume(ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, shortVolumeRatio?: number, shortVolumeRatioAnyOf?: string, shortVolumeRatioGt?: number, shortVolumeRatioGte?: number, shortVolumeRatioLt?: number, shortVolumeRatioLte?: number, totalVolume?: number, totalVolumeAnyOf?: string, totalVolumeGt?: number, totalVolumeGte?: number, totalVolumeLt?: number, totalVolumeLte?: number, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksV1ShortVolume200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksV1ShortVolume(ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, shortVolumeRatio, shortVolumeRatioAnyOf, shortVolumeRatioGt, shortVolumeRatioGte, shortVolumeRatioLt, shortVolumeRatioLte, totalVolume, totalVolumeAnyOf, totalVolumeGt, totalVolumeGte, totalVolumeLt, totalVolumeLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksV1ShortVolume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Contains historical stock split and reverse split events for US equities with historical adjustment factors for price normalization.
         * @param {string} [ticker] Stock symbol for the company that executed the split
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [executionDate] Date when the stock split was applied and shares adjusted Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [executionDateGt] Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [executionDateGte] Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [executionDateLt] Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [executionDateLte] Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
         * @param {string} [adjustmentType] Classification of the share-change event. Possible values include: forward_split (share count increases), reverse_split (share count decreases), stock_dividend (shares issued as a dividend)
         * @param {string} [adjustmentTypeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [adjustmentTypeGt] Filter greater than the value.
         * @param {string} [adjustmentTypeGte] Filter greater than or equal to the value.
         * @param {string} [adjustmentTypeLt] Filter less than the value.
         * @param {string} [adjustmentTypeLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;execution_date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStocksV1Splits(ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, executionDate?: string, executionDateGt?: string, executionDateGte?: string, executionDateLt?: string, executionDateLte?: string, adjustmentType?: string, adjustmentTypeAnyOf?: string, adjustmentTypeGt?: string, adjustmentTypeGte?: string, adjustmentTypeLt?: string, adjustmentTypeLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetStocksV1Splits200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStocksV1Splits(ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, executionDate, executionDateGt, executionDateGte, executionDateLt, executionDateLte, adjustmentType, adjustmentTypeAnyOf, adjustmentTypeGt, adjustmentTypeGte, adjustmentTypeLt, adjustmentTypeLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStocksV1Splits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a single ticker supported by Massive.com. This response will have detailed information about the ticker and the company behind it.
         * @summary Ticker Details v3
         * @param {string} ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [date] Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicker(ticker: string, date?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetTicker200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicker(ticker, date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getTicker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Contains corporate events and announcements for publicly traded companies, including earnings releases, conferences, dividends, and business updates sourced from TMX.
         * @param {string} [date] Scheduled date of the corporate event, formatted as YYYY-MM-DD.
         * @param {string} [dateAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [dateGt] Filter greater than the value.
         * @param {string} [dateGte] Filter greater than or equal to the value.
         * @param {string} [dateLt] Filter less than the value.
         * @param {string} [dateLte] Filter less than or equal to the value.
         * @param {string} [type] The normalized type of corporate event. Possible values include: analyst_day, business_update, capital_markets_day, conference, dividend, earnings_announcement_date, earnings_conference_call, earnings_results_announcement, forum, interim_statement, other_interim_announcement, production_update, research_and_development_day, seminar, shareholder_meeting, sales_update, stock_split, summit, service_level_update, tradeshow, company_travel, and workshop.
         * @param {string} [typeAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [typeGt] Filter greater than the value.
         * @param {string} [typeGte] Filter greater than or equal to the value.
         * @param {string} [typeLt] Filter less than the value.
         * @param {string} [typeLte] Filter less than or equal to the value.
         * @param {string} [status] The current status of the event. Possible values include: approved, canceled, confirmed, historical, pending_approval, postponed, and unconfirmed.
         * @param {string} [statusAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [statusGt] Filter greater than the value.
         * @param {string} [statusGte] Filter greater than or equal to the value.
         * @param {string} [statusLt] Filter less than the value.
         * @param {string} [statusLte] Filter less than or equal to the value.
         * @param {string} [ticker] The company\&#39;s stock symbol.
         * @param {string} [tickerAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tickerGt] Filter greater than the value.
         * @param {string} [tickerGte] Filter greater than or equal to the value.
         * @param {string} [tickerLt] Filter less than the value.
         * @param {string} [tickerLte] Filter less than or equal to the value.
         * @param {string} [isin] Standard international identifier for the company\&#39;s common stock.
         * @param {string} [isinAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [isinGt] Filter greater than the value.
         * @param {string} [isinGte] Filter greater than or equal to the value.
         * @param {string} [isinLt] Filter less than the value.
         * @param {string} [isinLte] Filter less than or equal to the value.
         * @param {string} [tradingVenue] MIC (Market Identifier Code) of the exchange where the company\&#39;s stock is listed.
         * @param {string} [tradingVenueAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tradingVenueGt] Filter greater than the value.
         * @param {string} [tradingVenueGte] Filter greater than or equal to the value.
         * @param {string} [tradingVenueLt] Filter less than the value.
         * @param {string} [tradingVenueLte] Filter less than or equal to the value.
         * @param {number} [tmxCompanyId] Unique numeric identifier for the company used by TMX. Value must be an integer.
         * @param {number} [tmxCompanyIdGt] Filter greater than the value. Value must be an integer.
         * @param {number} [tmxCompanyIdGte] Filter greater than or equal to the value. Value must be an integer.
         * @param {number} [tmxCompanyIdLt] Filter less than the value. Value must be an integer.
         * @param {number} [tmxCompanyIdLte] Filter less than or equal to the value. Value must be an integer.
         * @param {string} [tmxRecordId] The unique alphanumeric identifier for the event record used by TMX.
         * @param {string} [tmxRecordIdAnyOf] Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
         * @param {string} [tmxRecordIdGt] Filter greater than the value.
         * @param {string} [tmxRecordIdGte] Filter greater than or equal to the value.
         * @param {string} [tmxRecordIdLt] Filter less than the value.
         * @param {string} [tmxRecordIdLte] Filter less than or equal to the value.
         * @param {number} [limit] Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
         * @param {string} [sort] A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTmxV1CorporateEvents(date?: string, dateAnyOf?: string, dateGt?: string, dateGte?: string, dateLt?: string, dateLte?: string, type?: string, typeAnyOf?: string, typeGt?: string, typeGte?: string, typeLt?: string, typeLte?: string, status?: string, statusAnyOf?: string, statusGt?: string, statusGte?: string, statusLt?: string, statusLte?: string, ticker?: string, tickerAnyOf?: string, tickerGt?: string, tickerGte?: string, tickerLt?: string, tickerLte?: string, isin?: string, isinAnyOf?: string, isinGt?: string, isinGte?: string, isinLt?: string, isinLte?: string, tradingVenue?: string, tradingVenueAnyOf?: string, tradingVenueGt?: string, tradingVenueGte?: string, tradingVenueLt?: string, tradingVenueLte?: string, tmxCompanyId?: number, tmxCompanyIdGt?: number, tmxCompanyIdGte?: number, tmxCompanyIdLt?: number, tmxCompanyIdLte?: number, tmxRecordId?: string, tmxRecordIdAnyOf?: string, tmxRecordIdGt?: string, tmxRecordIdGte?: string, tmxRecordIdLt?: string, tmxRecordIdLte?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<GetTmxV1CorporateEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTmxV1CorporateEvents(date, dateAnyOf, dateGt, dateGte, dateLt, dateLte, type, typeAnyOf, typeGt, typeGte, typeLt, typeLte, status, statusAnyOf, statusGt, statusGte, statusLt, statusLte, ticker, tickerAnyOf, tickerGt, tickerGte, tickerLt, tickerLte, isin, isinAnyOf, isinGt, isinGte, isinLt, isinLte, tradingVenue, tradingVenueAnyOf, tradingVenueGt, tradingVenueGte, tradingVenueLt, tradingVenueLte, tmxCompanyId, tmxCompanyIdGt, tmxCompanyIdGte, tmxCompanyIdLt, tmxCompanyIdLte, tmxRecordId, tmxRecordIdAnyOf, tmxRecordIdGt, tmxRecordIdGte, tmxRecordIdLt, tmxRecordIdLte, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getTmxV1CorporateEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all conditions that Massive uses.
         * @summary Conditions
         * @param {ListConditionsAssetClassEnum} [assetClass] Filter for conditions within a given asset class.
         * @param {ListConditionsDataTypeEnum} [dataType] Filter by data type.
         * @param {number} [id] Filter for conditions with a given ID.
         * @param {ListConditionsSipEnum} [sip] Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned.
         * @param {ListConditionsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListConditionsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConditions(assetClass?: ListConditionsAssetClassEnum, dataType?: ListConditionsDataTypeEnum, id?: number, sip?: ListConditionsSipEnum, order?: ListConditionsOrderEnum, limit?: number, sort?: ListConditionsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListConditions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConditions(assetClass, dataType, id, sip, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listConditions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
         * @summary Dividends v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [exDividendDate] Query by ex-dividend date with the format YYYY-MM-DD.
         * @param {string} [recordDate] Query by record date with the format YYYY-MM-DD.
         * @param {string} [declarationDate] Query by declaration date with the format YYYY-MM-DD.
         * @param {string} [payDate] Query by pay date with the format YYYY-MM-DD.
         * @param {ListDividendsFrequencyEnum} [frequency] Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
         * @param {number} [cashAmount] Query by the cash amount of the dividend.
         * @param {ListDividendsDividendTypeEnum} [dividendType] Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [exDividendDateGte] Range by ex_dividend_date.
         * @param {string} [exDividendDateGt] Range by ex_dividend_date.
         * @param {string} [exDividendDateLte] Range by ex_dividend_date.
         * @param {string} [exDividendDateLt] Range by ex_dividend_date.
         * @param {string} [recordDateGte] Range by record_date.
         * @param {string} [recordDateGt] Range by record_date.
         * @param {string} [recordDateLte] Range by record_date.
         * @param {string} [recordDateLt] Range by record_date.
         * @param {string} [declarationDateGte] Range by declaration_date.
         * @param {string} [declarationDateGt] Range by declaration_date.
         * @param {string} [declarationDateLte] Range by declaration_date.
         * @param {string} [declarationDateLt] Range by declaration_date.
         * @param {string} [payDateGte] Range by pay_date.
         * @param {string} [payDateGt] Range by pay_date.
         * @param {string} [payDateLte] Range by pay_date.
         * @param {string} [payDateLt] Range by pay_date.
         * @param {number} [cashAmountGte] Range by cash_amount.
         * @param {number} [cashAmountGt] Range by cash_amount.
         * @param {number} [cashAmountLte] Range by cash_amount.
         * @param {number} [cashAmountLt] Range by cash_amount.
         * @param {ListDividendsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListDividendsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDividends(ticker?: string, exDividendDate?: string, recordDate?: string, declarationDate?: string, payDate?: string, frequency?: ListDividendsFrequencyEnum, cashAmount?: number, dividendType?: ListDividendsDividendTypeEnum, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, exDividendDateGte?: string, exDividendDateGt?: string, exDividendDateLte?: string, exDividendDateLt?: string, recordDateGte?: string, recordDateGt?: string, recordDateLte?: string, recordDateLt?: string, declarationDateGte?: string, declarationDateGt?: string, declarationDateLte?: string, declarationDateLt?: string, payDateGte?: string, payDateGt?: string, payDateLte?: string, payDateLt?: string, cashAmountGte?: number, cashAmountGt?: number, cashAmountLte?: number, cashAmountLt?: number, order?: ListDividendsOrderEnum, limit?: number, sort?: ListDividendsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListDividends200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDividends(ticker, exDividendDate, recordDate, declarationDate, payDate, frequency, cashAmount, dividendType, tickerGte, tickerGt, tickerLte, tickerLt, exDividendDateGte, exDividendDateGt, exDividendDateLte, exDividendDateLt, recordDateGte, recordDateGt, recordDateLte, recordDateLt, declarationDateGte, declarationDateGt, declarationDateLte, declarationDateLt, payDateGte, payDateGt, payDateLte, payDateLt, cashAmountGte, cashAmountGt, cashAmountLte, cashAmountLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listDividends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all exchanges that Massive knows about.
         * @summary Exchanges
         * @param {ListExchangesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListExchangesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExchanges(assetClass?: ListExchangesAssetClassEnum, locale?: ListExchangesLocaleEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListExchanges200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExchanges(assetClass, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listExchanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\">here</a>.
         * @summary Stock Financials vX
         * @param {string} [ticker] Query by company ticker.
         * @param {string} [cik] Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number
         * @param {string} [companyName] Query by company name.
         * @param {string} [sic] Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;)
         * @param {string} [filingDate] Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01
         * @param {string} [periodOfReportDate] The period of report for the filing with financials data in YYYY-MM-DD format.
         * @param {ListFinancialsTimeframeEnum} [timeframe] Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4
         * @param {boolean} [includeSources] Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default.
         * @param {string} [companyNameSearch] Search by company_name.
         * @param {string} [filingDateGte] Search by filing_date.
         * @param {string} [filingDateGt] Search by filing_date.
         * @param {string} [filingDateLte] Search by filing_date.
         * @param {string} [filingDateLt] Search by filing_date.
         * @param {string} [periodOfReportDateGte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateGt] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLte] Search by period_of_report_date.
         * @param {string} [periodOfReportDateLt] Search by period_of_report_date.
         * @param {ListFinancialsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 100.
         * @param {ListFinancialsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFinancials(ticker?: string, cik?: string, companyName?: string, sic?: string, filingDate?: string, periodOfReportDate?: string, timeframe?: ListFinancialsTimeframeEnum, includeSources?: boolean, companyNameSearch?: string, filingDateGte?: string, filingDateGt?: string, filingDateLte?: string, filingDateLt?: string, periodOfReportDateGte?: string, periodOfReportDateGt?: string, periodOfReportDateLte?: string, periodOfReportDateLt?: string, order?: ListFinancialsOrderEnum, limit?: number, sort?: ListFinancialsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListFinancials200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFinancials(ticker, cik, companyName, sic, filingDate, periodOfReportDate, timeframe, includeSources, companyNameSearch, filingDateGte, filingDateGt, filingDateLte, filingDateLt, periodOfReportDateGte, periodOfReportDateGt, periodOfReportDateLte, periodOfReportDateLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listFinancials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
         * @summary IPOs
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, TSLA represents Tesla Inc.
         * @param {string} [usCode] Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
         * @param {string} [isin] Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world.
         * @param {string} [listingDate] Specify a listing date. This is the first trading date for the newly listed entity.
         * @param {ListIPOsIpoStatusEnum} [ipoStatus] Specify an IPO status.
         * @param {string} [listingDateGte] Range by listing_date.
         * @param {string} [listingDateGt] Range by listing_date.
         * @param {string} [listingDateLte] Range by listing_date.
         * @param {string} [listingDateLt] Range by listing_date.
         * @param {ListIPOsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListIPOsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIPOs(ticker?: string, usCode?: string, isin?: string, listingDate?: string, ipoStatus?: ListIPOsIpoStatusEnum, listingDateGte?: string, listingDateGt?: string, listingDateLte?: string, listingDateLt?: string, order?: ListIPOsOrderEnum, limit?: number, sort?: ListIPOsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListIPOs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIPOs(ticker, usCode, isin, listingDate, ipoStatus, listingDateGte, listingDateGt, listingDateLte, listingDateLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listIPOs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
         * @summary Ticker News
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtc] Return results published on, before, or after this date.
         * @param {string} [tickerGte] Search by ticker.
         * @param {string} [tickerGt] Search by ticker.
         * @param {string} [tickerLte] Search by ticker.
         * @param {string} [tickerLt] Search by ticker.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcGt] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLte] Search by published_utc.
         * @param {ListNewsPublishedUtcParameter} [publishedUtcLt] Search by published_utc.
         * @param {ListNewsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListNewsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNews(ticker?: string, publishedUtc?: ListNewsPublishedUtcParameter, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, publishedUtcGte?: ListNewsPublishedUtcParameter, publishedUtcGt?: ListNewsPublishedUtcParameter, publishedUtcLte?: ListNewsPublishedUtcParameter, publishedUtcLt?: ListNewsPublishedUtcParameter, order?: ListNewsOrderEnum, limit?: number, sort?: ListNewsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListNews200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNews(ticker, publishedUtc, tickerGte, tickerGt, tickerLte, tickerLt, publishedUtcGte, publishedUtcGt, publishedUtcLte, publishedUtcLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listNews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query for historical options contracts. This provides both active and expired options contracts.
         * @summary Options Contracts
         * @param {string} [underlyingTicker] Query for contracts relating to an underlying stock ticker.
         * @param {string} [ticker] This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://massive.com/docs/rest/options/contracts/contract-overview).
         * @param {ListOptionsContractsContractTypeEnum} [contractType] Query by the type of contract.
         * @param {string} [expirationDate] Query by contract expiration with date format YYYY-MM-DD.
         * @param {string} [asOf] Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
         * @param {number} [strikePrice] Query by strike price of a contract.
         * @param {boolean} [expired] Query for expired contracts. Default is false.
         * @param {string} [underlyingTickerGte] Range by underlying_ticker.
         * @param {string} [underlyingTickerGt] Range by underlying_ticker.
         * @param {string} [underlyingTickerLte] Range by underlying_ticker.
         * @param {string} [underlyingTickerLt] Range by underlying_ticker.
         * @param {string} [expirationDateGte] Range by expiration_date.
         * @param {string} [expirationDateGt] Range by expiration_date.
         * @param {string} [expirationDateLte] Range by expiration_date.
         * @param {string} [expirationDateLt] Range by expiration_date.
         * @param {number} [strikePriceGte] Range by strike_price.
         * @param {number} [strikePriceGt] Range by strike_price.
         * @param {number} [strikePriceLte] Range by strike_price.
         * @param {number} [strikePriceLt] Range by strike_price.
         * @param {ListOptionsContractsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListOptionsContractsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOptionsContracts(underlyingTicker?: string, ticker?: string, contractType?: ListOptionsContractsContractTypeEnum, expirationDate?: string, asOf?: string, strikePrice?: number, expired?: boolean, underlyingTickerGte?: string, underlyingTickerGt?: string, underlyingTickerLte?: string, underlyingTickerLt?: string, expirationDateGte?: string, expirationDateGt?: string, expirationDateLte?: string, expirationDateLt?: string, strikePriceGte?: number, strikePriceGt?: number, strikePriceLte?: number, strikePriceLt?: number, order?: ListOptionsContractsOrderEnum, limit?: number, sort?: ListOptionsContractsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListOptionsContracts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOptionsContracts(underlyingTicker, ticker, contractType, expirationDate, asOf, strikePrice, expired, underlyingTickerGte, underlyingTickerGt, underlyingTickerLte, underlyingTickerLt, expirationDateGte, expirationDateGt, expirationDateLte, expirationDateLt, strikePriceGte, strikePriceGt, strikePriceLte, strikePriceLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listOptionsContracts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
         * @summary Stock Splits v3
         * @param {string} [ticker] Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
         * @param {string} [executionDate] Query by execution date with the format YYYY-MM-DD.
         * @param {boolean | null} [reverseSplit] Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {string} [executionDateGte] Range by execution_date.
         * @param {string} [executionDateGt] Range by execution_date.
         * @param {string} [executionDateLte] Range by execution_date.
         * @param {string} [executionDateLt] Range by execution_date.
         * @param {ListStockSplitsOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 10 and max is 1000.
         * @param {ListStockSplitsSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStockSplits(ticker?: string, executionDate?: string, reverseSplit?: boolean | null, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, executionDateGte?: string, executionDateGt?: string, executionDateLte?: string, executionDateLt?: string, order?: ListStockSplitsOrderEnum, limit?: number, sort?: ListStockSplitsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListStockSplits200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStockSplits(ticker, executionDate, reverseSplit, tickerGte, tickerGt, tickerLte, tickerLt, executionDateGte, executionDateGt, executionDateLte, executionDateLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listStockSplits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all ticker types that Massive.com has.
         * @summary Ticker Types
         * @param {ListTickerTypesAssetClassEnum} [assetClass] Filter by asset class.
         * @param {ListTickerTypesLocaleEnum} [locale] Filter by locale.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTickerTypes(assetClass?: ListTickerTypesAssetClassEnum, locale?: ListTickerTypesLocaleEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListTickerTypes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTickerTypes(assetClass, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listTickerTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query all ticker symbols which are supported by Massive.com. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
         * @summary Tickers
         * @param {string} [ticker] Specify a ticker symbol. Defaults to empty string which queries all tickers.
         * @param {ListTickersTypeEnum} [type] Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://massive.com/docs/rest/stocks/tickers/ticker-types). Defaults to empty string which queries all types.
         * @param {ListTickersMarketEnum} [market] Filter by market type. By default all markets are included.
         * @param {string} [exchange] Specify the asset\&#39;s primary exchange Market Identifier Code (MIC) according to [ISO 10383](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges.
         * @param {string} [cusip] Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
         * @param {string} [cik] Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs.
         * @param {string} [date] Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date.
         * @param {string} [search] Search for terms within the ticker and/or company name.
         * @param {boolean} [active] Specify if the tickers returned should be actively traded on the queried date. Default is true.
         * @param {string} [tickerGte] Range by ticker.
         * @param {string} [tickerGt] Range by ticker.
         * @param {string} [tickerLte] Range by ticker.
         * @param {string} [tickerLt] Range by ticker.
         * @param {ListTickersOrderEnum} [order] Order results based on the &#x60;sort&#x60; field.
         * @param {number} [limit] Limit the number of results returned, default is 100 and max is 1000.
         * @param {ListTickersSortEnum} [sort] Sort field used for ordering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTickers(ticker?: string, type?: ListTickersTypeEnum, market?: ListTickersMarketEnum, exchange?: string, cusip?: string, cik?: string, date?: string, search?: string, active?: boolean, tickerGte?: string, tickerGt?: string, tickerLte?: string, tickerLt?: string, order?: ListTickersOrderEnum, limit?: number, sort?: ListTickersSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<ListTickers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTickers(ticker, type, market, exchange, cusip, cik, date, search, active, tickerGte, tickerGt, tickerLte, tickerLt, order, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listTickers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker Full Book (L2)
         * @param {DefaultApiDeprecatedGetCryptoSnapshotTickerBookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetCryptoSnapshotTickerBook(requestParameters: DefaultApiDeprecatedGetCryptoSnapshotTickerBookRequest, options?: RawAxiosRequestConfig): Promise<DeprecatedGetCryptoSnapshotTickerBook200Response> {
            return localVarFp.deprecatedGetCryptoSnapshotTickerBook(requestParameters.ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get historic trade ticks for a cryptocurrency pair. 
         * @summary Historic Crypto Trades
         * @param {DefaultApiDeprecatedGetHistoricCryptoTradesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricCryptoTrades(requestParameters: DefaultApiDeprecatedGetHistoricCryptoTradesRequest, options?: RawAxiosRequestConfig): Promise<DeprecatedGetHistoricCryptoTrades200Response> {
            return localVarFp.deprecatedGetHistoricCryptoTrades(requestParameters.from, requestParameters.to, requestParameters.date, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get historic ticks for a forex currency pair. 
         * @summary Historic Forex Ticks
         * @param {DefaultApiDeprecatedGetHistoricForexQuotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricForexQuotes(requestParameters: DefaultApiDeprecatedGetHistoricForexQuotesRequest, options?: RawAxiosRequestConfig): Promise<DeprecatedGetHistoricForexQuotes200Response> {
            return localVarFp.deprecatedGetHistoricForexQuotes(requestParameters.from, requestParameters.to, requestParameters.date, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get NBBO quotes for a given ticker symbol on a specified date. 
         * @summary Quotes (NBBO)
         * @param {DefaultApiDeprecatedGetHistoricStocksQuotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricStocksQuotes(requestParameters: DefaultApiDeprecatedGetHistoricStocksQuotesRequest, options?: RawAxiosRequestConfig): Promise<DeprecatedGetHistoricStocksQuotes200Response> {
            return localVarFp.deprecatedGetHistoricStocksQuotes(requestParameters.ticker, requestParameters.date, requestParameters.timestamp, requestParameters.timestampLimit, requestParameters.reverse, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a given ticker symbol on a specified date. 
         * @summary Trades
         * @param {DefaultApiDeprecatedGetHistoricStocksTradesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deprecatedGetHistoricStocksTrades(requestParameters: DefaultApiDeprecatedGetHistoricStocksTradesRequest, options?: RawAxiosRequestConfig): Promise<DeprecatedGetHistoricStocksTrades200Response> {
            return localVarFp.deprecatedGetHistoricStocksTrades(requestParameters.ticker, requestParameters.date, requestParameters.timestamp, requestParameters.timestampLimit, requestParameters.reverse, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * A comprehensive database of financial analyst insights and ratings for various publicly traded companies, capturing detailed information about analyst recommendations and price targets.
         * @param {DefaultApiGetBenzingaV1AnalystInsightsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1AnalystInsights(requestParameters: DefaultApiGetBenzingaV1AnalystInsightsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1AnalystInsights200Response> {
            return localVarFp.getBenzingaV1AnalystInsights(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGt, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLt, requestParameters.lastUpdatedLte, requestParameters.firm, requestParameters.firmAnyOf, requestParameters.firmGt, requestParameters.firmGte, requestParameters.firmLt, requestParameters.firmLte, requestParameters.ratingAction, requestParameters.ratingActionAnyOf, requestParameters.ratingActionGt, requestParameters.ratingActionGte, requestParameters.ratingActionLt, requestParameters.ratingActionLte, requestParameters.benzingaFirmId, requestParameters.benzingaFirmIdAnyOf, requestParameters.benzingaFirmIdGt, requestParameters.benzingaFirmIdGte, requestParameters.benzingaFirmIdLt, requestParameters.benzingaFirmIdLte, requestParameters.benzingaRatingId, requestParameters.benzingaRatingIdAnyOf, requestParameters.benzingaRatingIdGt, requestParameters.benzingaRatingIdGte, requestParameters.benzingaRatingIdLt, requestParameters.benzingaRatingIdLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * A comprehensive database of financial analysts, containing detailed performance metrics and identification information for individual analysts across various financial firms.
         * @param {DefaultApiGetBenzingaV1AnalystsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Analysts(requestParameters: DefaultApiGetBenzingaV1AnalystsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1Analysts200Response> {
            return localVarFp.getBenzingaV1Analysts(requestParameters.benzingaId, requestParameters.benzingaIdAnyOf, requestParameters.benzingaIdGt, requestParameters.benzingaIdGte, requestParameters.benzingaIdLt, requestParameters.benzingaIdLte, requestParameters.benzingaFirmId, requestParameters.benzingaFirmIdAnyOf, requestParameters.benzingaFirmIdGt, requestParameters.benzingaFirmIdGte, requestParameters.benzingaFirmIdLt, requestParameters.benzingaFirmIdLte, requestParameters.firmName, requestParameters.firmNameAnyOf, requestParameters.firmNameGt, requestParameters.firmNameGte, requestParameters.firmNameLt, requestParameters.firmNameLte, requestParameters.fullName, requestParameters.fullNameAnyOf, requestParameters.fullNameGt, requestParameters.fullNameGte, requestParameters.fullNameLt, requestParameters.fullNameLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * A comprehensive financial consensus ratings table that aggregates analyst recommendations and price targets for individual stock tickers, capturing detailed rating breakdowns and statistical insights.
         * @param {DefaultApiGetBenzingaV1ConsensusRatingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1ConsensusRatings(requestParameters: DefaultApiGetBenzingaV1ConsensusRatingsRequest, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1ConsensusRatings200Response> {
            return localVarFp.getBenzingaV1ConsensusRatings(requestParameters.ticker, requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * This table contains earnings data from Benzinga, tracking both actual and estimated financial metrics for publicly traded companies. It includes EPS and revenue figures with surprise calculations, along with metadata like fiscal periods, company identifiers, and reporting timestamps.
         * @param {DefaultApiGetBenzingaV1EarningsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Earnings(requestParameters: DefaultApiGetBenzingaV1EarningsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1Earnings200Response> {
            return localVarFp.getBenzingaV1Earnings(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.importance, requestParameters.importanceAnyOf, requestParameters.importanceGt, requestParameters.importanceGte, requestParameters.importanceLt, requestParameters.importanceLte, requestParameters.lastUpdated, requestParameters.lastUpdatedAnyOf, requestParameters.lastUpdatedGt, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLt, requestParameters.lastUpdatedLte, requestParameters.dateStatus, requestParameters.dateStatusAnyOf, requestParameters.dateStatusGt, requestParameters.dateStatusGte, requestParameters.dateStatusLt, requestParameters.dateStatusLte, requestParameters.epsSurprisePercent, requestParameters.epsSurprisePercentAnyOf, requestParameters.epsSurprisePercentGt, requestParameters.epsSurprisePercentGte, requestParameters.epsSurprisePercentLt, requestParameters.epsSurprisePercentLte, requestParameters.revenueSurprisePercent, requestParameters.revenueSurprisePercentAnyOf, requestParameters.revenueSurprisePercentGt, requestParameters.revenueSurprisePercentGte, requestParameters.revenueSurprisePercentLt, requestParameters.revenueSurprisePercentLte, requestParameters.fiscalYear, requestParameters.fiscalYearAnyOf, requestParameters.fiscalYearGt, requestParameters.fiscalYearGte, requestParameters.fiscalYearLt, requestParameters.fiscalYearLte, requestParameters.fiscalPeriod, requestParameters.fiscalPeriodAnyOf, requestParameters.fiscalPeriodGt, requestParameters.fiscalPeriodGte, requestParameters.fiscalPeriodLt, requestParameters.fiscalPeriodLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * A comprehensive database of financial firms, tracking unique identifiers, names, and basic metadata for various financial institutions and research firms.
         * @param {DefaultApiGetBenzingaV1FirmsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Firms(requestParameters: DefaultApiGetBenzingaV1FirmsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1Firms200Response> {
            return localVarFp.getBenzingaV1Firms(requestParameters.benzingaId, requestParameters.benzingaIdAnyOf, requestParameters.benzingaIdGt, requestParameters.benzingaIdGte, requestParameters.benzingaIdLt, requestParameters.benzingaIdLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * A comprehensive database of financial guidance and earnings estimates for various companies, capturing key metrics related to earnings per share (EPS) and revenue projections across different fiscal periods.
         * @param {DefaultApiGetBenzingaV1GuidanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Guidance(requestParameters: DefaultApiGetBenzingaV1GuidanceRequest = {}, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1Guidance200Response> {
            return localVarFp.getBenzingaV1Guidance(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.positioning, requestParameters.positioningAnyOf, requestParameters.positioningGt, requestParameters.positioningGte, requestParameters.positioningLt, requestParameters.positioningLte, requestParameters.importance, requestParameters.importanceAnyOf, requestParameters.importanceGt, requestParameters.importanceGte, requestParameters.importanceLt, requestParameters.importanceLte, requestParameters.lastUpdated, requestParameters.lastUpdatedAnyOf, requestParameters.lastUpdatedGt, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLt, requestParameters.lastUpdatedLte, requestParameters.fiscalYear, requestParameters.fiscalYearAnyOf, requestParameters.fiscalYearGt, requestParameters.fiscalYearGte, requestParameters.fiscalYearLt, requestParameters.fiscalYearLte, requestParameters.fiscalPeriod, requestParameters.fiscalPeriodAnyOf, requestParameters.fiscalPeriodGt, requestParameters.fiscalPeriodGte, requestParameters.fiscalPeriodLt, requestParameters.fiscalPeriodLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * A comprehensive news article database from Benzinga, containing detailed information about financial news articles including metadata, content, and associated financial information.
         * @param {DefaultApiGetBenzingaV1NewsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1News(requestParameters: DefaultApiGetBenzingaV1NewsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1News200Response> {
            return localVarFp.getBenzingaV1News(requestParameters.published, requestParameters.publishedAnyOf, requestParameters.publishedGt, requestParameters.publishedGte, requestParameters.publishedLt, requestParameters.publishedLte, requestParameters.lastUpdated, requestParameters.lastUpdatedAnyOf, requestParameters.lastUpdatedGt, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLt, requestParameters.lastUpdatedLte, requestParameters.tickers, requestParameters.tickersAllOf, requestParameters.tickersAnyOf, requestParameters.channels, requestParameters.channelsAllOf, requestParameters.channelsAnyOf, requestParameters.tags, requestParameters.tagsAllOf, requestParameters.tagsAnyOf, requestParameters.author, requestParameters.authorAnyOf, requestParameters.authorGt, requestParameters.authorGte, requestParameters.authorLt, requestParameters.authorLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * This table contains analyst ratings and price target data from investment firms, tracking rating changes (upgrades, downgrades, initiates coverage, etc.) and price target adjustments for publicly traded companies. Each record includes the analyst details, company information, current and previous ratings/targets, and metadata like timestamps and Benzinga identifiers.
         * @param {DefaultApiGetBenzingaV1RatingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV1Ratings(requestParameters: DefaultApiGetBenzingaV1RatingsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetBenzingaV1Ratings200Response> {
            return localVarFp.getBenzingaV1Ratings(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.importance, requestParameters.importanceGt, requestParameters.importanceGte, requestParameters.importanceLt, requestParameters.importanceLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGt, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLt, requestParameters.lastUpdatedLte, requestParameters.ratingAction, requestParameters.ratingActionAnyOf, requestParameters.ratingActionGt, requestParameters.ratingActionGte, requestParameters.ratingActionLt, requestParameters.ratingActionLte, requestParameters.priceTargetAction, requestParameters.priceTargetActionAnyOf, requestParameters.priceTargetActionGt, requestParameters.priceTargetActionGte, requestParameters.priceTargetActionLt, requestParameters.priceTargetActionLte, requestParameters.benzingaId, requestParameters.benzingaIdAnyOf, requestParameters.benzingaIdGt, requestParameters.benzingaIdGte, requestParameters.benzingaIdLt, requestParameters.benzingaIdLte, requestParameters.benzingaAnalystId, requestParameters.benzingaAnalystIdAnyOf, requestParameters.benzingaAnalystIdGt, requestParameters.benzingaAnalystIdGte, requestParameters.benzingaAnalystIdLt, requestParameters.benzingaAnalystIdLte, requestParameters.benzingaFirmId, requestParameters.benzingaFirmIdAnyOf, requestParameters.benzingaFirmIdGt, requestParameters.benzingaFirmIdGte, requestParameters.benzingaFirmIdLt, requestParameters.benzingaFirmIdLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * A comprehensive news article database from Benzinga, containing detailed information about financial news articles including metadata, content, and associated financial information.
         * @param {DefaultApiGetBenzingaV2NewsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenzingaV2News(requestParameters: DefaultApiGetBenzingaV2NewsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetBenzingaV2News200Response> {
            return localVarFp.getBenzingaV2News(requestParameters.published, requestParameters.publishedGt, requestParameters.publishedGte, requestParameters.publishedLt, requestParameters.publishedLte, requestParameters.channels, requestParameters.channelsAllOf, requestParameters.channelsAnyOf, requestParameters.tags, requestParameters.tagsAllOf, requestParameters.tagsAnyOf, requestParameters.author, requestParameters.authorAnyOf, requestParameters.authorGt, requestParameters.authorGte, requestParameters.authorLt, requestParameters.authorLte, requestParameters.stocks, requestParameters.stocksAllOf, requestParameters.stocksAnyOf, requestParameters.tickers, requestParameters.tickersAllOf, requestParameters.tickersAnyOf, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {DefaultApiGetCryptoAggregatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoAggregates(requestParameters: DefaultApiGetCryptoAggregatesRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoAggregates200Response> {
            return localVarFp.getCryptoAggregates(requestParameters.cryptoTicker, requestParameters.multiplier, requestParameters.timespan, requestParameters.from, requestParameters.to, requestParameters.adjusted, requestParameters.sort, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {DefaultApiGetCryptoEMARequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoEMA(requestParameters: DefaultApiGetCryptoEMARequest, options?: RawAxiosRequestConfig): Promise<GetCryptoEMA200Response> {
            return localVarFp.getCryptoEMA(requestParameters.cryptoTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {DefaultApiGetCryptoMACDRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoMACD(requestParameters: DefaultApiGetCryptoMACDRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoMACD200Response> {
            return localVarFp.getCryptoMACD(requestParameters.cryptoTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.shortWindow, requestParameters.longWindow, requestParameters.signalWindow, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the open, close prices of a cryptocurrency symbol on a certain day. 
         * @summary Daily Open/Close
         * @param {DefaultApiGetCryptoOpenCloseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoOpenClose(requestParameters: DefaultApiGetCryptoOpenCloseRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoOpenClose200Response> {
            return localVarFp.getCryptoOpenClose(requestParameters.from, requestParameters.to, requestParameters.date, requestParameters.adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {DefaultApiGetCryptoRSIRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoRSI(requestParameters: DefaultApiGetCryptoRSIRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoRSI200Response> {
            return localVarFp.getCryptoRSI(requestParameters.cryptoTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {DefaultApiGetCryptoSMARequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSMA(requestParameters: DefaultApiGetCryptoSMARequest, options?: RawAxiosRequestConfig): Promise<GetCryptoSMA200Response> {
            return localVarFp.getCryptoSMA(requestParameters.cryptoTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current top 20 gainers or losers of the day in cryptocurrency markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {DefaultApiGetCryptoSnapshotDirectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSnapshotDirection(requestParameters: DefaultApiGetCryptoSnapshotDirectionRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoSnapshotDirection200Response> {
            return localVarFp.getCryptoSnapshotDirection(requestParameters.direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {DefaultApiGetCryptoSnapshotTickerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSnapshotTicker(requestParameters: DefaultApiGetCryptoSnapshotTickerRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoSnapshotTicker200Response> {
            return localVarFp.getCryptoSnapshotTicker(requestParameters.ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {DefaultApiGetCryptoSnapshotTickersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoSnapshotTickers(requestParameters: DefaultApiGetCryptoSnapshotTickersRequest = {}, options?: RawAxiosRequestConfig): Promise<GetCryptoSnapshotTickers200Response> {
            return localVarFp.getCryptoSnapshotTickers(requestParameters.tickers, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a crypto ticker symbol in a given time range.
         * @summary Trades
         * @param {DefaultApiGetCryptoTradesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoTrades(requestParameters: DefaultApiGetCryptoTradesRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoTrades200Response> {
            return localVarFp.getCryptoTrades(requestParameters.cryptoTicker, requestParameters.timestamp, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Global cryptocurrency exchanges and digital asset trading platforms, including major centralized exchanges (Coinbase, Binance, Bitfinex, etc.) that facilitate trading of cryptocurrencies and digital tokens worldwide.
         * @param {DefaultApiGetCryptoV1ExchangesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCryptoV1Exchanges(requestParameters: DefaultApiGetCryptoV1ExchangesRequest = {}, options?: RawAxiosRequestConfig): Promise<GetCryptoV1Exchanges200Response> {
            return localVarFp.getCryptoV1Exchanges(requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
         * @summary Real-time Currency Conversion
         * @param {DefaultApiGetCurrencyConversionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyConversion(requestParameters: DefaultApiGetCurrencyConversionRequest, options?: RawAxiosRequestConfig): Promise<GetCurrencyConversion200Response> {
            return localVarFp.getCurrencyConversion(requestParameters.from, requestParameters.to, requestParameters.amount, requestParameters.precision, options).then((request) => request(axios, basePath));
        },
        /**
         * ETF Global analytics data containing risk scores, reward metrics, and quantitative analysis for ETF composite tickers.
         * @param {DefaultApiGetEtfGlobalV1AnalyticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEtfGlobalV1Analytics(requestParameters: DefaultApiGetEtfGlobalV1AnalyticsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetEtfGlobalV1Analytics200Response> {
            return localVarFp.getEtfGlobalV1Analytics(requestParameters.compositeTicker, requestParameters.compositeTickerAnyOf, requestParameters.compositeTickerGt, requestParameters.compositeTickerGte, requestParameters.compositeTickerLt, requestParameters.compositeTickerLte, requestParameters.processedDate, requestParameters.processedDateGt, requestParameters.processedDateGte, requestParameters.processedDateLt, requestParameters.processedDateLte, requestParameters.effectiveDate, requestParameters.effectiveDateGt, requestParameters.effectiveDateGte, requestParameters.effectiveDateLt, requestParameters.effectiveDateLte, requestParameters.riskTotalScore, requestParameters.riskTotalScoreGt, requestParameters.riskTotalScoreGte, requestParameters.riskTotalScoreLt, requestParameters.riskTotalScoreLte, requestParameters.rewardScore, requestParameters.rewardScoreGt, requestParameters.rewardScoreGte, requestParameters.rewardScoreLt, requestParameters.rewardScoreLte, requestParameters.quantTotalScore, requestParameters.quantTotalScoreGt, requestParameters.quantTotalScoreGte, requestParameters.quantTotalScoreLt, requestParameters.quantTotalScoreLte, requestParameters.quantGrade, requestParameters.quantGradeAnyOf, requestParameters.quantGradeGt, requestParameters.quantGradeGte, requestParameters.quantGradeLt, requestParameters.quantGradeLte, requestParameters.quantCompositeTechnical, requestParameters.quantCompositeTechnicalGt, requestParameters.quantCompositeTechnicalGte, requestParameters.quantCompositeTechnicalLt, requestParameters.quantCompositeTechnicalLte, requestParameters.quantCompositeSentiment, requestParameters.quantCompositeSentimentGt, requestParameters.quantCompositeSentimentGte, requestParameters.quantCompositeSentimentLt, requestParameters.quantCompositeSentimentLte, requestParameters.quantCompositeBehavioral, requestParameters.quantCompositeBehavioralGt, requestParameters.quantCompositeBehavioralGte, requestParameters.quantCompositeBehavioralLt, requestParameters.quantCompositeBehavioralLte, requestParameters.quantCompositeFundamental, requestParameters.quantCompositeFundamentalGt, requestParameters.quantCompositeFundamentalGte, requestParameters.quantCompositeFundamentalLt, requestParameters.quantCompositeFundamentalLte, requestParameters.quantCompositeGlobal, requestParameters.quantCompositeGlobalGt, requestParameters.quantCompositeGlobalGte, requestParameters.quantCompositeGlobalLt, requestParameters.quantCompositeGlobalLte, requestParameters.quantCompositeQuality, requestParameters.quantCompositeQualityGt, requestParameters.quantCompositeQualityGte, requestParameters.quantCompositeQualityLt, requestParameters.quantCompositeQualityLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * ETF Global constituents data containing detailed information about the securities held within ETFs, including weights, market values, and security identifiers.
         * @param {DefaultApiGetEtfGlobalV1ConstituentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEtfGlobalV1Constituents(requestParameters: DefaultApiGetEtfGlobalV1ConstituentsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetEtfGlobalV1Constituents200Response> {
            return localVarFp.getEtfGlobalV1Constituents(requestParameters.compositeTicker, requestParameters.compositeTickerAnyOf, requestParameters.compositeTickerGt, requestParameters.compositeTickerGte, requestParameters.compositeTickerLt, requestParameters.compositeTickerLte, requestParameters.constituentTicker, requestParameters.constituentTickerAnyOf, requestParameters.constituentTickerGt, requestParameters.constituentTickerGte, requestParameters.constituentTickerLt, requestParameters.constituentTickerLte, requestParameters.effectiveDate, requestParameters.effectiveDateGt, requestParameters.effectiveDateGte, requestParameters.effectiveDateLt, requestParameters.effectiveDateLte, requestParameters.processedDate, requestParameters.processedDateGt, requestParameters.processedDateGte, requestParameters.processedDateLt, requestParameters.processedDateLte, requestParameters.usCode, requestParameters.usCodeAnyOf, requestParameters.usCodeGt, requestParameters.usCodeGte, requestParameters.usCodeLt, requestParameters.usCodeLte, requestParameters.isin, requestParameters.isinAnyOf, requestParameters.isinGt, requestParameters.isinGte, requestParameters.isinLt, requestParameters.isinLte, requestParameters.figi, requestParameters.figiAnyOf, requestParameters.figiGt, requestParameters.figiGte, requestParameters.figiLt, requestParameters.figiLte, requestParameters.sedol, requestParameters.sedolAnyOf, requestParameters.sedolGt, requestParameters.sedolGte, requestParameters.sedolLt, requestParameters.sedolLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * ETF Global fund flow data containing information about ETF share movements, net asset values, and fund flow metrics.
         * @param {DefaultApiGetEtfGlobalV1FundFlowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEtfGlobalV1FundFlows(requestParameters: DefaultApiGetEtfGlobalV1FundFlowsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetEtfGlobalV1FundFlows200Response> {
            return localVarFp.getEtfGlobalV1FundFlows(requestParameters.processedDate, requestParameters.processedDateGt, requestParameters.processedDateGte, requestParameters.processedDateLt, requestParameters.processedDateLte, requestParameters.effectiveDate, requestParameters.effectiveDateGt, requestParameters.effectiveDateGte, requestParameters.effectiveDateLt, requestParameters.effectiveDateLte, requestParameters.compositeTicker, requestParameters.compositeTickerAnyOf, requestParameters.compositeTickerGt, requestParameters.compositeTickerGte, requestParameters.compositeTickerLt, requestParameters.compositeTickerLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * ETF Global industry profile data containing comprehensive ETF metadata including financial metrics, operational details, and exposure information.
         * @param {DefaultApiGetEtfGlobalV1ProfilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEtfGlobalV1Profiles(requestParameters: DefaultApiGetEtfGlobalV1ProfilesRequest = {}, options?: RawAxiosRequestConfig): Promise<GetEtfGlobalV1Profiles200Response> {
            return localVarFp.getEtfGlobalV1Profiles(requestParameters.processedDate, requestParameters.processedDateGt, requestParameters.processedDateGte, requestParameters.processedDateLt, requestParameters.processedDateLte, requestParameters.effectiveDate, requestParameters.effectiveDateGt, requestParameters.effectiveDateGte, requestParameters.effectiveDateLt, requestParameters.effectiveDateLte, requestParameters.compositeTicker, requestParameters.compositeTickerAnyOf, requestParameters.compositeTickerGt, requestParameters.compositeTickerGte, requestParameters.compositeTickerLt, requestParameters.compositeTickerLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * ETF Global taxonomy data containing detailed classification and categorization information for ETFs including investment strategy, methodology, and structural characteristics.
         * @param {DefaultApiGetEtfGlobalV1TaxonomiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEtfGlobalV1Taxonomies(requestParameters: DefaultApiGetEtfGlobalV1TaxonomiesRequest = {}, options?: RawAxiosRequestConfig): Promise<GetEtfGlobalV1Taxonomies200Response> {
            return localVarFp.getEtfGlobalV1Taxonomies(requestParameters.processedDate, requestParameters.processedDateGt, requestParameters.processedDateGte, requestParameters.processedDateLt, requestParameters.processedDateLte, requestParameters.effectiveDate, requestParameters.effectiveDateGt, requestParameters.effectiveDateGte, requestParameters.effectiveDateLt, requestParameters.effectiveDateLte, requestParameters.compositeTicker, requestParameters.compositeTickerAnyOf, requestParameters.compositeTickerGt, requestParameters.compositeTickerGte, requestParameters.compositeTickerLt, requestParameters.compositeTickerLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
         * @summary Ticker Events
         * @param {DefaultApiGetEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(requestParameters: DefaultApiGetEventsRequest, options?: RawAxiosRequestConfig): Promise<GetEvents200Response> {
            return localVarFp.getEvents(requestParameters.id, requestParameters.types, options).then((request) => request(axios, basePath));
        },
        /**
         * A table tracking inflation and price indices, including Consumer Price Index (CPI) and Personal Consumption Expenditures (PCE) metrics over time.
         * @param {DefaultApiGetFedV1InflationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFedV1Inflation(requestParameters: DefaultApiGetFedV1InflationRequest = {}, options?: RawAxiosRequestConfig): Promise<GetFedV1Inflation200Response> {
            return localVarFp.getFedV1Inflation(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * A table tracking inflation expectations from both market-based and economic model perspectives across different time horizons.
         * @param {DefaultApiGetFedV1InflationExpectationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFedV1InflationExpectations(requestParameters: DefaultApiGetFedV1InflationExpectationsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetFedV1InflationExpectations200Response> {
            return localVarFp.getFedV1InflationExpectations(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * A record of U.S. Treasury bond yields across various maturity periods, tracking historical interest rates from short-term to long-term government securities.
         * @param {DefaultApiGetFedV1TreasuryYieldsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFedV1TreasuryYields(requestParameters: DefaultApiGetFedV1TreasuryYieldsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetFedV1TreasuryYields200Response> {
            return localVarFp.getFedV1TreasuryYields(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for a forex pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {DefaultApiGetForexAggregatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexAggregates(requestParameters: DefaultApiGetForexAggregatesRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoAggregates200Response> {
            return localVarFp.getForexAggregates(requestParameters.forexTicker, requestParameters.multiplier, requestParameters.timespan, requestParameters.from, requestParameters.to, requestParameters.adjusted, requestParameters.sort, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {DefaultApiGetForexEMARequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexEMA(requestParameters: DefaultApiGetForexEMARequest, options?: RawAxiosRequestConfig): Promise<GetCryptoEMA200Response> {
            return localVarFp.getForexEMA(requestParameters.fxTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {DefaultApiGetForexMACDRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexMACD(requestParameters: DefaultApiGetForexMACDRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoMACD200Response> {
            return localVarFp.getForexMACD(requestParameters.fxTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.shortWindow, requestParameters.longWindow, requestParameters.signalWindow, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get BBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (BBO)
         * @param {DefaultApiGetForexQuotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexQuotes(requestParameters: DefaultApiGetForexQuotesRequest, options?: RawAxiosRequestConfig): Promise<GetForexQuotes200Response> {
            return localVarFp.getForexQuotes(requestParameters.fxTicker, requestParameters.timestamp, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {DefaultApiGetForexRSIRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexRSI(requestParameters: DefaultApiGetForexRSIRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoRSI200Response> {
            return localVarFp.getForexRSI(requestParameters.fxTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {DefaultApiGetForexSMARequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSMA(requestParameters: DefaultApiGetForexSMARequest, options?: RawAxiosRequestConfig): Promise<GetCryptoSMA200Response> {
            return localVarFp.getForexSMA(requestParameters.fxTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current top 20 gainers or losers of the day in forex markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {DefaultApiGetForexSnapshotDirectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSnapshotDirection(requestParameters: DefaultApiGetForexSnapshotDirectionRequest, options?: RawAxiosRequestConfig): Promise<GetForexSnapshotTickers200Response> {
            return localVarFp.getForexSnapshotDirection(requestParameters.direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded currency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
         * @summary Ticker
         * @param {DefaultApiGetForexSnapshotTickerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSnapshotTicker(requestParameters: DefaultApiGetForexSnapshotTickerRequest, options?: RawAxiosRequestConfig): Promise<GetForexSnapshotTicker200Response> {
            return localVarFp.getForexSnapshotTicker(requestParameters.ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded forex symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {DefaultApiGetForexSnapshotTickersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexSnapshotTickers(requestParameters: DefaultApiGetForexSnapshotTickersRequest = {}, options?: RawAxiosRequestConfig): Promise<GetForexSnapshotTickers200Response> {
            return localVarFp.getForexSnapshotTickers(requestParameters.tickers, options).then((request) => request(axios, basePath));
        },
        /**
         * Global foreign exchange (FX) trading venues and market infrastructure, including electronic trading platforms, banks, and other institutions facilitating currency pair trading worldwide.
         * @param {DefaultApiGetForexV1ExchangesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForexV1Exchanges(requestParameters: DefaultApiGetForexV1ExchangesRequest = {}, options?: RawAxiosRequestConfig): Promise<GetForexV1Exchanges200Response> {
            return localVarFp.getForexV1Exchanges(requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregates for a contract in a given time range.
         * @summary Aggregates
         * @param {DefaultApiGetFuturesAggregatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesAggregates(requestParameters: DefaultApiGetFuturesAggregatesRequest, options?: RawAxiosRequestConfig): Promise<GetFuturesAggregates200Response> {
            return localVarFp.getFuturesAggregates(requestParameters.ticker, requestParameters.resolution, requestParameters.windowStart, requestParameters.limit, requestParameters.windowStartGte, requestParameters.windowStartGt, requestParameters.windowStartLte, requestParameters.windowStartLt, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * The Contract Details endpoint returns the details for a single contract at a specific point in time.
         * @summary Contract Details
         * @param {DefaultApiGetFuturesContractDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesContractDetails(requestParameters: DefaultApiGetFuturesContractDetailsRequest, options?: RawAxiosRequestConfig): Promise<GetFuturesContractDetails200Response> {
            return localVarFp.getFuturesContractDetails(requestParameters.ticker, requestParameters.asOf, options).then((request) => request(axios, basePath));
        },
        /**
         * The Contracts endpoint returns a list of futures contracts. This endpoint can be used to query for contracts based on a variety of parameters, including the contract\'s ticker, product code, first trade date, last trade date, and whether or not the contract was active on a given date.
         * @summary Contracts
         * @param {DefaultApiGetFuturesContractsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesContracts(requestParameters: DefaultApiGetFuturesContractsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetFuturesContracts200Response> {
            return localVarFp.getFuturesContracts(requestParameters.productCode, requestParameters.firstTradeDate, requestParameters.lastTradeDate, requestParameters.asOf, requestParameters.active, requestParameters.type, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * The Trading-Date Based Futures Schedules API provides detailed trading schedules for all products on a specific day. This API allows you to retrieve detailed information about trading sessions, including market events like preopen, open, and closed, along with their precise timestamps.
         * @summary Daily Schedules
         * @param {DefaultApiGetFuturesDailySchedulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesDailySchedules(requestParameters: DefaultApiGetFuturesDailySchedulesRequest = {}, options?: RawAxiosRequestConfig): Promise<GetFuturesDailySchedules200Response> {
            return localVarFp.getFuturesDailySchedules(requestParameters.sessionEndDate, requestParameters.tradingVenue, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * The market status endpoint returns the current status of the futures market for the given product code(s).
         * @summary Market Status
         * @param {DefaultApiGetFuturesMarketStatusesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesMarketStatuses(requestParameters: DefaultApiGetFuturesMarketStatusesRequest = {}, options?: RawAxiosRequestConfig): Promise<GetFuturesMarketStatuses200Response> {
            return localVarFp.getFuturesMarketStatuses(requestParameters.productCodeAnyOf, requestParameters.productCode, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * The Product Details endpoint returns the details for a single product as of a specific day.
         * @summary Product Details
         * @param {DefaultApiGetFuturesProductDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesProductDetails(requestParameters: DefaultApiGetFuturesProductDetailsRequest, options?: RawAxiosRequestConfig): Promise<GetFuturesProductDetails200Response> {
            return localVarFp.getFuturesProductDetails(requestParameters.productCode, requestParameters.type, requestParameters.asOf, options).then((request) => request(axios, basePath));
        },
        /**
         * The Product-Specific Futures Schedules API provides detailed trading schedules for a specific futures product. This API allows you to query schedules for a single product across a range of dates. Users can access comprehensive information about trading sessions, including market events such as preopen, open, and closed, along with their precise timestamps.
         * @summary Product Schedules
         * @param {DefaultApiGetFuturesProductSchedulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesProductSchedules(requestParameters: DefaultApiGetFuturesProductSchedulesRequest, options?: RawAxiosRequestConfig): Promise<GetFuturesProductSchedules200Response> {
            return localVarFp.getFuturesProductSchedules(requestParameters.productCode, requestParameters.sessionEndDate, requestParameters.limit, requestParameters.sessionEndDateGte, requestParameters.sessionEndDateGt, requestParameters.sessionEndDateLte, requestParameters.sessionEndDateLt, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * The Products endpoint returns a list of futures products. This endpoint can be used to query for products based on a variety of parameters, including by the product\'s name, exchange, sector, sub-sector, asset class, asset sub-class, and type.
         * @summary Products
         * @param {DefaultApiGetFuturesProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesProducts(requestParameters: DefaultApiGetFuturesProductsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetFuturesProducts200Response> {
            return localVarFp.getFuturesProducts(requestParameters.name, requestParameters.asOf, requestParameters.tradingVenue, requestParameters.sector, requestParameters.subSector, requestParameters.assetClass, requestParameters.assetSubClass, requestParameters.type, requestParameters.limit, requestParameters.nameSearch, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get quotes for a contract in a given time range.
         * @summary Quotes
         * @param {DefaultApiGetFuturesQuotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesQuotes(requestParameters: DefaultApiGetFuturesQuotesRequest, options?: RawAxiosRequestConfig): Promise<GetFuturesQuotes200Response> {
            return localVarFp.getFuturesQuotes(requestParameters.ticker, requestParameters.timestamp, requestParameters.sessionEndDate, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.sessionEndDateGte, requestParameters.sessionEndDateGt, requestParameters.sessionEndDateLte, requestParameters.sessionEndDateLt, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a contract in a given time range.
         * @summary Trades
         * @param {DefaultApiGetFuturesTradesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesTrades(requestParameters: DefaultApiGetFuturesTradesRequest, options?: RawAxiosRequestConfig): Promise<GetFuturesTrades200Response> {
            return localVarFp.getFuturesTrades(requestParameters.ticker, requestParameters.timestamp, requestParameters.sessionEndDate, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.sessionEndDateGte, requestParameters.sessionEndDateGt, requestParameters.sessionEndDateLte, requestParameters.sessionEndDateLt, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information about a specific futures contract identified by its ticker. The response includes comprehensive attributes such as active status, trade dates, days to maturity, exchange code, order quantity limits, settlement date, tick sizes, and other key metrics. Users can specify a point-in-time (as_of) to view the contract\'s state on a particular date, supporting informed trading decisions and historical analysis.  Use Cases: Contract specification, historical product checks, system integration, trading decision support.
         * @summary futures_contracts_v1 API
         * @param {DefaultApiGetFuturesVXContractsNewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesVXContractsNew(requestParameters: DefaultApiGetFuturesVXContractsNewRequest = {}, options?: RawAxiosRequestConfig): Promise<GetFuturesVXContractsNew200Response> {
            return localVarFp.getFuturesVXContractsNew(requestParameters.date, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.productCode, requestParameters.productCodeAnyOf, requestParameters.productCodeGt, requestParameters.productCodeGte, requestParameters.productCodeLt, requestParameters.productCodeLte, requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.active, requestParameters.type, requestParameters.typeAnyOf, requestParameters.typeGt, requestParameters.typeGte, requestParameters.typeLt, requestParameters.typeLte, requestParameters.firstTradeDate, requestParameters.firstTradeDateGt, requestParameters.firstTradeDateGte, requestParameters.firstTradeDateLt, requestParameters.firstTradeDateLte, requestParameters.lastTradeDate, requestParameters.lastTradeDateGt, requestParameters.lastTradeDateGte, requestParameters.lastTradeDateLt, requestParameters.lastTradeDateLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * US futures exchanges and trading venues including major derivatives exchanges (CME, CBOT, NYMEX, COMEX) and other futures market infrastructure for commodity, financial, and other derivative contract trading.
         * @param {DefaultApiGetFuturesVXExchangesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesVXExchanges(requestParameters: DefaultApiGetFuturesVXExchangesRequest = {}, options?: RawAxiosRequestConfig): Promise<GetFuturesVXExchanges200Response> {
            return localVarFp.getFuturesVXExchanges(requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information about a single futures product as of a specified date, including its asset class, exchange code, full product name, settlement details, pricing quotation, sector classifications, and unit of measure. Optional parameters such as product type (single or combo) and as_of allow you to capture the products state on a specific day, providing essential context for trading decisions and system integrations.  Use Cases: Product specification, historical product checks, risk management, trading system integration.
         * @summary futures_products_v1 API
         * @param {DefaultApiGetFuturesVXProductsNewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesVXProductsNew(requestParameters: DefaultApiGetFuturesVXProductsNewRequest = {}, options?: RawAxiosRequestConfig): Promise<GetFuturesVXProductsNew200Response> {
            return localVarFp.getFuturesVXProductsNew(requestParameters.name, requestParameters.nameAnyOf, requestParameters.nameGt, requestParameters.nameGte, requestParameters.nameLt, requestParameters.nameLte, requestParameters.productCode, requestParameters.productCodeAnyOf, requestParameters.productCodeGt, requestParameters.productCodeGte, requestParameters.productCodeLt, requestParameters.productCodeLte, requestParameters.date, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.sector, requestParameters.sectorAnyOf, requestParameters.sectorGt, requestParameters.sectorGte, requestParameters.sectorLt, requestParameters.sectorLte, requestParameters.subSector, requestParameters.subSectorAnyOf, requestParameters.subSectorGt, requestParameters.subSectorGte, requestParameters.subSectorLt, requestParameters.subSectorLte, requestParameters.assetClass, requestParameters.assetClassAnyOf, requestParameters.assetClassGt, requestParameters.assetClassGte, requestParameters.assetClassLt, requestParameters.assetClassLte, requestParameters.assetSubClass, requestParameters.assetSubClassAnyOf, requestParameters.assetSubClassGt, requestParameters.assetSubClassGte, requestParameters.assetSubClassLt, requestParameters.assetSubClassLte, requestParameters.type, requestParameters.typeAnyOf, requestParameters.typeGt, requestParameters.typeGte, requestParameters.typeLt, requestParameters.typeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a snapshot of the most recent futures contract data.
         * @summary futures_snapshot_v1 API
         * @param {DefaultApiGetFuturesVXSnapshotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuturesVXSnapshot(requestParameters: DefaultApiGetFuturesVXSnapshotRequest = {}, options?: RawAxiosRequestConfig): Promise<GetFuturesVXSnapshot200Response> {
            return localVarFp.getFuturesVXSnapshot(requestParameters.productCode, requestParameters.productCodeAnyOf, requestParameters.productCodeGt, requestParameters.productCodeGte, requestParameters.productCodeLt, requestParameters.productCodeLte, requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
         * @summary Grouped Daily (Bars)
         * @param {DefaultApiGetGroupedCryptoAggregatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedCryptoAggregates(requestParameters: DefaultApiGetGroupedCryptoAggregatesRequest, options?: RawAxiosRequestConfig): Promise<GetGroupedCryptoAggregates200Response> {
            return localVarFp.getGroupedCryptoAggregates(requestParameters.date, requestParameters.adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
         * @summary Grouped Daily (Bars)
         * @param {DefaultApiGetGroupedForexAggregatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedForexAggregates(requestParameters: DefaultApiGetGroupedForexAggregatesRequest, options?: RawAxiosRequestConfig): Promise<GetGroupedCryptoAggregates200Response> {
            return localVarFp.getGroupedForexAggregates(requestParameters.date, requestParameters.adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
         * @summary Grouped Daily (Bars)
         * @param {DefaultApiGetGroupedStocksAggregatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedStocksAggregates(requestParameters: DefaultApiGetGroupedStocksAggregatesRequest, options?: RawAxiosRequestConfig): Promise<GetGroupedStocksAggregates200Response> {
            return localVarFp.getGroupedStocksAggregates(requestParameters.date, requestParameters.adjusted, requestParameters.includeOtc, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for an index over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {DefaultApiGetIndicesAggregatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesAggregates(requestParameters: DefaultApiGetIndicesAggregatesRequest, options?: RawAxiosRequestConfig): Promise<GetPreviousIndicesAggregates200Response> {
            return localVarFp.getIndicesAggregates(requestParameters.indicesTicker, requestParameters.multiplier, requestParameters.timespan, requestParameters.from, requestParameters.to, requestParameters.sort, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {DefaultApiGetIndicesEMARequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesEMA(requestParameters: DefaultApiGetIndicesEMARequest, options?: RawAxiosRequestConfig): Promise<GetCryptoEMA200Response> {
            return localVarFp.getIndicesEMA(requestParameters.indicesTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {DefaultApiGetIndicesMACDRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesMACD(requestParameters: DefaultApiGetIndicesMACDRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoMACD200Response> {
            return localVarFp.getIndicesMACD(requestParameters.indicesTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.shortWindow, requestParameters.longWindow, requestParameters.signalWindow, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the open, close and afterhours values of a index symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {DefaultApiGetIndicesOpenCloseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesOpenClose(requestParameters: DefaultApiGetIndicesOpenCloseRequest, options?: RawAxiosRequestConfig): Promise<GetIndicesOpenClose200Response> {
            return localVarFp.getIndicesOpenClose(requestParameters.indicesTicker, requestParameters.date, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {DefaultApiGetIndicesRSIRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesRSI(requestParameters: DefaultApiGetIndicesRSIRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoRSI200Response> {
            return localVarFp.getIndicesRSI(requestParameters.indicesTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {DefaultApiGetIndicesSMARequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesSMA(requestParameters: DefaultApiGetIndicesSMARequest, options?: RawAxiosRequestConfig): Promise<GetCryptoSMA200Response> {
            return localVarFp.getIndicesSMA(requestParameters.indicesTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Snapshot of indices data for said tickers
         * @summary Indices Snapshot
         * @param {DefaultApiGetIndicesSnapshotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicesSnapshot(requestParameters: DefaultApiGetIndicesSnapshotRequest = {}, options?: RawAxiosRequestConfig): Promise<GetIndicesSnapshot200Response> {
            return localVarFp.getIndicesSnapshot(requestParameters.tickerAnyOf, requestParameters.ticker, requestParameters.tickerGte, requestParameters.tickerGt, requestParameters.tickerLte, requestParameters.tickerLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the last trade tick for a cryptocurrency pair.
         * @summary Last Trade for a Crypto Pair
         * @param {DefaultApiGetLastCryptoTradeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastCryptoTrade(requestParameters: DefaultApiGetLastCryptoTradeRequest, options?: RawAxiosRequestConfig): Promise<GetLastCryptoTrade200Response> {
            return localVarFp.getLastCryptoTrade(requestParameters.from, requestParameters.to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the last quote tick for a forex currency pair.
         * @summary Last Quote for a Currency Pair
         * @param {DefaultApiGetLastCurrencyQuoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastCurrencyQuote(requestParameters: DefaultApiGetLastCurrencyQuoteRequest, options?: RawAxiosRequestConfig): Promise<GetLastCurrencyQuote200Response> {
            return localVarFp.getLastCurrencyQuote(requestParameters.from, requestParameters.to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most recent trade for a given options contract.
         * @summary Last Trade
         * @param {DefaultApiGetLastOptionsTradeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastOptionsTrade(requestParameters: DefaultApiGetLastOptionsTradeRequest, options?: RawAxiosRequestConfig): Promise<GetLastOptionsTrade200Response> {
            return localVarFp.getLastOptionsTrade(requestParameters.optionsTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most recent NBBO (Quote) tick for a given stock.
         * @summary Last Quote
         * @param {DefaultApiGetLastStocksQuoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastStocksQuote(requestParameters: DefaultApiGetLastStocksQuoteRequest, options?: RawAxiosRequestConfig): Promise<GetLastStocksQuote200Response> {
            return localVarFp.getLastStocksQuote(requestParameters.stocksTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most recent trade for a given stock.
         * @summary Last Trade
         * @param {DefaultApiGetLastStocksTradeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastStocksTrade(requestParameters: DefaultApiGetLastStocksTradeRequest, options?: RawAxiosRequestConfig): Promise<GetLastOptionsTrade200Response> {
            return localVarFp.getLastStocksTrade(requestParameters.stocksTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get upcoming market holidays and their open/close times.
         * @summary Market Holidays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketHolidays(options?: RawAxiosRequestConfig): Promise<Array<GetMarketHolidays200ResponseInner>> {
            return localVarFp.getMarketHolidays(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current trading status of the exchanges and overall financial markets.
         * @summary Market Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketStatus(options?: RawAxiosRequestConfig): Promise<GetMarketStatus200Response> {
            return localVarFp.getMarketStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the snapshot of an option contract for a stock equity.
         * @summary Option Contract
         * @param {DefaultApiGetOptionContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionContract(requestParameters: DefaultApiGetOptionContractRequest, options?: RawAxiosRequestConfig): Promise<GetOptionContract200Response> {
            return localVarFp.getOptionContract(requestParameters.underlyingAsset, requestParameters.optionContract, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for an option contract over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {DefaultApiGetOptionsAggregatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsAggregates(requestParameters: DefaultApiGetOptionsAggregatesRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoAggregates200Response> {
            return localVarFp.getOptionsAggregates(requestParameters.optionsTicker, requestParameters.multiplier, requestParameters.timespan, requestParameters.from, requestParameters.to, requestParameters.adjusted, requestParameters.sort, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the snapshot of all options contracts for an underlying ticker.
         * @summary Options Chain
         * @param {DefaultApiGetOptionsChainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsChain(requestParameters: DefaultApiGetOptionsChainRequest, options?: RawAxiosRequestConfig): Promise<GetOptionsChain200Response> {
            return localVarFp.getOptionsChain(requestParameters.underlyingAsset, requestParameters.strikePrice, requestParameters.expirationDate, requestParameters.contractType, requestParameters.strikePriceGte, requestParameters.strikePriceGt, requestParameters.strikePriceLte, requestParameters.strikePriceLt, requestParameters.expirationDateGte, requestParameters.expirationDateGt, requestParameters.expirationDateLte, requestParameters.expirationDateLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an options contract
         * @summary Options Contract
         * @param {DefaultApiGetOptionsContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsContract(requestParameters: DefaultApiGetOptionsContractRequest, options?: RawAxiosRequestConfig): Promise<GetOptionsContract200Response> {
            return localVarFp.getOptionsContract(requestParameters.optionsTicker, requestParameters.asOf, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {DefaultApiGetOptionsEMARequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsEMA(requestParameters: DefaultApiGetOptionsEMARequest, options?: RawAxiosRequestConfig): Promise<GetCryptoEMA200Response> {
            return localVarFp.getOptionsEMA(requestParameters.optionsTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {DefaultApiGetOptionsMACDRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsMACD(requestParameters: DefaultApiGetOptionsMACDRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoMACD200Response> {
            return localVarFp.getOptionsMACD(requestParameters.optionsTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.shortWindow, requestParameters.longWindow, requestParameters.signalWindow, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the open, close and afterhours prices of an options contract on a certain date. 
         * @summary Daily Open/Close
         * @param {DefaultApiGetOptionsOpenCloseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsOpenClose(requestParameters: DefaultApiGetOptionsOpenCloseRequest, options?: RawAxiosRequestConfig): Promise<GetOptionsOpenClose200Response> {
            return localVarFp.getOptionsOpenClose(requestParameters.optionsTicker, requestParameters.date, requestParameters.adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get quotes for an options ticker symbol in a given time range.
         * @summary Quotes
         * @param {DefaultApiGetOptionsQuotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsQuotes(requestParameters: DefaultApiGetOptionsQuotesRequest, options?: RawAxiosRequestConfig): Promise<GetOptionsQuotes200Response> {
            return localVarFp.getOptionsQuotes(requestParameters.optionsTicker, requestParameters.timestamp, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {DefaultApiGetOptionsRSIRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsRSI(requestParameters: DefaultApiGetOptionsRSIRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoRSI200Response> {
            return localVarFp.getOptionsRSI(requestParameters.optionsTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {DefaultApiGetOptionsSMARequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsSMA(requestParameters: DefaultApiGetOptionsSMARequest, options?: RawAxiosRequestConfig): Promise<GetCryptoSMA200Response> {
            return localVarFp.getOptionsSMA(requestParameters.optionsTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for an options ticker symbol in a given time range.
         * @summary Trades
         * @param {DefaultApiGetOptionsTradesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsTrades(requestParameters: DefaultApiGetOptionsTradesRequest, options?: RawAxiosRequestConfig): Promise<GetOptionsTrades200Response> {
            return localVarFp.getOptionsTrades(requestParameters.optionsTicker, requestParameters.timestamp, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * US options exchanges and trading venues including traditional options exchanges (CBOE, ISE, etc.), Securities Information Processors (SIP), and other options market infrastructure for derivatives trading.
         * @param {DefaultApiGetOptionsV1ExchangesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsV1Exchanges(requestParameters: DefaultApiGetOptionsV1ExchangesRequest = {}, options?: RawAxiosRequestConfig): Promise<GetOptionsV1Exchanges200Response> {
            return localVarFp.getOptionsV1Exchanges(requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
         * @summary Previous Close
         * @param {DefaultApiGetPreviousCryptoAggregatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousCryptoAggregates(requestParameters: DefaultApiGetPreviousCryptoAggregatesRequest, options?: RawAxiosRequestConfig): Promise<GetPreviousCryptoAggregates200Response> {
            return localVarFp.getPreviousCryptoAggregates(requestParameters.cryptoTicker, requestParameters.adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified forex pair. 
         * @summary Previous Close
         * @param {DefaultApiGetPreviousForexAggregatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousForexAggregates(requestParameters: DefaultApiGetPreviousForexAggregatesRequest, options?: RawAxiosRequestConfig): Promise<GetPreviousForexAggregates200Response> {
            return localVarFp.getPreviousForexAggregates(requestParameters.forexTicker, requestParameters.adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified index. 
         * @summary Previous Close
         * @param {DefaultApiGetPreviousIndicesAggregatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousIndicesAggregates(requestParameters: DefaultApiGetPreviousIndicesAggregatesRequest, options?: RawAxiosRequestConfig): Promise<GetPreviousIndicesAggregates200Response> {
            return localVarFp.getPreviousIndicesAggregates(requestParameters.indicesTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified option contract. 
         * @summary Previous Close
         * @param {DefaultApiGetPreviousOptionsAggregatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousOptionsAggregates(requestParameters: DefaultApiGetPreviousOptionsAggregatesRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoAggregates200Response> {
            return localVarFp.getPreviousOptionsAggregates(requestParameters.optionsTicker, requestParameters.adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the previous day\'s open, high, low, and close (OHLC) for the specified stock ticker. 
         * @summary Previous Close
         * @param {DefaultApiGetPreviousStocksAggregatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousStocksAggregates(requestParameters: DefaultApiGetPreviousStocksAggregatesRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoAggregates200Response> {
            return localVarFp.getPreviousStocksAggregates(requestParameters.stocksTicker, requestParameters.adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of tickers related to the queried ticker based on News and Returns data.
         * @summary Related Companies
         * @param {DefaultApiGetRelatedCompaniesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedCompanies(requestParameters: DefaultApiGetRelatedCompaniesRequest, options?: RawAxiosRequestConfig): Promise<GetRelatedCompanies200Response> {
            return localVarFp.getRelatedCompanies(requestParameters.ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
         * @summary Summaries
         * @param {DefaultApiGetSnapshotSummaryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotSummary(requestParameters: DefaultApiGetSnapshotSummaryRequest = {}, options?: RawAxiosRequestConfig): Promise<GetSnapshotSummary200Response> {
            return localVarFp.getSnapshotSummary(requestParameters.tickerAnyOf, options).then((request) => request(axios, basePath));
        },
        /**
         * Get snapshots for assets of all types
         * @summary Universal Snapshot
         * @param {DefaultApiGetSnapshotsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshots(requestParameters: DefaultApiGetSnapshotsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetSnapshots200Response> {
            return localVarFp.getSnapshots(requestParameters.ticker, requestParameters.type, requestParameters.tickerGte, requestParameters.tickerGt, requestParameters.tickerLte, requestParameters.tickerLt, requestParameters.tickerAnyOf, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregate bars for a stock over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
         * @summary Aggregates (Bars)
         * @param {DefaultApiGetStocksAggregatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksAggregates(requestParameters: DefaultApiGetStocksAggregatesRequest, options?: RawAxiosRequestConfig): Promise<GetStocksAggregates200Response> {
            return localVarFp.getStocksAggregates(requestParameters.stocksTicker, requestParameters.multiplier, requestParameters.timespan, requestParameters.from, requestParameters.to, requestParameters.adjusted, requestParameters.sort, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
         * @summary Exponential Moving Average (EMA)
         * @param {DefaultApiGetStocksEMARequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksEMA(requestParameters: DefaultApiGetStocksEMARequest, options?: RawAxiosRequestConfig): Promise<GetCryptoEMA200Response> {
            return localVarFp.getStocksEMA(requestParameters.stockTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * A comprehensive financial dataset containing quarterly and annual balance sheet data for public companies. Includes detailed asset, liability, and equity positions representing the company\'s financial position at specific points in time. Balance sheet data represents point-in-time snapshots rather than cumulative flows, showing what the company owns, owes, and shareholders\' equity as of each period end date.
         * @param {DefaultApiGetStocksFinancialsV1BalanceSheetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksFinancialsV1BalanceSheets(requestParameters: DefaultApiGetStocksFinancialsV1BalanceSheetsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetStocksFinancialsV1BalanceSheets200Response> {
            return localVarFp.getStocksFinancialsV1BalanceSheets(requestParameters.cik, requestParameters.cikAnyOf, requestParameters.cikGt, requestParameters.cikGte, requestParameters.cikLt, requestParameters.cikLte, requestParameters.tickers, requestParameters.tickersAllOf, requestParameters.tickersAnyOf, requestParameters.periodEnd, requestParameters.periodEndGt, requestParameters.periodEndGte, requestParameters.periodEndLt, requestParameters.periodEndLte, requestParameters.filingDate, requestParameters.filingDateGt, requestParameters.filingDateGte, requestParameters.filingDateLt, requestParameters.filingDateLte, requestParameters.fiscalYear, requestParameters.fiscalYearGt, requestParameters.fiscalYearGte, requestParameters.fiscalYearLt, requestParameters.fiscalYearLte, requestParameters.fiscalQuarter, requestParameters.fiscalQuarterGt, requestParameters.fiscalQuarterGte, requestParameters.fiscalQuarterLt, requestParameters.fiscalQuarterLte, requestParameters.timeframe, requestParameters.timeframeAnyOf, requestParameters.timeframeGt, requestParameters.timeframeGte, requestParameters.timeframeLt, requestParameters.timeframeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * A comprehensive financial dataset containing quarterly, annual, and trailing twelve-month cash flow statement data for public companies. Includes detailed operating, investing, and financing cash flows with proper TTM calculations that sum all cash flow components over four quarters. TTM records are validated to ensure exactly four distinct quarters spanning 250-400 days for accurate trailing twelve-month cash flow analysis.
         * @param {DefaultApiGetStocksFinancialsV1CashFlowStatementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksFinancialsV1CashFlowStatements(requestParameters: DefaultApiGetStocksFinancialsV1CashFlowStatementsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetStocksFinancialsV1CashFlowStatements200Response> {
            return localVarFp.getStocksFinancialsV1CashFlowStatements(requestParameters.cik, requestParameters.cikAnyOf, requestParameters.cikGt, requestParameters.cikGte, requestParameters.cikLt, requestParameters.cikLte, requestParameters.periodEnd, requestParameters.periodEndGt, requestParameters.periodEndGte, requestParameters.periodEndLt, requestParameters.periodEndLte, requestParameters.filingDate, requestParameters.filingDateGt, requestParameters.filingDateGte, requestParameters.filingDateLt, requestParameters.filingDateLte, requestParameters.tickers, requestParameters.tickersAllOf, requestParameters.tickersAnyOf, requestParameters.fiscalYear, requestParameters.fiscalYearGt, requestParameters.fiscalYearGte, requestParameters.fiscalYearLt, requestParameters.fiscalYearLte, requestParameters.fiscalQuarter, requestParameters.fiscalQuarterGt, requestParameters.fiscalQuarterGte, requestParameters.fiscalQuarterLt, requestParameters.fiscalQuarterLte, requestParameters.timeframe, requestParameters.timeframeAnyOf, requestParameters.timeframeGt, requestParameters.timeframeGte, requestParameters.timeframeLt, requestParameters.timeframeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * A comprehensive database of income statement financial data for public companies, including key metrics such as revenue, expenses, and net income for various reporting periods.
         * @param {DefaultApiGetStocksFinancialsV1IncomeStatementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksFinancialsV1IncomeStatements(requestParameters: DefaultApiGetStocksFinancialsV1IncomeStatementsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetStocksFinancialsV1IncomeStatements200Response> {
            return localVarFp.getStocksFinancialsV1IncomeStatements(requestParameters.cik, requestParameters.cikAnyOf, requestParameters.cikGt, requestParameters.cikGte, requestParameters.cikLt, requestParameters.cikLte, requestParameters.tickers, requestParameters.tickersAllOf, requestParameters.tickersAnyOf, requestParameters.periodEnd, requestParameters.periodEndGt, requestParameters.periodEndGte, requestParameters.periodEndLt, requestParameters.periodEndLte, requestParameters.filingDate, requestParameters.filingDateGt, requestParameters.filingDateGte, requestParameters.filingDateLt, requestParameters.filingDateLte, requestParameters.fiscalYear, requestParameters.fiscalYearGt, requestParameters.fiscalYearGte, requestParameters.fiscalYearLt, requestParameters.fiscalYearLte, requestParameters.fiscalQuarter, requestParameters.fiscalQuarterGt, requestParameters.fiscalQuarterGte, requestParameters.fiscalQuarterLt, requestParameters.fiscalQuarterLte, requestParameters.timeframe, requestParameters.timeframeAnyOf, requestParameters.timeframeGt, requestParameters.timeframeGte, requestParameters.timeframeLt, requestParameters.timeframeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * A comprehensive financial ratios dataset providing key valuation, profitability, liquidity, and leverage metrics for public companies. Combines data from income statements, balance sheets, and cash flow statements with daily stock prices to calculate ratios on a daily basis. Uses trailing twelve months (TTM) data for income/cash flow metrics and quarterly data for balance sheet items. Fundamental data updates are applied starting from each filing\'s period end date. Market cap calculations use point-in-time shares outstanding for historical accuracy.
         * @param {DefaultApiGetStocksFinancialsV1RatiosRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksFinancialsV1Ratios(requestParameters: DefaultApiGetStocksFinancialsV1RatiosRequest = {}, options?: RawAxiosRequestConfig): Promise<GetStocksFinancialsV1Ratios200Response> {
            return localVarFp.getStocksFinancialsV1Ratios(requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.cik, requestParameters.cikAnyOf, requestParameters.cikGt, requestParameters.cikGte, requestParameters.cikLt, requestParameters.cikLte, requestParameters.price, requestParameters.priceGt, requestParameters.priceGte, requestParameters.priceLt, requestParameters.priceLte, requestParameters.averageVolume, requestParameters.averageVolumeGt, requestParameters.averageVolumeGte, requestParameters.averageVolumeLt, requestParameters.averageVolumeLte, requestParameters.marketCap, requestParameters.marketCapGt, requestParameters.marketCapGte, requestParameters.marketCapLt, requestParameters.marketCapLte, requestParameters.earningsPerShare, requestParameters.earningsPerShareGt, requestParameters.earningsPerShareGte, requestParameters.earningsPerShareLt, requestParameters.earningsPerShareLte, requestParameters.priceToEarnings, requestParameters.priceToEarningsGt, requestParameters.priceToEarningsGte, requestParameters.priceToEarningsLt, requestParameters.priceToEarningsLte, requestParameters.priceToBook, requestParameters.priceToBookGt, requestParameters.priceToBookGte, requestParameters.priceToBookLt, requestParameters.priceToBookLte, requestParameters.priceToSales, requestParameters.priceToSalesGt, requestParameters.priceToSalesGte, requestParameters.priceToSalesLt, requestParameters.priceToSalesLte, requestParameters.priceToCashFlow, requestParameters.priceToCashFlowGt, requestParameters.priceToCashFlowGte, requestParameters.priceToCashFlowLt, requestParameters.priceToCashFlowLte, requestParameters.priceToFreeCashFlow, requestParameters.priceToFreeCashFlowGt, requestParameters.priceToFreeCashFlowGte, requestParameters.priceToFreeCashFlowLt, requestParameters.priceToFreeCashFlowLte, requestParameters.dividendYield, requestParameters.dividendYieldGt, requestParameters.dividendYieldGte, requestParameters.dividendYieldLt, requestParameters.dividendYieldLte, requestParameters.returnOnAssets, requestParameters.returnOnAssetsGt, requestParameters.returnOnAssetsGte, requestParameters.returnOnAssetsLt, requestParameters.returnOnAssetsLte, requestParameters.returnOnEquity, requestParameters.returnOnEquityGt, requestParameters.returnOnEquityGte, requestParameters.returnOnEquityLt, requestParameters.returnOnEquityLte, requestParameters.debtToEquity, requestParameters.debtToEquityGt, requestParameters.debtToEquityGte, requestParameters.debtToEquityLt, requestParameters.debtToEquityLte, requestParameters.current, requestParameters.currentGt, requestParameters.currentGte, requestParameters.currentLt, requestParameters.currentLte, requestParameters.quick, requestParameters.quickGt, requestParameters.quickGte, requestParameters.quickLt, requestParameters.quickLte, requestParameters.cash, requestParameters.cashGt, requestParameters.cashGte, requestParameters.cashLt, requestParameters.cashLte, requestParameters.evToSales, requestParameters.evToSalesGt, requestParameters.evToSalesGte, requestParameters.evToSalesLt, requestParameters.evToSalesLte, requestParameters.evToEbitda, requestParameters.evToEbitdaGt, requestParameters.evToEbitdaGte, requestParameters.evToEbitdaLt, requestParameters.evToEbitdaLte, requestParameters.enterpriseValue, requestParameters.enterpriseValueGt, requestParameters.enterpriseValueGte, requestParameters.enterpriseValueLt, requestParameters.enterpriseValueLte, requestParameters.freeCashFlow, requestParameters.freeCashFlowGt, requestParameters.freeCashFlowGte, requestParameters.freeCashFlowLt, requestParameters.freeCashFlowLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
         * @summary Moving Average Convergence/Divergence (MACD)
         * @param {DefaultApiGetStocksMACDRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksMACD(requestParameters: DefaultApiGetStocksMACDRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoMACD200Response> {
            return localVarFp.getStocksMACD(requestParameters.stockTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.shortWindow, requestParameters.longWindow, requestParameters.signalWindow, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the open, close and afterhours prices of a stock symbol on a certain date. 
         * @summary Daily Open/Close
         * @param {DefaultApiGetStocksOpenCloseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksOpenClose(requestParameters: DefaultApiGetStocksOpenCloseRequest, options?: RawAxiosRequestConfig): Promise<GetOptionsOpenClose200Response> {
            return localVarFp.getStocksOpenClose(requestParameters.stocksTicker, requestParameters.date, requestParameters.adjusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get NBBO quotes for a ticker symbol in a given time range.
         * @summary Quotes (NBBO)
         * @param {DefaultApiGetStocksQuotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksQuotes(requestParameters: DefaultApiGetStocksQuotesRequest, options?: RawAxiosRequestConfig): Promise<GetStocksQuotes200Response> {
            return localVarFp.getStocksQuotes(requestParameters.stockTicker, requestParameters.timestamp, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the relative strength index (RSI) for a ticker symbol over a given time range.
         * @summary Relative Strength Index (RSI)
         * @param {DefaultApiGetStocksRSIRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksRSI(requestParameters: DefaultApiGetStocksRSIRequest, options?: RawAxiosRequestConfig): Promise<GetCryptoRSI200Response> {
            return localVarFp.getStocksRSI(requestParameters.stockTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the simple moving average (SMA) for a ticker symbol over a given time range.
         * @summary Simple Moving Average (SMA)
         * @param {DefaultApiGetStocksSMARequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSMA(requestParameters: DefaultApiGetStocksSMARequest, options?: RawAxiosRequestConfig): Promise<GetCryptoSMA200Response> {
            return localVarFp.getStocksSMA(requestParameters.stockTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. This output will only include tickers with a trading volume of 10,000 or more. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
         * @summary Gainers/Losers
         * @param {DefaultApiGetStocksSnapshotDirectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSnapshotDirection(requestParameters: DefaultApiGetStocksSnapshotDirectionRequest, options?: RawAxiosRequestConfig): Promise<GetStocksSnapshotDirection200Response> {
            return localVarFp.getStocksSnapshotDirection(requestParameters.direction, requestParameters.includeOtc, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most up-to-date market data for a single traded stock ticker. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary Ticker
         * @param {DefaultApiGetStocksSnapshotTickerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSnapshotTicker(requestParameters: DefaultApiGetStocksSnapshotTickerRequest, options?: RawAxiosRequestConfig): Promise<GetStocksSnapshotTicker200Response> {
            return localVarFp.getStocksSnapshotTicker(requestParameters.stocksTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most up-to-date market data for all traded stock symbols. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
         * @summary All Tickers
         * @param {DefaultApiGetStocksSnapshotTickersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksSnapshotTickers(requestParameters: DefaultApiGetStocksSnapshotTickersRequest = {}, options?: RawAxiosRequestConfig): Promise<GetStocksSnapshotTickers200Response> {
            return localVarFp.getStocksSnapshotTickers(requestParameters.tickers, requestParameters.includeOtc, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades for a ticker symbol in a given time range.
         * @summary Trades
         * @param {DefaultApiGetStocksTradesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksTrades(requestParameters: DefaultApiGetStocksTradesRequest, options?: RawAxiosRequestConfig): Promise<GetStocksTrades200Response> {
            return localVarFp.getStocksTrades(requestParameters.stockTicker, requestParameters.timestamp, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Contains historical dividend payment records for US stocks with split-adjusted amounts and historical adjustment factors for price normalization.
         * @param {DefaultApiGetStocksV1DividendsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksV1Dividends(requestParameters: DefaultApiGetStocksV1DividendsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetStocksV1Dividends200Response> {
            return localVarFp.getStocksV1Dividends(requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.exDividendDate, requestParameters.exDividendDateGt, requestParameters.exDividendDateGte, requestParameters.exDividendDateLt, requestParameters.exDividendDateLte, requestParameters.frequency, requestParameters.frequencyGt, requestParameters.frequencyGte, requestParameters.frequencyLt, requestParameters.frequencyLte, requestParameters.distributionType, requestParameters.distributionTypeAnyOf, requestParameters.distributionTypeGt, requestParameters.distributionTypeGte, requestParameters.distributionTypeLt, requestParameters.distributionTypeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * US stock exchanges, trading venues, and reporting facilities including exchanges (NYSE, Nasdaq), Trade Reporting Facilities (TRF), Securities Information Processors (SIP), and OTC Reporting Facilities (ORF) for equity trading.
         * @param {DefaultApiGetStocksV1ExchangesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksV1Exchanges(requestParameters: DefaultApiGetStocksV1ExchangesRequest = {}, options?: RawAxiosRequestConfig): Promise<GetStocksV1Exchanges200Response> {
            return localVarFp.getStocksV1Exchanges(requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Comprehensive FINRA short interest data that tracks the short selling metrics for securities on a specific settlement date.
         * @param {DefaultApiGetStocksV1ShortInterestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksV1ShortInterest(requestParameters: DefaultApiGetStocksV1ShortInterestRequest = {}, options?: RawAxiosRequestConfig): Promise<GetStocksV1ShortInterest200Response> {
            return localVarFp.getStocksV1ShortInterest(requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.daysToCover, requestParameters.daysToCoverAnyOf, requestParameters.daysToCoverGt, requestParameters.daysToCoverGte, requestParameters.daysToCoverLt, requestParameters.daysToCoverLte, requestParameters.settlementDate, requestParameters.settlementDateAnyOf, requestParameters.settlementDateGt, requestParameters.settlementDateGte, requestParameters.settlementDateLt, requestParameters.settlementDateLte, requestParameters.avgDailyVolume, requestParameters.avgDailyVolumeAnyOf, requestParameters.avgDailyVolumeGt, requestParameters.avgDailyVolumeGte, requestParameters.avgDailyVolumeLt, requestParameters.avgDailyVolumeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Contains short selling volume for different stock tickers, capturing total trading volume, short sale details, and breakdown by different trading platforms.
         * @param {DefaultApiGetStocksV1ShortVolumeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksV1ShortVolume(requestParameters: DefaultApiGetStocksV1ShortVolumeRequest = {}, options?: RawAxiosRequestConfig): Promise<GetStocksV1ShortVolume200Response> {
            return localVarFp.getStocksV1ShortVolume(requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.shortVolumeRatio, requestParameters.shortVolumeRatioAnyOf, requestParameters.shortVolumeRatioGt, requestParameters.shortVolumeRatioGte, requestParameters.shortVolumeRatioLt, requestParameters.shortVolumeRatioLte, requestParameters.totalVolume, requestParameters.totalVolumeAnyOf, requestParameters.totalVolumeGt, requestParameters.totalVolumeGte, requestParameters.totalVolumeLt, requestParameters.totalVolumeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Contains historical stock split and reverse split events for US equities with historical adjustment factors for price normalization.
         * @param {DefaultApiGetStocksV1SplitsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStocksV1Splits(requestParameters: DefaultApiGetStocksV1SplitsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetStocksV1Splits200Response> {
            return localVarFp.getStocksV1Splits(requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.executionDate, requestParameters.executionDateGt, requestParameters.executionDateGte, requestParameters.executionDateLt, requestParameters.executionDateLte, requestParameters.adjustmentType, requestParameters.adjustmentTypeAnyOf, requestParameters.adjustmentTypeGt, requestParameters.adjustmentTypeGte, requestParameters.adjustmentTypeLt, requestParameters.adjustmentTypeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single ticker supported by Massive.com. This response will have detailed information about the ticker and the company behind it.
         * @summary Ticker Details v3
         * @param {DefaultApiGetTickerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicker(requestParameters: DefaultApiGetTickerRequest, options?: RawAxiosRequestConfig): Promise<GetTicker200Response> {
            return localVarFp.getTicker(requestParameters.ticker, requestParameters.date, options).then((request) => request(axios, basePath));
        },
        /**
         * Contains corporate events and announcements for publicly traded companies, including earnings releases, conferences, dividends, and business updates sourced from TMX.
         * @param {DefaultApiGetTmxV1CorporateEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTmxV1CorporateEvents(requestParameters: DefaultApiGetTmxV1CorporateEventsRequest = {}, options?: RawAxiosRequestConfig): Promise<GetTmxV1CorporateEvents200Response> {
            return localVarFp.getTmxV1CorporateEvents(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.type, requestParameters.typeAnyOf, requestParameters.typeGt, requestParameters.typeGte, requestParameters.typeLt, requestParameters.typeLte, requestParameters.status, requestParameters.statusAnyOf, requestParameters.statusGt, requestParameters.statusGte, requestParameters.statusLt, requestParameters.statusLte, requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.isin, requestParameters.isinAnyOf, requestParameters.isinGt, requestParameters.isinGte, requestParameters.isinLt, requestParameters.isinLte, requestParameters.tradingVenue, requestParameters.tradingVenueAnyOf, requestParameters.tradingVenueGt, requestParameters.tradingVenueGte, requestParameters.tradingVenueLt, requestParameters.tradingVenueLte, requestParameters.tmxCompanyId, requestParameters.tmxCompanyIdGt, requestParameters.tmxCompanyIdGte, requestParameters.tmxCompanyIdLt, requestParameters.tmxCompanyIdLte, requestParameters.tmxRecordId, requestParameters.tmxRecordIdAnyOf, requestParameters.tmxRecordIdGt, requestParameters.tmxRecordIdGte, requestParameters.tmxRecordIdLt, requestParameters.tmxRecordIdLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * List all conditions that Massive uses.
         * @summary Conditions
         * @param {DefaultApiListConditionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConditions(requestParameters: DefaultApiListConditionsRequest = {}, options?: RawAxiosRequestConfig): Promise<ListConditions200Response> {
            return localVarFp.listConditions(requestParameters.assetClass, requestParameters.dataType, requestParameters.id, requestParameters.sip, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
         * @summary Dividends v3
         * @param {DefaultApiListDividendsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDividends(requestParameters: DefaultApiListDividendsRequest = {}, options?: RawAxiosRequestConfig): Promise<ListDividends200Response> {
            return localVarFp.listDividends(requestParameters.ticker, requestParameters.exDividendDate, requestParameters.recordDate, requestParameters.declarationDate, requestParameters.payDate, requestParameters.frequency, requestParameters.cashAmount, requestParameters.dividendType, requestParameters.tickerGte, requestParameters.tickerGt, requestParameters.tickerLte, requestParameters.tickerLt, requestParameters.exDividendDateGte, requestParameters.exDividendDateGt, requestParameters.exDividendDateLte, requestParameters.exDividendDateLt, requestParameters.recordDateGte, requestParameters.recordDateGt, requestParameters.recordDateLte, requestParameters.recordDateLt, requestParameters.declarationDateGte, requestParameters.declarationDateGt, requestParameters.declarationDateLte, requestParameters.declarationDateLt, requestParameters.payDateGte, requestParameters.payDateGt, requestParameters.payDateLte, requestParameters.payDateLt, requestParameters.cashAmountGte, requestParameters.cashAmountGt, requestParameters.cashAmountLte, requestParameters.cashAmountLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * List all exchanges that Massive knows about.
         * @summary Exchanges
         * @param {DefaultApiListExchangesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExchanges(requestParameters: DefaultApiListExchangesRequest = {}, options?: RawAxiosRequestConfig): Promise<ListExchanges200Response> {
            return localVarFp.listExchanges(requestParameters.assetClass, requestParameters.locale, options).then((request) => request(axios, basePath));
        },
        /**
         * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\">here</a>.
         * @summary Stock Financials vX
         * @param {DefaultApiListFinancialsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFinancials(requestParameters: DefaultApiListFinancialsRequest = {}, options?: RawAxiosRequestConfig): Promise<ListFinancials200Response> {
            return localVarFp.listFinancials(requestParameters.ticker, requestParameters.cik, requestParameters.companyName, requestParameters.sic, requestParameters.filingDate, requestParameters.periodOfReportDate, requestParameters.timeframe, requestParameters.includeSources, requestParameters.companyNameSearch, requestParameters.filingDateGte, requestParameters.filingDateGt, requestParameters.filingDateLte, requestParameters.filingDateLt, requestParameters.periodOfReportDateGte, requestParameters.periodOfReportDateGt, requestParameters.periodOfReportDateLte, requestParameters.periodOfReportDateLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
         * @summary IPOs
         * @param {DefaultApiListIPOsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIPOs(requestParameters: DefaultApiListIPOsRequest = {}, options?: RawAxiosRequestConfig): Promise<ListIPOs200Response> {
            return localVarFp.listIPOs(requestParameters.ticker, requestParameters.usCode, requestParameters.isin, requestParameters.listingDate, requestParameters.ipoStatus, requestParameters.listingDateGte, requestParameters.listingDateGt, requestParameters.listingDateLte, requestParameters.listingDateLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
         * @summary Ticker News
         * @param {DefaultApiListNewsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNews(requestParameters: DefaultApiListNewsRequest = {}, options?: RawAxiosRequestConfig): Promise<ListNews200Response> {
            return localVarFp.listNews(requestParameters.ticker, requestParameters.publishedUtc, requestParameters.tickerGte, requestParameters.tickerGt, requestParameters.tickerLte, requestParameters.tickerLt, requestParameters.publishedUtcGte, requestParameters.publishedUtcGt, requestParameters.publishedUtcLte, requestParameters.publishedUtcLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Query for historical options contracts. This provides both active and expired options contracts.
         * @summary Options Contracts
         * @param {DefaultApiListOptionsContractsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOptionsContracts(requestParameters: DefaultApiListOptionsContractsRequest = {}, options?: RawAxiosRequestConfig): Promise<ListOptionsContracts200Response> {
            return localVarFp.listOptionsContracts(requestParameters.underlyingTicker, requestParameters.ticker, requestParameters.contractType, requestParameters.expirationDate, requestParameters.asOf, requestParameters.strikePrice, requestParameters.expired, requestParameters.underlyingTickerGte, requestParameters.underlyingTickerGt, requestParameters.underlyingTickerLte, requestParameters.underlyingTickerLt, requestParameters.expirationDateGte, requestParameters.expirationDateGt, requestParameters.expirationDateLte, requestParameters.expirationDateLt, requestParameters.strikePriceGte, requestParameters.strikePriceGt, requestParameters.strikePriceLte, requestParameters.strikePriceLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
         * @summary Stock Splits v3
         * @param {DefaultApiListStockSplitsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStockSplits(requestParameters: DefaultApiListStockSplitsRequest = {}, options?: RawAxiosRequestConfig): Promise<ListStockSplits200Response> {
            return localVarFp.listStockSplits(requestParameters.ticker, requestParameters.executionDate, requestParameters.reverseSplit, requestParameters.tickerGte, requestParameters.tickerGt, requestParameters.tickerLte, requestParameters.tickerLt, requestParameters.executionDateGte, requestParameters.executionDateGt, requestParameters.executionDateLte, requestParameters.executionDateLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * List all ticker types that Massive.com has.
         * @summary Ticker Types
         * @param {DefaultApiListTickerTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickerTypes(requestParameters: DefaultApiListTickerTypesRequest = {}, options?: RawAxiosRequestConfig): Promise<ListTickerTypes200Response> {
            return localVarFp.listTickerTypes(requestParameters.assetClass, requestParameters.locale, options).then((request) => request(axios, basePath));
        },
        /**
         * Query all ticker symbols which are supported by Massive.com. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
         * @summary Tickers
         * @param {DefaultApiListTickersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickers(requestParameters: DefaultApiListTickersRequest = {}, options?: RawAxiosRequestConfig): Promise<ListTickers200Response> {
            return localVarFp.listTickers(requestParameters.ticker, requestParameters.type, requestParameters.market, requestParameters.exchange, requestParameters.cusip, requestParameters.cik, requestParameters.date, requestParameters.search, requestParameters.active, requestParameters.tickerGte, requestParameters.tickerGt, requestParameters.tickerLte, requestParameters.tickerLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deprecatedGetCryptoSnapshotTickerBook operation in DefaultApi.
 * @export
 * @interface DefaultApiDeprecatedGetCryptoSnapshotTickerBookRequest
 */
export interface DefaultApiDeprecatedGetCryptoSnapshotTickerBookRequest {
    /**
     * The cryptocurrency ticker.
     * @type {string}
     * @memberof DefaultApiDeprecatedGetCryptoSnapshotTickerBook
     */
    readonly ticker: string
}

/**
 * Request parameters for deprecatedGetHistoricCryptoTrades operation in DefaultApi.
 * @export
 * @interface DefaultApiDeprecatedGetHistoricCryptoTradesRequest
 */
export interface DefaultApiDeprecatedGetHistoricCryptoTradesRequest {
    /**
     * The \&quot;from\&quot; symbol of the crypto pair.
     * @type {string}
     * @memberof DefaultApiDeprecatedGetHistoricCryptoTrades
     */
    readonly from: string

    /**
     * The \&quot;to\&quot; symbol of the crypto pair.
     * @type {string}
     * @memberof DefaultApiDeprecatedGetHistoricCryptoTrades
     */
    readonly to: string

    /**
     * The date/day of the historic ticks to retrieve.
     * @type {string}
     * @memberof DefaultApiDeprecatedGetHistoricCryptoTrades
     */
    readonly date: string

    /**
     * The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @type {number}
     * @memberof DefaultApiDeprecatedGetHistoricCryptoTrades
     */
    readonly offset?: number

    /**
     * Limit the size of the response, max 10000.
     * @type {number}
     * @memberof DefaultApiDeprecatedGetHistoricCryptoTrades
     */
    readonly limit?: number
}

/**
 * Request parameters for deprecatedGetHistoricForexQuotes operation in DefaultApi.
 * @export
 * @interface DefaultApiDeprecatedGetHistoricForexQuotesRequest
 */
export interface DefaultApiDeprecatedGetHistoricForexQuotesRequest {
    /**
     * The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
     * @type {string}
     * @memberof DefaultApiDeprecatedGetHistoricForexQuotes
     */
    readonly from: string

    /**
     * The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
     * @type {string}
     * @memberof DefaultApiDeprecatedGetHistoricForexQuotes
     */
    readonly to: string

    /**
     * The date/day of the historic ticks to retrieve.
     * @type {string}
     * @memberof DefaultApiDeprecatedGetHistoricForexQuotes
     */
    readonly date: string

    /**
     * The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @type {number}
     * @memberof DefaultApiDeprecatedGetHistoricForexQuotes
     */
    readonly offset?: number

    /**
     * Limit the size of the response, max 10000.
     * @type {number}
     * @memberof DefaultApiDeprecatedGetHistoricForexQuotes
     */
    readonly limit?: number
}

/**
 * Request parameters for deprecatedGetHistoricStocksQuotes operation in DefaultApi.
 * @export
 * @interface DefaultApiDeprecatedGetHistoricStocksQuotesRequest
 */
export interface DefaultApiDeprecatedGetHistoricStocksQuotesRequest {
    /**
     * The ticker symbol we want quotes for.
     * @type {string}
     * @memberof DefaultApiDeprecatedGetHistoricStocksQuotes
     */
    readonly ticker: string

    /**
     * The date/day of the quotes to retrieve in the format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiDeprecatedGetHistoricStocksQuotes
     */
    readonly date: string

    /**
     * The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @type {number}
     * @memberof DefaultApiDeprecatedGetHistoricStocksQuotes
     */
    readonly timestamp?: number

    /**
     * The maximum timestamp allowed in the results. 
     * @type {number}
     * @memberof DefaultApiDeprecatedGetHistoricStocksQuotes
     */
    readonly timestampLimit?: number

    /**
     * Reverse the order of the results. 
     * @type {boolean}
     * @memberof DefaultApiDeprecatedGetHistoricStocksQuotes
     */
    readonly reverse?: boolean

    /**
     * Limit the size of the response, max 50000 and default 5000.
     * @type {number}
     * @memberof DefaultApiDeprecatedGetHistoricStocksQuotes
     */
    readonly limit?: number
}

/**
 * Request parameters for deprecatedGetHistoricStocksTrades operation in DefaultApi.
 * @export
 * @interface DefaultApiDeprecatedGetHistoricStocksTradesRequest
 */
export interface DefaultApiDeprecatedGetHistoricStocksTradesRequest {
    /**
     * The ticker symbol we want trades for.
     * @type {string}
     * @memberof DefaultApiDeprecatedGetHistoricStocksTrades
     */
    readonly ticker: string

    /**
     * The date/day of the trades to retrieve in the format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiDeprecatedGetHistoricStocksTrades
     */
    readonly date: string

    /**
     * The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @type {number}
     * @memberof DefaultApiDeprecatedGetHistoricStocksTrades
     */
    readonly timestamp?: number

    /**
     * The maximum timestamp allowed in the results. 
     * @type {number}
     * @memberof DefaultApiDeprecatedGetHistoricStocksTrades
     */
    readonly timestampLimit?: number

    /**
     * Reverse the order of the results. 
     * @type {boolean}
     * @memberof DefaultApiDeprecatedGetHistoricStocksTrades
     */
    readonly reverse?: boolean

    /**
     * Limit the size of the response, max 50000 and default 5000.
     * @type {number}
     * @memberof DefaultApiDeprecatedGetHistoricStocksTrades
     */
    readonly limit?: number
}

/**
 * Request parameters for getBenzingaV1AnalystInsights operation in DefaultApi.
 * @export
 * @interface DefaultApiGetBenzingaV1AnalystInsightsRequest
 */
export interface DefaultApiGetBenzingaV1AnalystInsightsRequest {
    /**
     * The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly date?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly dateAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly dateGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly dateGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly dateLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly dateLte?: string

    /**
     * The stock symbol of the company being rated.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly ticker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly tickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly tickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly tickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly tickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly tickerLte?: string

    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly lastUpdated?: string

    /**
     * Filter greater than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly lastUpdatedGt?: string

    /**
     * Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly lastUpdatedGte?: string

    /**
     * Filter less than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly lastUpdatedLt?: string

    /**
     * Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly lastUpdatedLte?: string

    /**
     * The name of the research firm or investment bank issuing the rating.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly firm?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly firmAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly firmGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly firmGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly firmLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly firmLte?: string

    /**
     * The description of the change in rating from the firm\&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly ratingAction?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly ratingActionAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly ratingActionGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly ratingActionGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly ratingActionLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly ratingActionLte?: string

    /**
     * The identifer used by Benzinga for the firm record.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly benzingaFirmId?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly benzingaFirmIdAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly benzingaFirmIdGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly benzingaFirmIdGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly benzingaFirmIdLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly benzingaFirmIdLte?: string

    /**
     * The identifier used by Benzinga for the rating record.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly benzingaRatingId?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly benzingaRatingIdAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly benzingaRatingIdGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly benzingaRatingIdGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly benzingaRatingIdLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly benzingaRatingIdLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;last_updated\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1AnalystInsights
     */
    readonly sort?: string
}

/**
 * Request parameters for getBenzingaV1Analysts operation in DefaultApi.
 * @export
 * @interface DefaultApiGetBenzingaV1AnalystsRequest
 */
export interface DefaultApiGetBenzingaV1AnalystsRequest {
    /**
     * The identifier used by Benzinga for this record.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly benzingaId?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly benzingaIdAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly benzingaIdGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly benzingaIdGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly benzingaIdLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly benzingaIdLte?: string

    /**
     * The unique identifier assigned by Benzinga to the research firm or investment bank.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly benzingaFirmId?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly benzingaFirmIdAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly benzingaFirmIdGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly benzingaFirmIdGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly benzingaFirmIdLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly benzingaFirmIdLte?: string

    /**
     * The name of the research firm or investment bank issuing the ratings.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly firmName?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly firmNameAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly firmNameGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly firmNameGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly firmNameLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly firmNameLte?: string

    /**
     * The full name of the analyst associated with the ratings.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly fullName?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly fullNameAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly fullNameGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly fullNameGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly fullNameLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly fullNameLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;full_name\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Analysts
     */
    readonly sort?: string
}

/**
 * Request parameters for getBenzingaV1ConsensusRatings operation in DefaultApi.
 * @export
 * @interface DefaultApiGetBenzingaV1ConsensusRatingsRequest
 */
export interface DefaultApiGetBenzingaV1ConsensusRatingsRequest {
    /**
     * The requested ticker.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1ConsensusRatings
     */
    readonly ticker: string

    /**
     * The date range to aggregate analyst ratings over. For example, date.gte&#x3D;2024-10-01 and date.lt&#x3D;2025-01-01 for ratings published in Q4 2024. By default, all ratings are aggregated regardless of date.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1ConsensusRatings
     */
    readonly date?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1ConsensusRatings
     */
    readonly dateAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1ConsensusRatings
     */
    readonly dateGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1ConsensusRatings
     */
    readonly dateGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1ConsensusRatings
     */
    readonly dateLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1ConsensusRatings
     */
    readonly dateLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1ConsensusRatings
     */
    readonly limit?: number
}

/**
 * Request parameters for getBenzingaV1Earnings operation in DefaultApi.
 * @export
 * @interface DefaultApiGetBenzingaV1EarningsRequest
 */
export interface DefaultApiGetBenzingaV1EarningsRequest {
    /**
     * The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly date?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly dateAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly dateGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly dateGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly dateLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly dateLte?: string

    /**
     * The stock symbol of the company reporting earnings.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly ticker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly tickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly tickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly tickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly tickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly tickerLte?: string

    /**
     * A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly importance?: number

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly importanceAnyOf?: string

    /**
     * Filter greater than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly importanceGt?: number

    /**
     * Filter greater than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly importanceGte?: number

    /**
     * Filter less than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly importanceLt?: number

    /**
     * Filter less than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly importanceLte?: number

    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly lastUpdated?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly lastUpdatedAnyOf?: string

    /**
     * Filter greater than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly lastUpdatedGt?: string

    /**
     * Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly lastUpdatedGte?: string

    /**
     * Filter less than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly lastUpdatedLt?: string

    /**
     * Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly lastUpdatedLte?: string

    /**
     * Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly dateStatus?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly dateStatusAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly dateStatusGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly dateStatusGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly dateStatusLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly dateStatusLte?: string

    /**
     * The percentage difference between the actual and estimated EPS. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly epsSurprisePercent?: number

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly epsSurprisePercentAnyOf?: string

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly epsSurprisePercentGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly epsSurprisePercentGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly epsSurprisePercentLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly epsSurprisePercentLte?: number

    /**
     * The percentage difference between the actual and estimated revenue. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly revenueSurprisePercent?: number

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly revenueSurprisePercentAnyOf?: string

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly revenueSurprisePercentGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly revenueSurprisePercentGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly revenueSurprisePercentLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly revenueSurprisePercentLte?: number

    /**
     * The fiscal year in which the earnings period falls. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly fiscalYear?: number

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly fiscalYearAnyOf?: string

    /**
     * Filter greater than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly fiscalYearGt?: number

    /**
     * Filter greater than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly fiscalYearGte?: number

    /**
     * Filter less than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly fiscalYearLt?: number

    /**
     * Filter less than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly fiscalYearLte?: number

    /**
     * The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly fiscalPeriod?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly fiscalPeriodAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly fiscalPeriodGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly fiscalPeriodGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly fiscalPeriodLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly fiscalPeriodLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;last_updated\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Earnings
     */
    readonly sort?: string
}

/**
 * Request parameters for getBenzingaV1Firms operation in DefaultApi.
 * @export
 * @interface DefaultApiGetBenzingaV1FirmsRequest
 */
export interface DefaultApiGetBenzingaV1FirmsRequest {
    /**
     * The identifer used by Benzinga for this record.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Firms
     */
    readonly benzingaId?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Firms
     */
    readonly benzingaIdAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Firms
     */
    readonly benzingaIdGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Firms
     */
    readonly benzingaIdGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Firms
     */
    readonly benzingaIdLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Firms
     */
    readonly benzingaIdLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Firms
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;name\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Firms
     */
    readonly sort?: string
}

/**
 * Request parameters for getBenzingaV1Guidance operation in DefaultApi.
 * @export
 * @interface DefaultApiGetBenzingaV1GuidanceRequest
 */
export interface DefaultApiGetBenzingaV1GuidanceRequest {
    /**
     * The calendar date (formatted as YYYY-MM-DD) when the guidance was issued.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly date?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly dateAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly dateGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly dateGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly dateLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly dateLte?: string

    /**
     * The stock symbol of the company issuing guidance.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly ticker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly tickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly tickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly tickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly tickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly tickerLte?: string

    /**
     * Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are \&#39;primary\&#39; (the emphasized figure) and \&#39;secondary\&#39; (a supporting or alternate figure)
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly positioning?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly positioningAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly positioningGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly positioningGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly positioningLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly positioningLte?: string

    /**
     * A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly importance?: number

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly importanceAnyOf?: string

    /**
     * Filter greater than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly importanceGt?: number

    /**
     * Filter greater than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly importanceGte?: number

    /**
     * Filter less than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly importanceLt?: number

    /**
     * Filter less than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly importanceLte?: number

    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly lastUpdated?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly lastUpdatedAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly lastUpdatedGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly lastUpdatedGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly lastUpdatedLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly lastUpdatedLte?: string

    /**
     * The fiscal year corresponding to the period for which the guidance is issued. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly fiscalYear?: number

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly fiscalYearAnyOf?: string

    /**
     * Filter greater than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly fiscalYearGt?: number

    /**
     * Filter greater than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly fiscalYearGte?: number

    /**
     * Filter less than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly fiscalYearLt?: number

    /**
     * Filter less than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly fiscalYearLte?: number

    /**
     * The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly fiscalPeriod?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly fiscalPeriodAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly fiscalPeriodGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly fiscalPeriodGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly fiscalPeriodLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly fiscalPeriodLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Guidance
     */
    readonly sort?: string
}

/**
 * Request parameters for getBenzingaV1News operation in DefaultApi.
 * @export
 * @interface DefaultApiGetBenzingaV1NewsRequest
 */
export interface DefaultApiGetBenzingaV1NewsRequest {
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly published?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly publishedAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly publishedGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly publishedGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly publishedLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly publishedLte?: string

    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly lastUpdated?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly lastUpdatedAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly lastUpdatedGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly lastUpdatedGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly lastUpdatedLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly lastUpdatedLte?: string

    /**
     * Filter for arrays that contain the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly tickers?: string

    /**
     * Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly tickersAllOf?: string

    /**
     * Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly tickersAnyOf?: string

    /**
     * Filter for arrays that contain the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly channels?: string

    /**
     * Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly channelsAllOf?: string

    /**
     * Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly channelsAnyOf?: string

    /**
     * Filter for arrays that contain the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly tags?: string

    /**
     * Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly tagsAllOf?: string

    /**
     * Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly tagsAnyOf?: string

    /**
     * The name of the journalist or entity that authored the news article.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly author?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly authorAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly authorGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly authorGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly authorLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly authorLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;published\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1News
     */
    readonly sort?: string
}

/**
 * Request parameters for getBenzingaV1Ratings operation in DefaultApi.
 * @export
 * @interface DefaultApiGetBenzingaV1RatingsRequest
 */
export interface DefaultApiGetBenzingaV1RatingsRequest {
    /**
     * The calendar date (formatted as YYYY-MM-DD) when the rating was issued.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly date?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly dateAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly dateGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly dateGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly dateLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly dateLte?: string

    /**
     * The stock symbol of the company being rated.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly ticker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly tickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly tickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly tickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly tickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly tickerLte?: string

    /**
     * A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly importance?: number

    /**
     * Filter greater than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly importanceGt?: number

    /**
     * Filter greater than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly importanceGte?: number

    /**
     * Filter less than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly importanceLt?: number

    /**
     * Filter less than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly importanceLte?: number

    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly lastUpdated?: string

    /**
     * Filter greater than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly lastUpdatedGt?: string

    /**
     * Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly lastUpdatedGte?: string

    /**
     * Filter less than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly lastUpdatedLt?: string

    /**
     * Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly lastUpdatedLte?: string

    /**
     * The description of the change in rating from the firm\&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly ratingAction?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly ratingActionAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly ratingActionGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly ratingActionGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly ratingActionLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly ratingActionLte?: string

    /**
     * The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly priceTargetAction?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly priceTargetActionAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly priceTargetActionGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly priceTargetActionGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly priceTargetActionLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly priceTargetActionLte?: string

    /**
     * The identifer used by Benzinga for this record.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaId?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaIdAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaIdGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaIdGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaIdLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaIdLte?: string

    /**
     * The identifer used by Benzinga for this analyst.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaAnalystId?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaAnalystIdAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaAnalystIdGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaAnalystIdGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaAnalystIdLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaAnalystIdLte?: string

    /**
     * The identifer used by Benzinga for this firm.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaFirmId?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaFirmIdAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaFirmIdGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaFirmIdGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaFirmIdLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly benzingaFirmIdLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;last_updated\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV1Ratings
     */
    readonly sort?: string
}

/**
 * Request parameters for getBenzingaV2News operation in DefaultApi.
 * @export
 * @interface DefaultApiGetBenzingaV2NewsRequest
 */
export interface DefaultApiGetBenzingaV2NewsRequest {
    /**
     * The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly published?: string

    /**
     * Filter greater than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly publishedGt?: string

    /**
     * Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly publishedGte?: string

    /**
     * Filter less than the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly publishedLt?: string

    /**
     * Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly publishedLte?: string

    /**
     * Filter for arrays that contain the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly channels?: string

    /**
     * Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly channelsAllOf?: string

    /**
     * Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly channelsAnyOf?: string

    /**
     * Filter for arrays that contain the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly tags?: string

    /**
     * Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly tagsAllOf?: string

    /**
     * Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly tagsAnyOf?: string

    /**
     * The name of the journalist or entity that authored the news article.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly author?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly authorAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly authorGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly authorGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly authorLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly authorLte?: string

    /**
     * Filter for arrays that contain the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly stocks?: string

    /**
     * Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly stocksAllOf?: string

    /**
     * Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly stocksAnyOf?: string

    /**
     * Filter for arrays that contain the value.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly tickers?: string

    /**
     * Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly tickersAllOf?: string

    /**
     * Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly tickersAnyOf?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;published\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetBenzingaV2News
     */
    readonly sort?: string
}

/**
 * Request parameters for getCryptoAggregates operation in DefaultApi.
 * @export
 * @interface DefaultApiGetCryptoAggregatesRequest
 */
export interface DefaultApiGetCryptoAggregatesRequest {
    /**
     * The ticker symbol of the currency pair.
     * @type {string}
     * @memberof DefaultApiGetCryptoAggregates
     */
    readonly cryptoTicker: string

    /**
     * The size of the timespan multiplier.
     * @type {number}
     * @memberof DefaultApiGetCryptoAggregates
     */
    readonly multiplier: number

    /**
     * The size of the time window.
     * @type {'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetCryptoAggregates
     */
    readonly timespan: GetCryptoAggregatesTimespanEnum

    /**
     * The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoAggregates
     */
    readonly from: string

    /**
     * The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoAggregates
     */
    readonly to: string

    /**
     * Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @type {boolean}
     * @memberof DefaultApiGetCryptoAggregates
     */
    readonly adjusted?: boolean

    /**
     * Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetCryptoAggregates
     */
    readonly sort?: GetCryptoAggregatesSortEnum

    /**
     * Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @type {number}
     * @memberof DefaultApiGetCryptoAggregates
     */
    readonly limit?: number
}

/**
 * Request parameters for getCryptoEMA operation in DefaultApi.
 * @export
 * @interface DefaultApiGetCryptoEMARequest
 */
export interface DefaultApiGetCryptoEMARequest {
    /**
     * The ticker symbol for which to get exponential moving average (EMA) data.
     * @type {string}
     * @memberof DefaultApiGetCryptoEMA
     */
    readonly cryptoTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoEMA
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetCryptoEMA
     */
    readonly timespan?: GetCryptoEMATimespanEnum

    /**
     * The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @type {number}
     * @memberof DefaultApiGetCryptoEMA
     */
    readonly window?: number

    /**
     * The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetCryptoEMA
     */
    readonly seriesType?: GetCryptoEMASeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetCryptoEMA
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetCryptoEMA
     */
    readonly order?: GetCryptoEMAOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetCryptoEMA
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoEMA
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoEMA
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoEMA
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoEMA
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getCryptoMACD operation in DefaultApi.
 * @export
 * @interface DefaultApiGetCryptoMACDRequest
 */
export interface DefaultApiGetCryptoMACDRequest {
    /**
     * The ticker symbol for which to get MACD data.
     * @type {string}
     * @memberof DefaultApiGetCryptoMACD
     */
    readonly cryptoTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoMACD
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetCryptoMACD
     */
    readonly timespan?: GetCryptoMACDTimespanEnum

    /**
     * The short window size used to calculate MACD data.
     * @type {number}
     * @memberof DefaultApiGetCryptoMACD
     */
    readonly shortWindow?: number

    /**
     * The long window size used to calculate MACD data.
     * @type {number}
     * @memberof DefaultApiGetCryptoMACD
     */
    readonly longWindow?: number

    /**
     * The window size used to calculate the MACD signal line.
     * @type {number}
     * @memberof DefaultApiGetCryptoMACD
     */
    readonly signalWindow?: number

    /**
     * The price in the aggregate which will be used to calculate MACD data. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetCryptoMACD
     */
    readonly seriesType?: GetCryptoMACDSeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetCryptoMACD
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetCryptoMACD
     */
    readonly order?: GetCryptoMACDOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetCryptoMACD
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoMACD
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoMACD
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoMACD
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoMACD
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getCryptoOpenClose operation in DefaultApi.
 * @export
 * @interface DefaultApiGetCryptoOpenCloseRequest
 */
export interface DefaultApiGetCryptoOpenCloseRequest {
    /**
     * The \&quot;from\&quot; symbol of the pair.
     * @type {string}
     * @memberof DefaultApiGetCryptoOpenClose
     */
    readonly from: string

    /**
     * The \&quot;to\&quot; symbol of the pair.
     * @type {string}
     * @memberof DefaultApiGetCryptoOpenClose
     */
    readonly to: string

    /**
     * The date of the requested open/close in the format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiGetCryptoOpenClose
     */
    readonly date: string

    /**
     * Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @type {boolean}
     * @memberof DefaultApiGetCryptoOpenClose
     */
    readonly adjusted?: boolean
}

/**
 * Request parameters for getCryptoRSI operation in DefaultApi.
 * @export
 * @interface DefaultApiGetCryptoRSIRequest
 */
export interface DefaultApiGetCryptoRSIRequest {
    /**
     * The ticker symbol for which to get relative strength index (RSI) data.
     * @type {string}
     * @memberof DefaultApiGetCryptoRSI
     */
    readonly cryptoTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoRSI
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetCryptoRSI
     */
    readonly timespan?: GetCryptoRSITimespanEnum

    /**
     * The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @type {number}
     * @memberof DefaultApiGetCryptoRSI
     */
    readonly window?: number

    /**
     * The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetCryptoRSI
     */
    readonly seriesType?: GetCryptoRSISeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetCryptoRSI
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetCryptoRSI
     */
    readonly order?: GetCryptoRSIOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetCryptoRSI
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoRSI
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoRSI
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoRSI
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoRSI
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getCryptoSMA operation in DefaultApi.
 * @export
 * @interface DefaultApiGetCryptoSMARequest
 */
export interface DefaultApiGetCryptoSMARequest {
    /**
     * The ticker symbol for which to get simple moving average (SMA) data.
     * @type {string}
     * @memberof DefaultApiGetCryptoSMA
     */
    readonly cryptoTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoSMA
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetCryptoSMA
     */
    readonly timespan?: GetCryptoSMATimespanEnum

    /**
     * The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @type {number}
     * @memberof DefaultApiGetCryptoSMA
     */
    readonly window?: number

    /**
     * The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetCryptoSMA
     */
    readonly seriesType?: GetCryptoSMASeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetCryptoSMA
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetCryptoSMA
     */
    readonly order?: GetCryptoSMAOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetCryptoSMA
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoSMA
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoSMA
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoSMA
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoSMA
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getCryptoSnapshotDirection operation in DefaultApi.
 * @export
 * @interface DefaultApiGetCryptoSnapshotDirectionRequest
 */
export interface DefaultApiGetCryptoSnapshotDirectionRequest {
    /**
     * The direction of the snapshot results to return. 
     * @type {'gainers' | 'losers'}
     * @memberof DefaultApiGetCryptoSnapshotDirection
     */
    readonly direction: GetCryptoSnapshotDirectionDirectionEnum
}

/**
 * Request parameters for getCryptoSnapshotTicker operation in DefaultApi.
 * @export
 * @interface DefaultApiGetCryptoSnapshotTickerRequest
 */
export interface DefaultApiGetCryptoSnapshotTickerRequest {
    /**
     * Ticker of the snapshot
     * @type {string}
     * @memberof DefaultApiGetCryptoSnapshotTicker
     */
    readonly ticker: string
}

/**
 * Request parameters for getCryptoSnapshotTickers operation in DefaultApi.
 * @export
 * @interface DefaultApiGetCryptoSnapshotTickersRequest
 */
export interface DefaultApiGetCryptoSnapshotTickersRequest {
    /**
     * A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers.
     * @type {Array<string>}
     * @memberof DefaultApiGetCryptoSnapshotTickers
     */
    readonly tickers?: Array<string>
}

/**
 * Request parameters for getCryptoTrades operation in DefaultApi.
 * @export
 * @interface DefaultApiGetCryptoTradesRequest
 */
export interface DefaultApiGetCryptoTradesRequest {
    /**
     * The ticker symbol to get trades for.
     * @type {string}
     * @memberof DefaultApiGetCryptoTrades
     */
    readonly cryptoTicker: string

    /**
     * Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoTrades
     */
    readonly timestamp?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoTrades
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoTrades
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoTrades
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetCryptoTrades
     */
    readonly timestampLt?: string

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetCryptoTrades
     */
    readonly order?: GetCryptoTradesOrderEnum

    /**
     * Limit the number of results returned, default is 1000 and max is 50000.
     * @type {number}
     * @memberof DefaultApiGetCryptoTrades
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'timestamp'}
     * @memberof DefaultApiGetCryptoTrades
     */
    readonly sort?: GetCryptoTradesSortEnum
}

/**
 * Request parameters for getCryptoV1Exchanges operation in DefaultApi.
 * @export
 * @interface DefaultApiGetCryptoV1ExchangesRequest
 */
export interface DefaultApiGetCryptoV1ExchangesRequest {
    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
     * @type {number}
     * @memberof DefaultApiGetCryptoV1Exchanges
     */
    readonly limit?: number
}

/**
 * Request parameters for getCurrencyConversion operation in DefaultApi.
 * @export
 * @interface DefaultApiGetCurrencyConversionRequest
 */
export interface DefaultApiGetCurrencyConversionRequest {
    /**
     * The \&quot;from\&quot; symbol of the pair.
     * @type {string}
     * @memberof DefaultApiGetCurrencyConversion
     */
    readonly from: string

    /**
     * The \&quot;to\&quot; symbol of the pair.
     * @type {string}
     * @memberof DefaultApiGetCurrencyConversion
     */
    readonly to: string

    /**
     * The amount to convert, with a decimal.
     * @type {number}
     * @memberof DefaultApiGetCurrencyConversion
     */
    readonly amount?: number

    /**
     * The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy.
     * @type {0 | 1 | 2 | 3 | 4}
     * @memberof DefaultApiGetCurrencyConversion
     */
    readonly precision?: GetCurrencyConversionPrecisionEnum
}

/**
 * Request parameters for getEtfGlobalV1Analytics operation in DefaultApi.
 * @export
 * @interface DefaultApiGetEtfGlobalV1AnalyticsRequest
 */
export interface DefaultApiGetEtfGlobalV1AnalyticsRequest {
    /**
     * The stock ticker symbol used to identify this ETF product on exchanges.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly compositeTicker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly compositeTickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly compositeTickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly compositeTickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly compositeTickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly compositeTickerLte?: string

    /**
     * The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly processedDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly processedDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly processedDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly processedDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly processedDateLte?: string

    /**
     * The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly effectiveDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly effectiveDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly effectiveDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly effectiveDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly effectiveDateLte?: string

    /**
     * ETF Global\&#39;s proprietary Red Diamond overall risk assessment score for the ETF. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly riskTotalScore?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly riskTotalScoreGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly riskTotalScoreGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly riskTotalScoreLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly riskTotalScoreLte?: number

    /**
     * ETF Global\&#39;s proprietary Green Diamond score measuring the potential reward and return prospects of the ETF. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly rewardScore?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly rewardScoreGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly rewardScoreGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly rewardScoreLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly rewardScoreLte?: number

    /**
     * ETF Global\&#39;s comprehensive quantitative analysis score combining all quantitative factors. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantTotalScore?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantTotalScoreGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantTotalScoreGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantTotalScoreLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantTotalScoreLte?: number

    /**
     * Letter grade summarizing the ETF\&#39;s overall quantitative assessment, where A &#x3D; 71-100, B &#x3D; 56-70, etc.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantGrade?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantGradeAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantGradeGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantGradeGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantGradeLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantGradeLte?: string

    /**
     * Combined technical analysis score aggregating short, intermediate, and long-term technical factors. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeTechnical?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeTechnicalGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeTechnicalGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeTechnicalLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeTechnicalLte?: number

    /**
     * Overall market sentiment score combining put/call ratios, short interest, and implied volatility. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeSentiment?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeSentimentGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeSentimentGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeSentimentLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeSentimentLte?: number

    /**
     * Behavioral analysis score measuring investor psychology and market behavior patterns. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeBehavioral?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeBehavioralGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeBehavioralGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeBehavioralLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeBehavioralLte?: number

    /**
     * Overall fundamental analysis score combining P/E, P/CF, P/B, and dividend yield metrics. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeFundamental?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeFundamentalGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeFundamentalGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeFundamentalLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeFundamentalLte?: number

    /**
     * Overall global theme score combining sector and country analysis for macro investment views. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeGlobal?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeGlobalGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeGlobalGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeGlobalLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeGlobalLte?: number

    /**
     * Overall quality assessment score combining liquidity, diversification, and issuing firm factors. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeQuality?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeQualityGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeQualityGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeQualityLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly quantCompositeQualityLte?: number

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Analytics
     */
    readonly sort?: string
}

/**
 * Request parameters for getEtfGlobalV1Constituents operation in DefaultApi.
 * @export
 * @interface DefaultApiGetEtfGlobalV1ConstituentsRequest
 */
export interface DefaultApiGetEtfGlobalV1ConstituentsRequest {
    /**
     * The stock ticker symbol of the ETF that holds these constituent securities.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly compositeTicker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly compositeTickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly compositeTickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly compositeTickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly compositeTickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly compositeTickerLte?: string

    /**
     * The stock ticker symbol of the individual security held within the ETF.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly constituentTicker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly constituentTickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly constituentTickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly constituentTickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly constituentTickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly constituentTickerLte?: string

    /**
     * The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly effectiveDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly effectiveDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly effectiveDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly effectiveDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly effectiveDateLte?: string

    /**
     * The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly processedDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly processedDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly processedDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly processedDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly processedDateLte?: string

    /**
     * A unique identifier code for the constituent security in US markets.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly usCode?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly usCodeAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly usCodeGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly usCodeGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly usCodeLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly usCodeLte?: string

    /**
     * The International Securities Identification Number, a global standard for identifying securities.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly isin?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly isinAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly isinGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly isinGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly isinLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly isinLte?: string

    /**
     * The Financial Instrument Global Identifier, an open standard for uniquely identifying financial instruments.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly figi?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly figiAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly figiGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly figiGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly figiLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly figiLte?: string

    /**
     * The Stock Exchange Daily Official List code, primarily used for securities trading in the UK.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly sedol?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly sedolAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly sedolGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly sedolGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly sedolLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly sedolLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Constituents
     */
    readonly sort?: string
}

/**
 * Request parameters for getEtfGlobalV1FundFlows operation in DefaultApi.
 * @export
 * @interface DefaultApiGetEtfGlobalV1FundFlowsRequest
 */
export interface DefaultApiGetEtfGlobalV1FundFlowsRequest {
    /**
     * The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly processedDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly processedDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly processedDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly processedDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly processedDateLte?: string

    /**
     * The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly effectiveDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly effectiveDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly effectiveDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly effectiveDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly effectiveDateLte?: string

    /**
     * The stock ticker symbol used to identify this ETF on exchanges.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly compositeTicker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly compositeTickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly compositeTickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly compositeTickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly compositeTickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly compositeTickerLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1FundFlows
     */
    readonly sort?: string
}

/**
 * Request parameters for getEtfGlobalV1Profiles operation in DefaultApi.
 * @export
 * @interface DefaultApiGetEtfGlobalV1ProfilesRequest
 */
export interface DefaultApiGetEtfGlobalV1ProfilesRequest {
    /**
     * The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly processedDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly processedDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly processedDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly processedDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly processedDateLte?: string

    /**
     * The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly effectiveDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly effectiveDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly effectiveDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly effectiveDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly effectiveDateLte?: string

    /**
     * The stock ticker symbol used to identify this ETF product on exchanges.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly compositeTicker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly compositeTickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly compositeTickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly compositeTickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly compositeTickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly compositeTickerLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Profiles
     */
    readonly sort?: string
}

/**
 * Request parameters for getEtfGlobalV1Taxonomies operation in DefaultApi.
 * @export
 * @interface DefaultApiGetEtfGlobalV1TaxonomiesRequest
 */
export interface DefaultApiGetEtfGlobalV1TaxonomiesRequest {
    /**
     * The date showing when ETF Global received and processed the data. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly processedDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly processedDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly processedDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly processedDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly processedDateLte?: string

    /**
     * The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly effectiveDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly effectiveDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly effectiveDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly effectiveDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly effectiveDateLte?: string

    /**
     * The stock ticker symbol used to identify this ETF product on exchanges.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly compositeTicker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly compositeTickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly compositeTickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly compositeTickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly compositeTickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly compositeTickerLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;composite_ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetEtfGlobalV1Taxonomies
     */
    readonly sort?: string
}

/**
 * Request parameters for getEvents operation in DefaultApi.
 * @export
 * @interface DefaultApiGetEventsRequest
 */
export interface DefaultApiGetEventsRequest {
    /**
     * Identifier of an asset, which can be a Ticker, CUSIP, or Composite FIGI. Specify a case-sensitive  ticker symbol (e.g. AAPL for Apple Inc). When provided a ticker, events for the entity currently  represented by that ticker are returned. To find events for entities previously associated with a  ticker, obtain the relevant identifier using the [Ticker Details Endpoint](https://massive.com/docs/rest/stocks/tickers/ticker-overview).
     * @type {string}
     * @memberof DefaultApiGetEvents
     */
    readonly id: string

    /**
     * A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types.
     * @type {string}
     * @memberof DefaultApiGetEvents
     */
    readonly types?: string
}

/**
 * Request parameters for getFedV1Inflation operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFedV1InflationRequest
 */
export interface DefaultApiGetFedV1InflationRequest {
    /**
     * Calendar date of the observation (YYYYMMDD).
     * @type {string}
     * @memberof DefaultApiGetFedV1Inflation
     */
    readonly date?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFedV1Inflation
     */
    readonly dateAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFedV1Inflation
     */
    readonly dateGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFedV1Inflation
     */
    readonly dateGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFedV1Inflation
     */
    readonly dateLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFedV1Inflation
     */
    readonly dateLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetFedV1Inflation
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetFedV1Inflation
     */
    readonly sort?: string
}

/**
 * Request parameters for getFedV1InflationExpectations operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFedV1InflationExpectationsRequest
 */
export interface DefaultApiGetFedV1InflationExpectationsRequest {
    /**
     * Calendar date of the observation (YYYYMMDD).
     * @type {string}
     * @memberof DefaultApiGetFedV1InflationExpectations
     */
    readonly date?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFedV1InflationExpectations
     */
    readonly dateAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFedV1InflationExpectations
     */
    readonly dateGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFedV1InflationExpectations
     */
    readonly dateGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFedV1InflationExpectations
     */
    readonly dateLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFedV1InflationExpectations
     */
    readonly dateLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetFedV1InflationExpectations
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetFedV1InflationExpectations
     */
    readonly sort?: string
}

/**
 * Request parameters for getFedV1TreasuryYields operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFedV1TreasuryYieldsRequest
 */
export interface DefaultApiGetFedV1TreasuryYieldsRequest {
    /**
     * Calendar date of the yield observation (YYYY-MM-DD).
     * @type {string}
     * @memberof DefaultApiGetFedV1TreasuryYields
     */
    readonly date?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFedV1TreasuryYields
     */
    readonly dateAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFedV1TreasuryYields
     */
    readonly dateGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFedV1TreasuryYields
     */
    readonly dateGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFedV1TreasuryYields
     */
    readonly dateLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFedV1TreasuryYields
     */
    readonly dateLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetFedV1TreasuryYields
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetFedV1TreasuryYields
     */
    readonly sort?: string
}

/**
 * Request parameters for getForexAggregates operation in DefaultApi.
 * @export
 * @interface DefaultApiGetForexAggregatesRequest
 */
export interface DefaultApiGetForexAggregatesRequest {
    /**
     * The ticker symbol of the currency pair.
     * @type {string}
     * @memberof DefaultApiGetForexAggregates
     */
    readonly forexTicker: string

    /**
     * The size of the timespan multiplier.
     * @type {number}
     * @memberof DefaultApiGetForexAggregates
     */
    readonly multiplier: number

    /**
     * The size of the time window.
     * @type {'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetForexAggregates
     */
    readonly timespan: GetForexAggregatesTimespanEnum

    /**
     * The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexAggregates
     */
    readonly from: string

    /**
     * The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexAggregates
     */
    readonly to: string

    /**
     * Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @type {boolean}
     * @memberof DefaultApiGetForexAggregates
     */
    readonly adjusted?: boolean

    /**
     * Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetForexAggregates
     */
    readonly sort?: GetForexAggregatesSortEnum

    /**
     * Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @type {number}
     * @memberof DefaultApiGetForexAggregates
     */
    readonly limit?: number
}

/**
 * Request parameters for getForexEMA operation in DefaultApi.
 * @export
 * @interface DefaultApiGetForexEMARequest
 */
export interface DefaultApiGetForexEMARequest {
    /**
     * The ticker symbol for which to get exponential moving average (EMA) data.
     * @type {string}
     * @memberof DefaultApiGetForexEMA
     */
    readonly fxTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexEMA
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetForexEMA
     */
    readonly timespan?: GetForexEMATimespanEnum

    /**
     * Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetForexEMA
     */
    readonly adjusted?: boolean

    /**
     * The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @type {number}
     * @memberof DefaultApiGetForexEMA
     */
    readonly window?: number

    /**
     * The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetForexEMA
     */
    readonly seriesType?: GetForexEMASeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetForexEMA
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetForexEMA
     */
    readonly order?: GetForexEMAOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetForexEMA
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexEMA
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexEMA
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexEMA
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexEMA
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getForexMACD operation in DefaultApi.
 * @export
 * @interface DefaultApiGetForexMACDRequest
 */
export interface DefaultApiGetForexMACDRequest {
    /**
     * The ticker symbol for which to get MACD data.
     * @type {string}
     * @memberof DefaultApiGetForexMACD
     */
    readonly fxTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexMACD
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetForexMACD
     */
    readonly timespan?: GetForexMACDTimespanEnum

    /**
     * Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetForexMACD
     */
    readonly adjusted?: boolean

    /**
     * The short window size used to calculate MACD data.
     * @type {number}
     * @memberof DefaultApiGetForexMACD
     */
    readonly shortWindow?: number

    /**
     * The long window size used to calculate MACD data.
     * @type {number}
     * @memberof DefaultApiGetForexMACD
     */
    readonly longWindow?: number

    /**
     * The window size used to calculate the MACD signal line.
     * @type {number}
     * @memberof DefaultApiGetForexMACD
     */
    readonly signalWindow?: number

    /**
     * The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetForexMACD
     */
    readonly seriesType?: GetForexMACDSeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetForexMACD
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetForexMACD
     */
    readonly order?: GetForexMACDOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetForexMACD
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexMACD
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexMACD
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexMACD
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexMACD
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getForexQuotes operation in DefaultApi.
 * @export
 * @interface DefaultApiGetForexQuotesRequest
 */
export interface DefaultApiGetForexQuotesRequest {
    /**
     * The ticker symbol to get quotes for.
     * @type {string}
     * @memberof DefaultApiGetForexQuotes
     */
    readonly fxTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexQuotes
     */
    readonly timestamp?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexQuotes
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexQuotes
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexQuotes
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexQuotes
     */
    readonly timestampLt?: string

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetForexQuotes
     */
    readonly order?: GetForexQuotesOrderEnum

    /**
     * Limit the number of results returned, default is 1000 and max is 50000.
     * @type {number}
     * @memberof DefaultApiGetForexQuotes
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'timestamp'}
     * @memberof DefaultApiGetForexQuotes
     */
    readonly sort?: GetForexQuotesSortEnum
}

/**
 * Request parameters for getForexRSI operation in DefaultApi.
 * @export
 * @interface DefaultApiGetForexRSIRequest
 */
export interface DefaultApiGetForexRSIRequest {
    /**
     * The ticker symbol for which to get relative strength index (RSI) data.
     * @type {string}
     * @memberof DefaultApiGetForexRSI
     */
    readonly fxTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexRSI
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetForexRSI
     */
    readonly timespan?: GetForexRSITimespanEnum

    /**
     * Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetForexRSI
     */
    readonly adjusted?: boolean

    /**
     * The window size used to calculate the relative strength index (RSI).
     * @type {number}
     * @memberof DefaultApiGetForexRSI
     */
    readonly window?: number

    /**
     * The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetForexRSI
     */
    readonly seriesType?: GetForexRSISeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetForexRSI
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetForexRSI
     */
    readonly order?: GetForexRSIOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetForexRSI
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexRSI
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexRSI
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexRSI
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexRSI
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getForexSMA operation in DefaultApi.
 * @export
 * @interface DefaultApiGetForexSMARequest
 */
export interface DefaultApiGetForexSMARequest {
    /**
     * The ticker symbol for which to get simple moving average (SMA) data.
     * @type {string}
     * @memberof DefaultApiGetForexSMA
     */
    readonly fxTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexSMA
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetForexSMA
     */
    readonly timespan?: GetForexSMATimespanEnum

    /**
     * Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetForexSMA
     */
    readonly adjusted?: boolean

    /**
     * The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @type {number}
     * @memberof DefaultApiGetForexSMA
     */
    readonly window?: number

    /**
     * The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetForexSMA
     */
    readonly seriesType?: GetForexSMASeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetForexSMA
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetForexSMA
     */
    readonly order?: GetForexSMAOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetForexSMA
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexSMA
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexSMA
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexSMA
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetForexSMA
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getForexSnapshotDirection operation in DefaultApi.
 * @export
 * @interface DefaultApiGetForexSnapshotDirectionRequest
 */
export interface DefaultApiGetForexSnapshotDirectionRequest {
    /**
     * The direction of the snapshot results to return. 
     * @type {'gainers' | 'losers'}
     * @memberof DefaultApiGetForexSnapshotDirection
     */
    readonly direction: GetForexSnapshotDirectionDirectionEnum
}

/**
 * Request parameters for getForexSnapshotTicker operation in DefaultApi.
 * @export
 * @interface DefaultApiGetForexSnapshotTickerRequest
 */
export interface DefaultApiGetForexSnapshotTickerRequest {
    /**
     * The forex ticker.
     * @type {string}
     * @memberof DefaultApiGetForexSnapshotTicker
     */
    readonly ticker: string
}

/**
 * Request parameters for getForexSnapshotTickers operation in DefaultApi.
 * @export
 * @interface DefaultApiGetForexSnapshotTickersRequest
 */
export interface DefaultApiGetForexSnapshotTickersRequest {
    /**
     * A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers.
     * @type {Array<string>}
     * @memberof DefaultApiGetForexSnapshotTickers
     */
    readonly tickers?: Array<string>
}

/**
 * Request parameters for getForexV1Exchanges operation in DefaultApi.
 * @export
 * @interface DefaultApiGetForexV1ExchangesRequest
 */
export interface DefaultApiGetForexV1ExchangesRequest {
    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
     * @type {number}
     * @memberof DefaultApiGetForexV1Exchanges
     */
    readonly limit?: number
}

/**
 * Request parameters for getFuturesAggregates operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFuturesAggregatesRequest
 */
export interface DefaultApiGetFuturesAggregatesRequest {
    /**
     * The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
     * @type {string}
     * @memberof DefaultApiGetFuturesAggregates
     */
    readonly ticker: string

    /**
     * This sets the size of the aggregate windows. It accepts custom values that specify the granularity and the duration of the window. For example: 15mins, 30secs, 12hours, or 7days. There are maximum allowable candle sizes. For example, you can request \&quot;1min\&quot; to \&quot;59mins\&quot;, but after that you will need to use \&quot;1hr\&quot;. If you make a request for a candle size that is not supported, we will return a 400 \&quot;Bad Request - resolution value is not allowed.\&quot;
     * @type {string}
     * @memberof DefaultApiGetFuturesAggregates
     */
    readonly resolution?: string

    /**
     * Specifies the start time of the aggregate (OHLC) candles you want returned (YYYY-MM-DD date or nanosecond Unix timestamp). How it works - If not provided, the API returns the most recent candles available, up to the limit you set. - If provided, the value determines which candle(s) to return. The timestamp or date is snapped to the start time of the matching candle interval. - You can use comparison operators to form ranges:   - &#x60;window_start.gte&#x60;  greater than or equal to   - &#x60;window_start.gt&#x60;  greater than   - &#x60;window_start.lte&#x60;  less than or equal to   - &#x60;window_start.lt&#x60;  less than  Examples 1. Most recent minute candles    &#x60;/vX/aggs/ESU5?resolution&#x3D;1min&amp;limit&#x3D;5&#x60;  2. Daily candle for August 5, 2025    &#x60;/vX/aggs/ESU5?resolution&#x3D;1day&amp;window_start&#x3D;2025-08-05&#x60;  3. Daily candles from July 131, 2025    &#x60;/vX/aggs/ESU5?resolution&#x3D;1day&amp;window_start.gte&#x3D;2025-07-01&amp;window_start.lte&#x3D;2025-07-31&#x60;  4. 1,000 one-second candles after a specific timestamp    &#x60;/vX/aggs/ESU5?resolution&#x3D;1sec&amp;window_start.gt&#x3D;1751409877000000000&amp;limit&#x3D;1000&#x60;
     * @type {string}
     * @memberof DefaultApiGetFuturesAggregates
     */
    readonly windowStart?: string

    /**
     * The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1).
     * @type {number}
     * @memberof DefaultApiGetFuturesAggregates
     */
    readonly limit?: number

    /**
     * Range by window_start.
     * @type {string}
     * @memberof DefaultApiGetFuturesAggregates
     */
    readonly windowStartGte?: string

    /**
     * Range by window_start.
     * @type {string}
     * @memberof DefaultApiGetFuturesAggregates
     */
    readonly windowStartGt?: string

    /**
     * Range by window_start.
     * @type {string}
     * @memberof DefaultApiGetFuturesAggregates
     */
    readonly windowStartLte?: string

    /**
     * Range by window_start.
     * @type {string}
     * @memberof DefaultApiGetFuturesAggregates
     */
    readonly windowStartLt?: string

    /**
     * Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
     * @type {'window_start.asc' | 'window_start.desc'}
     * @memberof DefaultApiGetFuturesAggregates
     */
    readonly sort?: GetFuturesAggregatesSortEnum
}

/**
 * Request parameters for getFuturesContractDetails operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFuturesContractDetailsRequest
 */
export interface DefaultApiGetFuturesContractDetailsRequest {
    /**
     * The ticker symbol of the contract to retrieve.
     * @type {string}
     * @memberof DefaultApiGetFuturesContractDetails
     */
    readonly ticker: string

    /**
     * The point-in-time of the data to be retrieved. Note that the contract data returned for a given date represents the state of that contract on that day. A date in the format YYYY-MM-DD (default&#x3D;today).
     * @type {string}
     * @memberof DefaultApiGetFuturesContractDetails
     */
    readonly asOf?: string
}

/**
 * Request parameters for getFuturesContracts operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFuturesContractsRequest
 */
export interface DefaultApiGetFuturesContractsRequest {
    /**
     * A unique identifier for the Product a Contract belongs to. Note that multiple contracts can belong to the same product.
     * @type {string}
     * @memberof DefaultApiGetFuturesContracts
     */
    readonly productCode?: string

    /**
     * The first day that a contract was tradeable. A date with the format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiGetFuturesContracts
     */
    readonly firstTradeDate?: string

    /**
     * The last day that the contract was tradeable. A date with the format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiGetFuturesContracts
     */
    readonly lastTradeDate?: string

    /**
     * Specify the point-in-time for which you want to retrieve information. Note that the contract data returned for a given date is the state of that contract as of that day. A date in the format YYYY-MM-DD (default&#x3D;today).
     * @type {string}
     * @memberof DefaultApiGetFuturesContracts
     */
    readonly asOf?: string

    /**
     * Filter for contracts based on whether or not they were tradeable at the given point in time. For example, if the date queried is greater-than or equal-to a contract\&#39;s \&#39;first_trade_date\&#39; and less-than-or-equal-to its \&#39;last_trade_date\&#39;, then the contract was active. If the date queried is greater-than-or-equal-to the contract\&#39;s \&#39;last_trade_date\&#39; or less-than-or-equal-to its \&#39;first_trade_date\&#39;, then the contract was inactive.
     * @type {'all' | 'true' | 'false'}
     * @memberof DefaultApiGetFuturesContracts
     */
    readonly active?: GetFuturesContractsActiveEnum

    /**
     * The type of contract, one of \&quot;all\&quot;, \&quot;single\&quot;, or \&quot;combo\&quot; (default&#x3D;all).
     * @type {'all' | 'single' | 'combo'}
     * @memberof DefaultApiGetFuturesContracts
     */
    readonly type?: GetFuturesContractsTypeEnum

    /**
     * The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1).
     * @type {number}
     * @memberof DefaultApiGetFuturesContracts
     */
    readonly limit?: number

    /**
     * Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
     * @type {'product_code.asc' | 'product_code.desc' | 'first_trade_date.asc' | 'first_trade_date.desc' | 'last_trade_date.asc' | 'last_trade_date.desc'}
     * @memberof DefaultApiGetFuturesContracts
     */
    readonly sort?: GetFuturesContractsSortEnum
}

/**
 * Request parameters for getFuturesDailySchedules operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFuturesDailySchedulesRequest
 */
export interface DefaultApiGetFuturesDailySchedulesRequest {
    /**
     * The session end date for the schedules (also known as the trading date). This is the day in CT for which the user wants to retrieve data. If left blank, this value defaults to \&#39;today\&#39; in Central Time. e.g. If a request is made from Pacific Time on \&#39;2025-01-01\&#39; at 11:00 pm with no \&#39;session_end_date\&#39; a default value of &#x60;2025-01-02&#x60; will be used.
     * @type {string}
     * @memberof DefaultApiGetFuturesDailySchedules
     */
    readonly sessionEndDate?: string

    /**
     * The trading venue (MIC) of the exchange for the schedules.
     * @type {string}
     * @memberof DefaultApiGetFuturesDailySchedules
     */
    readonly tradingVenue?: string

    /**
     * The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1).
     * @type {number}
     * @memberof DefaultApiGetFuturesDailySchedules
     */
    readonly limit?: number

    /**
     * Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
     * @type {'trading_venue.asc' | 'trading_venue.desc'}
     * @memberof DefaultApiGetFuturesDailySchedules
     */
    readonly sort?: GetFuturesDailySchedulesSortEnum
}

/**
 * Request parameters for getFuturesMarketStatuses operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFuturesMarketStatusesRequest
 */
export interface DefaultApiGetFuturesMarketStatusesRequest {
    /**
     * The product code(s) to return market statuses for.  Multiple product codes can be specified by separating them with a comma. Currently, the limit is 250 product codes.
     * @type {string}
     * @memberof DefaultApiGetFuturesMarketStatuses
     */
    readonly productCodeAnyOf?: string

    /**
     * The product code to return market statuses for.
     * @type {string}
     * @memberof DefaultApiGetFuturesMarketStatuses
     */
    readonly productCode?: string

    /**
     * The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1).
     * @type {number}
     * @memberof DefaultApiGetFuturesMarketStatuses
     */
    readonly limit?: number

    /**
     * Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
     * @type {'product_code.asc' | 'product_code.desc'}
     * @memberof DefaultApiGetFuturesMarketStatuses
     */
    readonly sort?: GetFuturesMarketStatusesSortEnum
}

/**
 * Request parameters for getFuturesProductDetails operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFuturesProductDetailsRequest
 */
export interface DefaultApiGetFuturesProductDetailsRequest {
    /**
     * The unique identifier for a product.
     * @type {string}
     * @memberof DefaultApiGetFuturesProductDetails
     */
    readonly productCode: string

    /**
     * The type of product to return. One of \&quot;single\&quot; or \&quot;combo\&quot; (default&#x3D;single).
     * @type {'single' | 'combo'}
     * @memberof DefaultApiGetFuturesProductDetails
     */
    readonly type?: GetFuturesProductDetailsTypeEnum

    /**
     * A date string in the format YYYY-MM-DD. Note that the data returned is the state of this product\&#39;s data at that point-in-time.
     * @type {string}
     * @memberof DefaultApiGetFuturesProductDetails
     */
    readonly asOf?: string
}

/**
 * Request parameters for getFuturesProductSchedules operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFuturesProductSchedulesRequest
 */
export interface DefaultApiGetFuturesProductSchedulesRequest {
    /**
     * The product code for the futures product.
     * @type {string}
     * @memberof DefaultApiGetFuturesProductSchedules
     */
    readonly productCode: string

    /**
     * The date on which the schedule\&#39;s trading day ended (sometimes referred to as trading date). Defaults to today. Formatted as &#x60;YYYY-MM-DD&#x60;. Note that although there is no time component the day is assumed to be that day in Central Time.
     * @type {string}
     * @memberof DefaultApiGetFuturesProductSchedules
     */
    readonly sessionEndDate?: string

    /**
     * The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1).
     * @type {number}
     * @memberof DefaultApiGetFuturesProductSchedules
     */
    readonly limit?: number

    /**
     * Range by session_end_date.
     * @type {string}
     * @memberof DefaultApiGetFuturesProductSchedules
     */
    readonly sessionEndDateGte?: string

    /**
     * Range by session_end_date.
     * @type {string}
     * @memberof DefaultApiGetFuturesProductSchedules
     */
    readonly sessionEndDateGt?: string

    /**
     * Range by session_end_date.
     * @type {string}
     * @memberof DefaultApiGetFuturesProductSchedules
     */
    readonly sessionEndDateLte?: string

    /**
     * Range by session_end_date.
     * @type {string}
     * @memberof DefaultApiGetFuturesProductSchedules
     */
    readonly sessionEndDateLt?: string

    /**
     * Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
     * @type {'session_end_date.asc' | 'session_end_date.desc'}
     * @memberof DefaultApiGetFuturesProductSchedules
     */
    readonly sort?: GetFuturesProductSchedulesSortEnum
}

/**
 * Request parameters for getFuturesProducts operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFuturesProductsRequest
 */
export interface DefaultApiGetFuturesProductsRequest {
    /**
     * Search for products by Product Name. This parameter supports an exact match, while a name-contains search can be performed using the &#x60;name.search&#x60; parameter. Note that the search is case-sensitive.
     * @type {string}
     * @memberof DefaultApiGetFuturesProducts
     */
    readonly name?: string

    /**
     * A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day (default&#x3D;today).
     * @type {string}
     * @memberof DefaultApiGetFuturesProducts
     */
    readonly asOf?: string

    /**
     * The trading venue (MIC) for the exchange on which the products trades.
     * @type {string}
     * @memberof DefaultApiGetFuturesProducts
     */
    readonly tradingVenue?: string

    /**
     * The sector to which the products belong.
     * @type {'asia' | 'base' | 'biofuels' | 'coal' | 'cross_rates' | 'crude_oil' | 'custom_index' | 'dairy' | 'dj_ubs_ci' | 'electricity' | 'emissions' | 'europe' | 'fertilizer' | 'forestry' | 'grains_and_oilseeds' | 'intl_index' | 'liq_nat_gas_lng' | 'livestock' | 'long_term_gov' | 'long_term_non_gov' | 'majors' | 'minors' | 'nat_gas' | 'nat_gas_liq_petro' | 'precious' | 'refined_products' | 's_and_p_gsci' | 'sel_sector_index' | 'short_term_gov' | 'short_term_non_gov' | 'softs' | 'us' | 'us_index' | 'wet_bulk'}
     * @memberof DefaultApiGetFuturesProducts
     */
    readonly sector?: GetFuturesProductsSectorEnum

    /**
     * The sub-sector to which the products belong.
     * @type {'asian' | 'canadian' | 'cat' | 'cooling_degree_days' | 'ercot' | 'european' | 'gulf' | 'heating_degree_days' | 'iso_ne' | 'large_cap_index' | 'mid_cap_index' | 'miso' | 'north_american' | 'nyiso' | 'pjm' | 'small_cap_index' | 'west' | 'western_power'}
     * @memberof DefaultApiGetFuturesProducts
     */
    readonly subSector?: GetFuturesProductsSubSectorEnum

    /**
     * The asset class to which the products belong.
     * @type {'alt_investment' | 'commodity' | 'financials'}
     * @memberof DefaultApiGetFuturesProducts
     */
    readonly assetClass?: GetFuturesProductsAssetClassEnum

    /**
     * The asset sub-class to which the products belong.
     * @type {'agricultural' | 'commodity_index' | 'energy' | 'equity' | 'foreign_exchange' | 'freight' | 'housing' | 'interest_rate' | 'metals' | 'weather'}
     * @memberof DefaultApiGetFuturesProducts
     */
    readonly assetSubClass?: GetFuturesProductsAssetSubClassEnum

    /**
     * The type of products to return. One of \&quot;all\&quot;, \&quot;single\&quot;, or \&quot;combo\&quot; (default&#x3D;all).
     * @type {'all' | 'single' | 'combo'}
     * @memberof DefaultApiGetFuturesProducts
     */
    readonly type?: GetFuturesProductsTypeEnum

    /**
     * The number of results to return per page (default&#x3D;100, maximum&#x3D;1000, minimum&#x3D;1).
     * @type {number}
     * @memberof DefaultApiGetFuturesProducts
     */
    readonly limit?: number

    /**
     * Search by name.
     * @type {string}
     * @memberof DefaultApiGetFuturesProducts
     */
    readonly nameSearch?: string

    /**
     * Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
     * @type {'name.asc' | 'name.desc' | 'trading_venue.asc' | 'trading_venue.desc' | 'sector.asc' | 'sector.desc' | 'sub_sector.asc' | 'sub_sector.desc' | 'asset_class.asc' | 'asset_class.desc' | 'asset_sub_class.asc' | 'asset_sub_class.desc' | 'type.asc' | 'type.desc'}
     * @memberof DefaultApiGetFuturesProducts
     */
    readonly sort?: GetFuturesProductsSortEnum
}

/**
 * Request parameters for getFuturesQuotes operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFuturesQuotesRequest
 */
export interface DefaultApiGetFuturesQuotesRequest {
    /**
     * The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
     * @type {string}
     * @memberof DefaultApiGetFuturesQuotes
     */
    readonly ticker: string

    /**
     * Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetFuturesQuotes
     */
    readonly timestamp?: string

    /**
     * Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
     * @type {string}
     * @memberof DefaultApiGetFuturesQuotes
     */
    readonly sessionEndDate?: string

    /**
     * The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1).
     * @type {number}
     * @memberof DefaultApiGetFuturesQuotes
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetFuturesQuotes
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetFuturesQuotes
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetFuturesQuotes
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetFuturesQuotes
     */
    readonly timestampLt?: string

    /**
     * Range by session_end_date.
     * @type {string}
     * @memberof DefaultApiGetFuturesQuotes
     */
    readonly sessionEndDateGte?: string

    /**
     * Range by session_end_date.
     * @type {string}
     * @memberof DefaultApiGetFuturesQuotes
     */
    readonly sessionEndDateGt?: string

    /**
     * Range by session_end_date.
     * @type {string}
     * @memberof DefaultApiGetFuturesQuotes
     */
    readonly sessionEndDateLte?: string

    /**
     * Range by session_end_date.
     * @type {string}
     * @memberof DefaultApiGetFuturesQuotes
     */
    readonly sessionEndDateLt?: string

    /**
     * Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
     * @type {'timestamp.asc' | 'timestamp.desc'}
     * @memberof DefaultApiGetFuturesQuotes
     */
    readonly sort?: GetFuturesQuotesSortEnum
}

/**
 * Request parameters for getFuturesTrades operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFuturesTradesRequest
 */
export interface DefaultApiGetFuturesTradesRequest {
    /**
     * The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
     * @type {string}
     * @memberof DefaultApiGetFuturesTrades
     */
    readonly ticker: string

    /**
     * Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetFuturesTrades
     */
    readonly timestamp?: string

    /**
     * Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format.
     * @type {string}
     * @memberof DefaultApiGetFuturesTrades
     */
    readonly sessionEndDate?: string

    /**
     * The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1).
     * @type {number}
     * @memberof DefaultApiGetFuturesTrades
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetFuturesTrades
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetFuturesTrades
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetFuturesTrades
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetFuturesTrades
     */
    readonly timestampLt?: string

    /**
     * Range by session_end_date.
     * @type {string}
     * @memberof DefaultApiGetFuturesTrades
     */
    readonly sessionEndDateGte?: string

    /**
     * Range by session_end_date.
     * @type {string}
     * @memberof DefaultApiGetFuturesTrades
     */
    readonly sessionEndDateGt?: string

    /**
     * Range by session_end_date.
     * @type {string}
     * @memberof DefaultApiGetFuturesTrades
     */
    readonly sessionEndDateLte?: string

    /**
     * Range by session_end_date.
     * @type {string}
     * @memberof DefaultApiGetFuturesTrades
     */
    readonly sessionEndDateLt?: string

    /**
     * Sort results by field and direction using dotted notation (e.g., \&#39;ticker.asc\&#39;, \&#39;name.desc\&#39;).
     * @type {'timestamp.asc' | 'timestamp.desc'}
     * @memberof DefaultApiGetFuturesTrades
     */
    readonly sort?: GetFuturesTradesSortEnum
}

/**
 * Request parameters for getFuturesVXContractsNew operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFuturesVXContractsNewRequest
 */
export interface DefaultApiGetFuturesVXContractsNewRequest {
    /**
     * A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day (default&#x3D;today). Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly date?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly dateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly dateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly dateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly dateLte?: string

    /**
     * The unique identifier for the product.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly productCode?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly productCodeAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly productCodeGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly productCodeGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly productCodeLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly productCodeLte?: string

    /**
     * The ticker for the contract.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly ticker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly tickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly tickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly tickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly tickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly tickerLte?: string

    /**
     * The contract is still trading. Value must be \&#39;true\&#39;, \&#39;false\&#39;, \&#39;1\&#39; or \&#39;0\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly active?: string

    /**
     * The type of product, one of \&#39;single\&#39; or \&#39;combo\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly type?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly typeAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly typeGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly typeGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly typeLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly typeLte?: string

    /**
     * The first date the contract trades. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly firstTradeDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly firstTradeDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly firstTradeDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly firstTradeDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly firstTradeDateLte?: string

    /**
     * The last date the contract trades. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly lastTradeDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly lastTradeDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly lastTradeDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly lastTradeDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly lastTradeDateLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;1000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;product_code\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXContractsNew
     */
    readonly sort?: string
}

/**
 * Request parameters for getFuturesVXExchanges operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFuturesVXExchangesRequest
 */
export interface DefaultApiGetFuturesVXExchangesRequest {
    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
     * @type {number}
     * @memberof DefaultApiGetFuturesVXExchanges
     */
    readonly limit?: number
}

/**
 * Request parameters for getFuturesVXProductsNew operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFuturesVXProductsNewRequest
 */
export interface DefaultApiGetFuturesVXProductsNewRequest {
    /**
     * The full name of the product.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly name?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly nameAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly nameGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly nameGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly nameLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly nameLte?: string

    /**
     * The unique identifier for the product.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly productCode?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly productCodeAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly productCodeGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly productCodeGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly productCodeLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly productCodeLte?: string

    /**
     * A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day (default&#x3D;today). Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly date?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly dateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly dateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly dateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly dateLte?: string

    /**
     * The sector to which the product belongs.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly sector?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly sectorAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly sectorGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly sectorGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly sectorLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly sectorLte?: string

    /**
     * The sub-sector to which the product belongs.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly subSector?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly subSectorAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly subSectorGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly subSectorGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly subSectorLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly subSectorLte?: string

    /**
     * The asset class to which the product belongs.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly assetClass?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly assetClassAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly assetClassGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly assetClassGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly assetClassLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly assetClassLte?: string

    /**
     * The asset sub-class to which the product belongs.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly assetSubClass?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly assetSubClassAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly assetSubClassGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly assetSubClassGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly assetSubClassLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly assetSubClassLte?: string

    /**
     * The type of product, one of \&#39;single\&#39; or \&#39;combo\&#39;.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly type?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly typeAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly typeGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly typeGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly typeLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly typeLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXProductsNew
     */
    readonly sort?: string
}

/**
 * Request parameters for getFuturesVXSnapshot operation in DefaultApi.
 * @export
 * @interface DefaultApiGetFuturesVXSnapshotRequest
 */
export interface DefaultApiGetFuturesVXSnapshotRequest {
    /**
     * The code for the contracts\&#39; underlying product.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXSnapshot
     */
    readonly productCode?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXSnapshot
     */
    readonly productCodeAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXSnapshot
     */
    readonly productCodeGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXSnapshot
     */
    readonly productCodeGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXSnapshot
     */
    readonly productCodeLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXSnapshot
     */
    readonly productCodeLte?: string

    /**
     * The futures contract identifier, including the base symbol and contract expiration (e.g., ESZ24 for the December 2024 S&amp;P 500 E-mini contract).
     * @type {string}
     * @memberof DefaultApiGetFuturesVXSnapshot
     */
    readonly ticker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXSnapshot
     */
    readonly tickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXSnapshot
     */
    readonly tickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXSnapshot
     */
    readonly tickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXSnapshot
     */
    readonly tickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXSnapshot
     */
    readonly tickerLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetFuturesVXSnapshot
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetFuturesVXSnapshot
     */
    readonly sort?: string
}

/**
 * Request parameters for getGroupedCryptoAggregates operation in DefaultApi.
 * @export
 * @interface DefaultApiGetGroupedCryptoAggregatesRequest
 */
export interface DefaultApiGetGroupedCryptoAggregatesRequest {
    /**
     * The beginning date for the aggregate window.
     * @type {string}
     * @memberof DefaultApiGetGroupedCryptoAggregates
     */
    readonly date: string

    /**
     * Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @type {boolean}
     * @memberof DefaultApiGetGroupedCryptoAggregates
     */
    readonly adjusted?: boolean
}

/**
 * Request parameters for getGroupedForexAggregates operation in DefaultApi.
 * @export
 * @interface DefaultApiGetGroupedForexAggregatesRequest
 */
export interface DefaultApiGetGroupedForexAggregatesRequest {
    /**
     * The beginning date for the aggregate window.
     * @type {string}
     * @memberof DefaultApiGetGroupedForexAggregates
     */
    readonly date: string

    /**
     * Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @type {boolean}
     * @memberof DefaultApiGetGroupedForexAggregates
     */
    readonly adjusted?: boolean
}

/**
 * Request parameters for getGroupedStocksAggregates operation in DefaultApi.
 * @export
 * @interface DefaultApiGetGroupedStocksAggregatesRequest
 */
export interface DefaultApiGetGroupedStocksAggregatesRequest {
    /**
     * The beginning date for the aggregate window.
     * @type {string}
     * @memberof DefaultApiGetGroupedStocksAggregates
     */
    readonly date: string

    /**
     * Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @type {boolean}
     * @memberof DefaultApiGetGroupedStocksAggregates
     */
    readonly adjusted?: boolean

    /**
     * Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
     * @type {boolean}
     * @memberof DefaultApiGetGroupedStocksAggregates
     */
    readonly includeOtc?: boolean
}

/**
 * Request parameters for getIndicesAggregates operation in DefaultApi.
 * @export
 * @interface DefaultApiGetIndicesAggregatesRequest
 */
export interface DefaultApiGetIndicesAggregatesRequest {
    /**
     * The ticker symbol of Index.
     * @type {string}
     * @memberof DefaultApiGetIndicesAggregates
     */
    readonly indicesTicker: string

    /**
     * The size of the timespan multiplier.
     * @type {number}
     * @memberof DefaultApiGetIndicesAggregates
     */
    readonly multiplier: number

    /**
     * The size of the time window.
     * @type {'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetIndicesAggregates
     */
    readonly timespan: GetIndicesAggregatesTimespanEnum

    /**
     * The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesAggregates
     */
    readonly from: string

    /**
     * The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesAggregates
     */
    readonly to: string

    /**
     * Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetIndicesAggregates
     */
    readonly sort?: GetIndicesAggregatesSortEnum

    /**
     * Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @type {number}
     * @memberof DefaultApiGetIndicesAggregates
     */
    readonly limit?: number
}

/**
 * Request parameters for getIndicesEMA operation in DefaultApi.
 * @export
 * @interface DefaultApiGetIndicesEMARequest
 */
export interface DefaultApiGetIndicesEMARequest {
    /**
     * The ticker symbol for which to get exponential moving average (EMA) data.
     * @type {string}
     * @memberof DefaultApiGetIndicesEMA
     */
    readonly indicesTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesEMA
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetIndicesEMA
     */
    readonly timespan?: GetIndicesEMATimespanEnum

    /**
     * Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetIndicesEMA
     */
    readonly adjusted?: boolean

    /**
     * The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @type {number}
     * @memberof DefaultApiGetIndicesEMA
     */
    readonly window?: number

    /**
     * The value in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the exponential moving average (EMA).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetIndicesEMA
     */
    readonly seriesType?: GetIndicesEMASeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetIndicesEMA
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetIndicesEMA
     */
    readonly order?: GetIndicesEMAOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetIndicesEMA
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesEMA
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesEMA
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesEMA
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesEMA
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getIndicesMACD operation in DefaultApi.
 * @export
 * @interface DefaultApiGetIndicesMACDRequest
 */
export interface DefaultApiGetIndicesMACDRequest {
    /**
     * The ticker symbol for which to get MACD data.
     * @type {string}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly indicesTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly timespan?: GetIndicesMACDTimespanEnum

    /**
     * Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly adjusted?: boolean

    /**
     * The short window size used to calculate MACD data.
     * @type {number}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly shortWindow?: number

    /**
     * The long window size used to calculate MACD data.
     * @type {number}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly longWindow?: number

    /**
     * The window size used to calculate the MACD signal line.
     * @type {number}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly signalWindow?: number

    /**
     * The value in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close values to  calculate the MACD.
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly seriesType?: GetIndicesMACDSeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly order?: GetIndicesMACDOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesMACD
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getIndicesOpenClose operation in DefaultApi.
 * @export
 * @interface DefaultApiGetIndicesOpenCloseRequest
 */
export interface DefaultApiGetIndicesOpenCloseRequest {
    /**
     * The ticker symbol of Index.
     * @type {string}
     * @memberof DefaultApiGetIndicesOpenClose
     */
    readonly indicesTicker: string

    /**
     * The date of the requested open/close in the format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiGetIndicesOpenClose
     */
    readonly date: string
}

/**
 * Request parameters for getIndicesRSI operation in DefaultApi.
 * @export
 * @interface DefaultApiGetIndicesRSIRequest
 */
export interface DefaultApiGetIndicesRSIRequest {
    /**
     * The ticker symbol for which to get relative strength index (RSI) data.
     * @type {string}
     * @memberof DefaultApiGetIndicesRSI
     */
    readonly indicesTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesRSI
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetIndicesRSI
     */
    readonly timespan?: GetIndicesRSITimespanEnum

    /**
     * Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetIndicesRSI
     */
    readonly adjusted?: boolean

    /**
     * The window size used to calculate the relative strength index (RSI).
     * @type {number}
     * @memberof DefaultApiGetIndicesRSI
     */
    readonly window?: number

    /**
     * The value in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close values to  calculate the relative strength index (RSI).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetIndicesRSI
     */
    readonly seriesType?: GetIndicesRSISeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetIndicesRSI
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetIndicesRSI
     */
    readonly order?: GetIndicesRSIOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetIndicesRSI
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesRSI
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesRSI
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesRSI
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesRSI
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getIndicesSMA operation in DefaultApi.
 * @export
 * @interface DefaultApiGetIndicesSMARequest
 */
export interface DefaultApiGetIndicesSMARequest {
    /**
     * The ticker symbol for which to get simple moving average (SMA) data.
     * @type {string}
     * @memberof DefaultApiGetIndicesSMA
     */
    readonly indicesTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesSMA
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetIndicesSMA
     */
    readonly timespan?: GetIndicesSMATimespanEnum

    /**
     * Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetIndicesSMA
     */
    readonly adjusted?: boolean

    /**
     * The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @type {number}
     * @memberof DefaultApiGetIndicesSMA
     */
    readonly window?: number

    /**
     * The value in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close values to  calculate the simple moving average (SMA).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetIndicesSMA
     */
    readonly seriesType?: GetIndicesSMASeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetIndicesSMA
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetIndicesSMA
     */
    readonly order?: GetIndicesSMAOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetIndicesSMA
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesSMA
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesSMA
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesSMA
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetIndicesSMA
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getIndicesSnapshot operation in DefaultApi.
 * @export
 * @interface DefaultApiGetIndicesSnapshotRequest
 */
export interface DefaultApiGetIndicesSnapshotRequest {
    /**
     * Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
     * @type {string}
     * @memberof DefaultApiGetIndicesSnapshot
     */
    readonly tickerAnyOf?: string

    /**
     * Search a range of tickers lexicographically.
     * @type {string}
     * @memberof DefaultApiGetIndicesSnapshot
     */
    readonly ticker?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiGetIndicesSnapshot
     */
    readonly tickerGte?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiGetIndicesSnapshot
     */
    readonly tickerGt?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiGetIndicesSnapshot
     */
    readonly tickerLte?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiGetIndicesSnapshot
     */
    readonly tickerLt?: string

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetIndicesSnapshot
     */
    readonly order?: GetIndicesSnapshotOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 250.
     * @type {number}
     * @memberof DefaultApiGetIndicesSnapshot
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'ticker'}
     * @memberof DefaultApiGetIndicesSnapshot
     */
    readonly sort?: GetIndicesSnapshotSortEnum
}

/**
 * Request parameters for getLastCryptoTrade operation in DefaultApi.
 * @export
 * @interface DefaultApiGetLastCryptoTradeRequest
 */
export interface DefaultApiGetLastCryptoTradeRequest {
    /**
     * The \&quot;from\&quot; symbol of the pair.
     * @type {string}
     * @memberof DefaultApiGetLastCryptoTrade
     */
    readonly from: string

    /**
     * The \&quot;to\&quot; symbol of the pair.
     * @type {string}
     * @memberof DefaultApiGetLastCryptoTrade
     */
    readonly to: string
}

/**
 * Request parameters for getLastCurrencyQuote operation in DefaultApi.
 * @export
 * @interface DefaultApiGetLastCurrencyQuoteRequest
 */
export interface DefaultApiGetLastCurrencyQuoteRequest {
    /**
     * The \&quot;from\&quot; symbol of the pair.
     * @type {string}
     * @memberof DefaultApiGetLastCurrencyQuote
     */
    readonly from: string

    /**
     * The \&quot;to\&quot; symbol of the pair.
     * @type {string}
     * @memberof DefaultApiGetLastCurrencyQuote
     */
    readonly to: string
}

/**
 * Request parameters for getLastOptionsTrade operation in DefaultApi.
 * @export
 * @interface DefaultApiGetLastOptionsTradeRequest
 */
export interface DefaultApiGetLastOptionsTradeRequest {
    /**
     * The ticker symbol of the options contract.
     * @type {string}
     * @memberof DefaultApiGetLastOptionsTrade
     */
    readonly optionsTicker: string
}

/**
 * Request parameters for getLastStocksQuote operation in DefaultApi.
 * @export
 * @interface DefaultApiGetLastStocksQuoteRequest
 */
export interface DefaultApiGetLastStocksQuoteRequest {
    /**
     * Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiGetLastStocksQuote
     */
    readonly stocksTicker: string
}

/**
 * Request parameters for getLastStocksTrade operation in DefaultApi.
 * @export
 * @interface DefaultApiGetLastStocksTradeRequest
 */
export interface DefaultApiGetLastStocksTradeRequest {
    /**
     * Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiGetLastStocksTrade
     */
    readonly stocksTicker: string
}

/**
 * Request parameters for getOptionContract operation in DefaultApi.
 * @export
 * @interface DefaultApiGetOptionContractRequest
 */
export interface DefaultApiGetOptionContractRequest {
    /**
     * The underlying ticker symbol of the option contract.
     * @type {string}
     * @memberof DefaultApiGetOptionContract
     */
    readonly underlyingAsset: string

    /**
     * The option contract identifier.
     * @type {string}
     * @memberof DefaultApiGetOptionContract
     */
    readonly optionContract: string
}

/**
 * Request parameters for getOptionsAggregates operation in DefaultApi.
 * @export
 * @interface DefaultApiGetOptionsAggregatesRequest
 */
export interface DefaultApiGetOptionsAggregatesRequest {
    /**
     * The ticker symbol of the options contract.
     * @type {string}
     * @memberof DefaultApiGetOptionsAggregates
     */
    readonly optionsTicker: string

    /**
     * The size of the timespan multiplier.
     * @type {number}
     * @memberof DefaultApiGetOptionsAggregates
     */
    readonly multiplier: number

    /**
     * The size of the time window.
     * @type {'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetOptionsAggregates
     */
    readonly timespan: GetOptionsAggregatesTimespanEnum

    /**
     * The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsAggregates
     */
    readonly from: string

    /**
     * The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsAggregates
     */
    readonly to: string

    /**
     * Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @type {boolean}
     * @memberof DefaultApiGetOptionsAggregates
     */
    readonly adjusted?: boolean

    /**
     * Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetOptionsAggregates
     */
    readonly sort?: GetOptionsAggregatesSortEnum

    /**
     * Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @type {number}
     * @memberof DefaultApiGetOptionsAggregates
     */
    readonly limit?: number
}

/**
 * Request parameters for getOptionsChain operation in DefaultApi.
 * @export
 * @interface DefaultApiGetOptionsChainRequest
 */
export interface DefaultApiGetOptionsChainRequest {
    /**
     * The underlying ticker symbol of the option contract.
     * @type {string}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly underlyingAsset: string

    /**
     * Query by strike price of a contract.
     * @type {number}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly strikePrice?: number

    /**
     * Query by contract expiration with date format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly expirationDate?: string

    /**
     * Query by the type of contract.
     * @type {'call' | 'put'}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly contractType?: GetOptionsChainContractTypeEnum

    /**
     * Range by strike_price.
     * @type {number}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly strikePriceGte?: number

    /**
     * Range by strike_price.
     * @type {number}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly strikePriceGt?: number

    /**
     * Range by strike_price.
     * @type {number}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly strikePriceLte?: number

    /**
     * Range by strike_price.
     * @type {number}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly strikePriceLt?: number

    /**
     * Range by expiration_date.
     * @type {string}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly expirationDateGte?: string

    /**
     * Range by expiration_date.
     * @type {string}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly expirationDateGt?: string

    /**
     * Range by expiration_date.
     * @type {string}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly expirationDateLte?: string

    /**
     * Range by expiration_date.
     * @type {string}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly expirationDateLt?: string

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly order?: GetOptionsChainOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 250.
     * @type {number}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'ticker' | 'expiration_date' | 'strike_price'}
     * @memberof DefaultApiGetOptionsChain
     */
    readonly sort?: GetOptionsChainSortEnum
}

/**
 * Request parameters for getOptionsContract operation in DefaultApi.
 * @export
 * @interface DefaultApiGetOptionsContractRequest
 */
export interface DefaultApiGetOptionsContractRequest {
    /**
     * Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://massive.com/blog/how-to-read-a-stock-options-ticker/).
     * @type {string}
     * @memberof DefaultApiGetOptionsContract
     */
    readonly optionsTicker: string

    /**
     * Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
     * @type {string}
     * @memberof DefaultApiGetOptionsContract
     */
    readonly asOf?: string
}

/**
 * Request parameters for getOptionsEMA operation in DefaultApi.
 * @export
 * @interface DefaultApiGetOptionsEMARequest
 */
export interface DefaultApiGetOptionsEMARequest {
    /**
     * The ticker symbol for which to get exponential moving average (EMA) data.
     * @type {string}
     * @memberof DefaultApiGetOptionsEMA
     */
    readonly optionsTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsEMA
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetOptionsEMA
     */
    readonly timespan?: GetOptionsEMATimespanEnum

    /**
     * Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetOptionsEMA
     */
    readonly adjusted?: boolean

    /**
     * The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @type {number}
     * @memberof DefaultApiGetOptionsEMA
     */
    readonly window?: number

    /**
     * The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetOptionsEMA
     */
    readonly seriesType?: GetOptionsEMASeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetOptionsEMA
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetOptionsEMA
     */
    readonly order?: GetOptionsEMAOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetOptionsEMA
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsEMA
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsEMA
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsEMA
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsEMA
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getOptionsMACD operation in DefaultApi.
 * @export
 * @interface DefaultApiGetOptionsMACDRequest
 */
export interface DefaultApiGetOptionsMACDRequest {
    /**
     * The ticker symbol for which to get MACD data.
     * @type {string}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly optionsTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly timespan?: GetOptionsMACDTimespanEnum

    /**
     * Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly adjusted?: boolean

    /**
     * The short window size used to calculate MACD data.
     * @type {number}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly shortWindow?: number

    /**
     * The long window size used to calculate MACD data.
     * @type {number}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly longWindow?: number

    /**
     * The window size used to calculate the MACD signal line.
     * @type {number}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly signalWindow?: number

    /**
     * The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly seriesType?: GetOptionsMACDSeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly order?: GetOptionsMACDOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsMACD
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getOptionsOpenClose operation in DefaultApi.
 * @export
 * @interface DefaultApiGetOptionsOpenCloseRequest
 */
export interface DefaultApiGetOptionsOpenCloseRequest {
    /**
     * The ticker symbol of the options contract.
     * @type {string}
     * @memberof DefaultApiGetOptionsOpenClose
     */
    readonly optionsTicker: string

    /**
     * The date of the requested open/close in the format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiGetOptionsOpenClose
     */
    readonly date: string

    /**
     * Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @type {boolean}
     * @memberof DefaultApiGetOptionsOpenClose
     */
    readonly adjusted?: boolean
}

/**
 * Request parameters for getOptionsQuotes operation in DefaultApi.
 * @export
 * @interface DefaultApiGetOptionsQuotesRequest
 */
export interface DefaultApiGetOptionsQuotesRequest {
    /**
     * The ticker symbol to get quotes for.
     * @type {string}
     * @memberof DefaultApiGetOptionsQuotes
     */
    readonly optionsTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsQuotes
     */
    readonly timestamp?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsQuotes
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsQuotes
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsQuotes
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsQuotes
     */
    readonly timestampLt?: string

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetOptionsQuotes
     */
    readonly order?: GetOptionsQuotesOrderEnum

    /**
     * Limit the number of results returned, default is 1000 and max is 50000.
     * @type {number}
     * @memberof DefaultApiGetOptionsQuotes
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'timestamp'}
     * @memberof DefaultApiGetOptionsQuotes
     */
    readonly sort?: GetOptionsQuotesSortEnum
}

/**
 * Request parameters for getOptionsRSI operation in DefaultApi.
 * @export
 * @interface DefaultApiGetOptionsRSIRequest
 */
export interface DefaultApiGetOptionsRSIRequest {
    /**
     * The ticker symbol for which to get relative strength index (RSI) data.
     * @type {string}
     * @memberof DefaultApiGetOptionsRSI
     */
    readonly optionsTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsRSI
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetOptionsRSI
     */
    readonly timespan?: GetOptionsRSITimespanEnum

    /**
     * Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetOptionsRSI
     */
    readonly adjusted?: boolean

    /**
     * The window size used to calculate the relative strength index (RSI).
     * @type {number}
     * @memberof DefaultApiGetOptionsRSI
     */
    readonly window?: number

    /**
     * The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetOptionsRSI
     */
    readonly seriesType?: GetOptionsRSISeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetOptionsRSI
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetOptionsRSI
     */
    readonly order?: GetOptionsRSIOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetOptionsRSI
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsRSI
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsRSI
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsRSI
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsRSI
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getOptionsSMA operation in DefaultApi.
 * @export
 * @interface DefaultApiGetOptionsSMARequest
 */
export interface DefaultApiGetOptionsSMARequest {
    /**
     * The ticker symbol for which to get simple moving average (SMA) data.
     * @type {string}
     * @memberof DefaultApiGetOptionsSMA
     */
    readonly optionsTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsSMA
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetOptionsSMA
     */
    readonly timespan?: GetOptionsSMATimespanEnum

    /**
     * Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetOptionsSMA
     */
    readonly adjusted?: boolean

    /**
     * The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @type {number}
     * @memberof DefaultApiGetOptionsSMA
     */
    readonly window?: number

    /**
     * The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetOptionsSMA
     */
    readonly seriesType?: GetOptionsSMASeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetOptionsSMA
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetOptionsSMA
     */
    readonly order?: GetOptionsSMAOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetOptionsSMA
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsSMA
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsSMA
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsSMA
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsSMA
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getOptionsTrades operation in DefaultApi.
 * @export
 * @interface DefaultApiGetOptionsTradesRequest
 */
export interface DefaultApiGetOptionsTradesRequest {
    /**
     * The options ticker symbol to get trades for.
     * @type {string}
     * @memberof DefaultApiGetOptionsTrades
     */
    readonly optionsTicker: string

    /**
     * Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsTrades
     */
    readonly timestamp?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsTrades
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsTrades
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsTrades
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetOptionsTrades
     */
    readonly timestampLt?: string

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetOptionsTrades
     */
    readonly order?: GetOptionsTradesOrderEnum

    /**
     * Limit the number of results returned, default is 1000 and max is 50000.
     * @type {number}
     * @memberof DefaultApiGetOptionsTrades
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'timestamp'}
     * @memberof DefaultApiGetOptionsTrades
     */
    readonly sort?: GetOptionsTradesSortEnum
}

/**
 * Request parameters for getOptionsV1Exchanges operation in DefaultApi.
 * @export
 * @interface DefaultApiGetOptionsV1ExchangesRequest
 */
export interface DefaultApiGetOptionsV1ExchangesRequest {
    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
     * @type {number}
     * @memberof DefaultApiGetOptionsV1Exchanges
     */
    readonly limit?: number
}

/**
 * Request parameters for getPreviousCryptoAggregates operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPreviousCryptoAggregatesRequest
 */
export interface DefaultApiGetPreviousCryptoAggregatesRequest {
    /**
     * The ticker symbol of the currency pair.
     * @type {string}
     * @memberof DefaultApiGetPreviousCryptoAggregates
     */
    readonly cryptoTicker: string

    /**
     * Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @type {boolean}
     * @memberof DefaultApiGetPreviousCryptoAggregates
     */
    readonly adjusted?: boolean
}

/**
 * Request parameters for getPreviousForexAggregates operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPreviousForexAggregatesRequest
 */
export interface DefaultApiGetPreviousForexAggregatesRequest {
    /**
     * The ticker symbol of the currency pair.
     * @type {string}
     * @memberof DefaultApiGetPreviousForexAggregates
     */
    readonly forexTicker: string

    /**
     * Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @type {boolean}
     * @memberof DefaultApiGetPreviousForexAggregates
     */
    readonly adjusted?: boolean
}

/**
 * Request parameters for getPreviousIndicesAggregates operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPreviousIndicesAggregatesRequest
 */
export interface DefaultApiGetPreviousIndicesAggregatesRequest {
    /**
     * The ticker symbol of Index.
     * @type {string}
     * @memberof DefaultApiGetPreviousIndicesAggregates
     */
    readonly indicesTicker: string
}

/**
 * Request parameters for getPreviousOptionsAggregates operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPreviousOptionsAggregatesRequest
 */
export interface DefaultApiGetPreviousOptionsAggregatesRequest {
    /**
     * The ticker symbol of the options contract.
     * @type {string}
     * @memberof DefaultApiGetPreviousOptionsAggregates
     */
    readonly optionsTicker: string

    /**
     * Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @type {boolean}
     * @memberof DefaultApiGetPreviousOptionsAggregates
     */
    readonly adjusted?: boolean
}

/**
 * Request parameters for getPreviousStocksAggregates operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPreviousStocksAggregatesRequest
 */
export interface DefaultApiGetPreviousStocksAggregatesRequest {
    /**
     * Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiGetPreviousStocksAggregates
     */
    readonly stocksTicker: string

    /**
     * Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @type {boolean}
     * @memberof DefaultApiGetPreviousStocksAggregates
     */
    readonly adjusted?: boolean
}

/**
 * Request parameters for getRelatedCompanies operation in DefaultApi.
 * @export
 * @interface DefaultApiGetRelatedCompaniesRequest
 */
export interface DefaultApiGetRelatedCompaniesRequest {
    /**
     * The ticker symbol to search.
     * @type {string}
     * @memberof DefaultApiGetRelatedCompanies
     */
    readonly ticker: string
}

/**
 * Request parameters for getSnapshotSummary operation in DefaultApi.
 * @export
 * @interface DefaultApiGetSnapshotSummaryRequest
 */
export interface DefaultApiGetSnapshotSummaryRequest {
    /**
     * Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://massive.com/docs/rest/stocks/tickers/all-tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.
     * @type {string}
     * @memberof DefaultApiGetSnapshotSummary
     */
    readonly tickerAnyOf?: string
}

/**
 * Request parameters for getSnapshots operation in DefaultApi.
 * @export
 * @interface DefaultApiGetSnapshotsRequest
 */
export interface DefaultApiGetSnapshotsRequest {
    /**
     * Search a range of tickers lexicographically.
     * @type {string}
     * @memberof DefaultApiGetSnapshots
     */
    readonly ticker?: string

    /**
     * Query by the type of asset.
     * @type {'stocks' | 'options' | 'crypto' | 'fx' | 'indices'}
     * @memberof DefaultApiGetSnapshots
     */
    readonly type?: GetSnapshotsTypeEnum

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiGetSnapshots
     */
    readonly tickerGte?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiGetSnapshots
     */
    readonly tickerGt?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiGetSnapshots
     */
    readonly tickerLte?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiGetSnapshots
     */
    readonly tickerLt?: string

    /**
     * Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. 
     * @type {string}
     * @memberof DefaultApiGetSnapshots
     */
    readonly tickerAnyOf?: string

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetSnapshots
     */
    readonly order?: GetSnapshotsOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 250.
     * @type {number}
     * @memberof DefaultApiGetSnapshots
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'ticker'}
     * @memberof DefaultApiGetSnapshots
     */
    readonly sort?: GetSnapshotsSortEnum
}

/**
 * Request parameters for getStocksAggregates operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksAggregatesRequest
 */
export interface DefaultApiGetStocksAggregatesRequest {
    /**
     * Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiGetStocksAggregates
     */
    readonly stocksTicker: string

    /**
     * The size of the timespan multiplier.
     * @type {number}
     * @memberof DefaultApiGetStocksAggregates
     */
    readonly multiplier: number

    /**
     * The size of the time window.
     * @type {'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetStocksAggregates
     */
    readonly timespan: GetStocksAggregatesTimespanEnum

    /**
     * The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksAggregates
     */
    readonly from: string

    /**
     * The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksAggregates
     */
    readonly to: string

    /**
     * Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @type {boolean}
     * @memberof DefaultApiGetStocksAggregates
     */
    readonly adjusted?: boolean

    /**
     * Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top). 
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetStocksAggregates
     */
    readonly sort?: GetStocksAggregatesSortEnum

    /**
     * Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;. 
     * @type {number}
     * @memberof DefaultApiGetStocksAggregates
     */
    readonly limit?: number
}

/**
 * Request parameters for getStocksEMA operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksEMARequest
 */
export interface DefaultApiGetStocksEMARequest {
    /**
     * Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiGetStocksEMA
     */
    readonly stockTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksEMA
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetStocksEMA
     */
    readonly timespan?: GetStocksEMATimespanEnum

    /**
     * Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetStocksEMA
     */
    readonly adjusted?: boolean

    /**
     * The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @type {number}
     * @memberof DefaultApiGetStocksEMA
     */
    readonly window?: number

    /**
     * The price in the aggregate which will be used to calculate the exponential moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the exponential moving average (EMA).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetStocksEMA
     */
    readonly seriesType?: GetStocksEMASeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetStocksEMA
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetStocksEMA
     */
    readonly order?: GetStocksEMAOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetStocksEMA
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksEMA
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksEMA
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksEMA
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksEMA
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getStocksFinancialsV1BalanceSheets operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksFinancialsV1BalanceSheetsRequest
 */
export interface DefaultApiGetStocksFinancialsV1BalanceSheetsRequest {
    /**
     * The company\&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a company\&#39;s CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly cik?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly cikAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly cikGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly cikGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly cikLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly cikLte?: string

    /**
     * Filter for arrays that contain the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly tickers?: string

    /**
     * Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly tickersAllOf?: string

    /**
     * Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly tickersAnyOf?: string

    /**
     * The last date of the reporting period, representing the specific point in time when the balance sheet snapshot was taken. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly periodEnd?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly periodEndGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly periodEndGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly periodEndLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly periodEndLte?: string

    /**
     * The date when the financial statement was filed with the SEC. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly filingDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly filingDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly filingDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly filingDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly filingDateLte?: string

    /**
     * The fiscal year for the reporting period. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly fiscalYear?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly fiscalYearGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly fiscalYearGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly fiscalYearLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly fiscalYearLte?: number

    /**
     * The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly fiscalQuarter?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly fiscalQuarterGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly fiscalQuarterGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly fiscalQuarterLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly fiscalQuarterLte?: number

    /**
     * The reporting period type. Possible values include: quarterly, annual.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly timeframe?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly timeframeAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly timeframeGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly timeframeGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly timeframeLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly timeframeLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;period_end\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1BalanceSheets
     */
    readonly sort?: string
}

/**
 * Request parameters for getStocksFinancialsV1CashFlowStatements operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksFinancialsV1CashFlowStatementsRequest
 */
export interface DefaultApiGetStocksFinancialsV1CashFlowStatementsRequest {
    /**
     * The company\&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly cik?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly cikAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly cikGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly cikGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly cikLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly cikLte?: string

    /**
     * The last date of the reporting period (formatted as YYYY-MM-DD). Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly periodEnd?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly periodEndGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly periodEndGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly periodEndLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly periodEndLte?: string

    /**
     * The date when the financial statement was filed with the SEC. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly filingDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly filingDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly filingDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly filingDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly filingDateLte?: string

    /**
     * Filter for arrays that contain the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly tickers?: string

    /**
     * Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly tickersAllOf?: string

    /**
     * Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly tickersAnyOf?: string

    /**
     * The fiscal year for the reporting period. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly fiscalYear?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly fiscalYearGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly fiscalYearGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly fiscalYearLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly fiscalYearLte?: number

    /**
     * The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly fiscalQuarter?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly fiscalQuarterGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly fiscalQuarterGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly fiscalQuarterLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly fiscalQuarterLte?: number

    /**
     * The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly timeframe?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly timeframeAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly timeframeGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly timeframeGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly timeframeLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly timeframeLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;period_end\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1CashFlowStatements
     */
    readonly sort?: string
}

/**
 * Request parameters for getStocksFinancialsV1IncomeStatements operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksFinancialsV1IncomeStatementsRequest
 */
export interface DefaultApiGetStocksFinancialsV1IncomeStatementsRequest {
    /**
     * The company\&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup).
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly cik?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly cikAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly cikGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly cikGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly cikLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly cikLte?: string

    /**
     * Filter for arrays that contain the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly tickers?: string

    /**
     * Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly tickersAllOf?: string

    /**
     * Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly tickersAnyOf?: string

    /**
     * The last date of the reporting period (formatted as YYYY-MM-DD). Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly periodEnd?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly periodEndGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly periodEndGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly periodEndLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly periodEndLte?: string

    /**
     * The date when the financial statement was filed with the SEC. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly filingDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly filingDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly filingDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly filingDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly filingDateLte?: string

    /**
     * The fiscal year for the reporting period. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly fiscalYear?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly fiscalYearGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly fiscalYearGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly fiscalYearLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly fiscalYearLte?: number

    /**
     * The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly fiscalQuarter?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly fiscalQuarterGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly fiscalQuarterGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly fiscalQuarterLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly fiscalQuarterLte?: number

    /**
     * The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly timeframe?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly timeframeAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly timeframeGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly timeframeGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly timeframeLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly timeframeLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;period_end\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1IncomeStatements
     */
    readonly sort?: string
}

/**
 * Request parameters for getStocksFinancialsV1Ratios operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksFinancialsV1RatiosRequest
 */
export interface DefaultApiGetStocksFinancialsV1RatiosRequest {
    /**
     * Stock ticker symbol for the company.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly ticker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly tickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly tickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly tickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly tickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly tickerLte?: string

    /**
     * Central Index Key (CIK) number assigned by the SEC to identify the company.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly cik?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly cikAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly cikGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly cikGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly cikLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly cikLte?: string

    /**
     * Stock price used in ratio calculations, typically the closing price for the given date. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly price?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceLte?: number

    /**
     * Average trading volume over the last 30 trading days, providing context for liquidity. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly averageVolume?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly averageVolumeGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly averageVolumeGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly averageVolumeLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly averageVolumeLte?: number

    /**
     * Market capitalization, calculated as stock price multiplied by total shares outstanding. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly marketCap?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly marketCapGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly marketCapGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly marketCapLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly marketCapLte?: number

    /**
     * Earnings per share, calculated as net income available to common shareholders divided by weighted shares outstanding. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly earningsPerShare?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly earningsPerShareGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly earningsPerShareGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly earningsPerShareLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly earningsPerShareLte?: number

    /**
     * Price-to-earnings ratio, calculated as stock price divided by earnings per share. Only calculated when earnings per share is positive. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToEarnings?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToEarningsGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToEarningsGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToEarningsLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToEarningsLte?: number

    /**
     * Price-to-book ratio, calculated as stock price divided by book value per share, comparing market value to book value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToBook?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToBookGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToBookGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToBookLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToBookLte?: number

    /**
     * Price-to-sales ratio, calculated as stock price divided by revenue per share, measuring valuation relative to sales. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToSales?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToSalesGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToSalesGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToSalesLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToSalesLte?: number

    /**
     * Price-to-cash-flow ratio, calculated as stock price divided by operating cash flow per share. Only calculated when operating cash flow per share is positive. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToCashFlow?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToCashFlowGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToCashFlowGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToCashFlowLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToCashFlowLte?: number

    /**
     * Price-to-free-cash-flow ratio, calculated as stock price divided by free cash flow per share. Only calculated when free cash flow per share is positive. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToFreeCashFlow?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToFreeCashFlowGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToFreeCashFlowGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToFreeCashFlowLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly priceToFreeCashFlowLte?: number

    /**
     * Dividend yield, calculated as annual dividends per share divided by stock price, measuring the income return on investment. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly dividendYield?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly dividendYieldGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly dividendYieldGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly dividendYieldLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly dividendYieldLte?: number

    /**
     * Return on assets ratio, calculated as net income divided by total assets, measuring how efficiently a company uses its assets to generate profit. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly returnOnAssets?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly returnOnAssetsGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly returnOnAssetsGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly returnOnAssetsLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly returnOnAssetsLte?: number

    /**
     * Return on equity ratio, calculated as net income divided by total shareholders\&#39; equity, measuring profitability relative to shareholders\&#39; equity. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly returnOnEquity?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly returnOnEquityGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly returnOnEquityGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly returnOnEquityLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly returnOnEquityLte?: number

    /**
     * Debt-to-equity ratio, calculated as total debt (current debt plus long-term debt) divided by total shareholders\&#39; equity, measuring financial leverage. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly debtToEquity?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly debtToEquityGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly debtToEquityGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly debtToEquityLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly debtToEquityLte?: number

    /**
     * Current ratio, calculated as total current assets divided by total current liabilities, measuring short-term liquidity. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly current?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly currentGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly currentGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly currentLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly currentLte?: number

    /**
     * Quick ratio (acid-test ratio), calculated as (current assets minus inventories) divided by current liabilities, measuring immediate liquidity. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly quick?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly quickGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly quickGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly quickLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly quickLte?: number

    /**
     * Cash ratio, calculated as cash and cash equivalents divided by current liabilities, measuring the most liquid form of liquidity coverage. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly cash?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly cashGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly cashGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly cashLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly cashLte?: number

    /**
     * Enterprise value to sales ratio, calculated as enterprise value divided by revenue, measuring company valuation relative to sales. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly evToSales?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly evToSalesGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly evToSalesGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly evToSalesLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly evToSalesLte?: number

    /**
     * Enterprise value to EBITDA ratio, calculated as enterprise value divided by EBITDA, measuring company valuation relative to earnings before interest, taxes, depreciation, and amortization. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly evToEbitda?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly evToEbitdaGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly evToEbitdaGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly evToEbitdaLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly evToEbitdaLte?: number

    /**
     * Enterprise value, calculated as market capitalization plus total debt minus cash and cash equivalents, representing total company value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly enterpriseValue?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly enterpriseValueGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly enterpriseValueGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly enterpriseValueLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly enterpriseValueLte?: number

    /**
     * Free cash flow, calculated as operating cash flow minus capital expenditures (purchase of property, plant, and equipment). Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly freeCashFlow?: number

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly freeCashFlowGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly freeCashFlowGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly freeCashFlowLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly freeCashFlowLte?: number

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetStocksFinancialsV1Ratios
     */
    readonly sort?: string
}

/**
 * Request parameters for getStocksMACD operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksMACDRequest
 */
export interface DefaultApiGetStocksMACDRequest {
    /**
     * Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly stockTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly timespan?: GetStocksMACDTimespanEnum

    /**
     * Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly adjusted?: boolean

    /**
     * The short window size used to calculate MACD data.
     * @type {number}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly shortWindow?: number

    /**
     * The long window size used to calculate MACD data.
     * @type {number}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly longWindow?: number

    /**
     * The window size used to calculate the MACD signal line.
     * @type {number}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly signalWindow?: number

    /**
     * The price in the aggregate which will be used to calculate the MACD. i.e. \&#39;close\&#39; will result in using close prices to  calculate the MACD.
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly seriesType?: GetStocksMACDSeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly order?: GetStocksMACDOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksMACD
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getStocksOpenClose operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksOpenCloseRequest
 */
export interface DefaultApiGetStocksOpenCloseRequest {
    /**
     * Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiGetStocksOpenClose
     */
    readonly stocksTicker: string

    /**
     * The date of the requested open/close in the format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiGetStocksOpenClose
     */
    readonly date: string

    /**
     * Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits. 
     * @type {boolean}
     * @memberof DefaultApiGetStocksOpenClose
     */
    readonly adjusted?: boolean
}

/**
 * Request parameters for getStocksQuotes operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksQuotesRequest
 */
export interface DefaultApiGetStocksQuotesRequest {
    /**
     * Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiGetStocksQuotes
     */
    readonly stockTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksQuotes
     */
    readonly timestamp?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksQuotes
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksQuotes
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksQuotes
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksQuotes
     */
    readonly timestampLt?: string

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetStocksQuotes
     */
    readonly order?: GetStocksQuotesOrderEnum

    /**
     * Limit the number of results returned, default is 1000 and max is 50000.
     * @type {number}
     * @memberof DefaultApiGetStocksQuotes
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'timestamp'}
     * @memberof DefaultApiGetStocksQuotes
     */
    readonly sort?: GetStocksQuotesSortEnum
}

/**
 * Request parameters for getStocksRSI operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksRSIRequest
 */
export interface DefaultApiGetStocksRSIRequest {
    /**
     * Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiGetStocksRSI
     */
    readonly stockTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksRSI
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetStocksRSI
     */
    readonly timespan?: GetStocksRSITimespanEnum

    /**
     * Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetStocksRSI
     */
    readonly adjusted?: boolean

    /**
     * The window size used to calculate the relative strength index (RSI).
     * @type {number}
     * @memberof DefaultApiGetStocksRSI
     */
    readonly window?: number

    /**
     * The price in the aggregate which will be used to calculate the relative strength index. i.e. \&#39;close\&#39; will result in using close prices to  calculate the relative strength index (RSI).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetStocksRSI
     */
    readonly seriesType?: GetStocksRSISeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetStocksRSI
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetStocksRSI
     */
    readonly order?: GetStocksRSIOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetStocksRSI
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksRSI
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksRSI
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksRSI
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksRSI
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getStocksSMA operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksSMARequest
 */
export interface DefaultApiGetStocksSMARequest {
    /**
     * Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiGetStocksSMA
     */
    readonly stockTicker: string

    /**
     * Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksSMA
     */
    readonly timestamp?: string

    /**
     * The size of the aggregate time window.
     * @type {'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetStocksSMA
     */
    readonly timespan?: GetStocksSMATimespanEnum

    /**
     * Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.
     * @type {boolean}
     * @memberof DefaultApiGetStocksSMA
     */
    readonly adjusted?: boolean

    /**
     * The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.
     * @type {number}
     * @memberof DefaultApiGetStocksSMA
     */
    readonly window?: number

    /**
     * The price in the aggregate which will be used to calculate the simple moving average. i.e. \&#39;close\&#39; will result in using close prices to  calculate the simple moving average (SMA).
     * @type {'open' | 'high' | 'low' | 'close'}
     * @memberof DefaultApiGetStocksSMA
     */
    readonly seriesType?: GetStocksSMASeriesTypeEnum

    /**
     * Whether or not to include the aggregates used to calculate this indicator in the response.
     * @type {boolean}
     * @memberof DefaultApiGetStocksSMA
     */
    readonly expandUnderlying?: boolean

    /**
     * The order in which to return the results, ordered by timestamp.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetStocksSMA
     */
    readonly order?: GetStocksSMAOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 5000
     * @type {number}
     * @memberof DefaultApiGetStocksSMA
     */
    readonly limit?: number

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksSMA
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksSMA
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksSMA
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksSMA
     */
    readonly timestampLt?: string
}

/**
 * Request parameters for getStocksSnapshotDirection operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksSnapshotDirectionRequest
 */
export interface DefaultApiGetStocksSnapshotDirectionRequest {
    /**
     * The direction of the snapshot results to return. 
     * @type {'gainers' | 'losers'}
     * @memberof DefaultApiGetStocksSnapshotDirection
     */
    readonly direction: GetStocksSnapshotDirectionDirectionEnum

    /**
     * Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
     * @type {boolean}
     * @memberof DefaultApiGetStocksSnapshotDirection
     */
    readonly includeOtc?: boolean
}

/**
 * Request parameters for getStocksSnapshotTicker operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksSnapshotTickerRequest
 */
export interface DefaultApiGetStocksSnapshotTickerRequest {
    /**
     * Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiGetStocksSnapshotTicker
     */
    readonly stocksTicker: string
}

/**
 * Request parameters for getStocksSnapshotTickers operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksSnapshotTickersRequest
 */
export interface DefaultApiGetStocksSnapshotTickersRequest {
    /**
     * A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers.
     * @type {Array<string>}
     * @memberof DefaultApiGetStocksSnapshotTickers
     */
    readonly tickers?: Array<string>

    /**
     * Include OTC securities in the response. Default is false (don\&#39;t include OTC securities). 
     * @type {boolean}
     * @memberof DefaultApiGetStocksSnapshotTickers
     */
    readonly includeOtc?: boolean
}

/**
 * Request parameters for getStocksTrades operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksTradesRequest
 */
export interface DefaultApiGetStocksTradesRequest {
    /**
     * Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiGetStocksTrades
     */
    readonly stockTicker: string

    /**
     * Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksTrades
     */
    readonly timestamp?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksTrades
     */
    readonly timestampGte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksTrades
     */
    readonly timestampGt?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksTrades
     */
    readonly timestampLte?: string

    /**
     * Range by timestamp.
     * @type {string}
     * @memberof DefaultApiGetStocksTrades
     */
    readonly timestampLt?: string

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiGetStocksTrades
     */
    readonly order?: GetStocksTradesOrderEnum

    /**
     * Limit the number of results returned, default is 1000 and max is 50000.
     * @type {number}
     * @memberof DefaultApiGetStocksTrades
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'timestamp'}
     * @memberof DefaultApiGetStocksTrades
     */
    readonly sort?: GetStocksTradesSortEnum
}

/**
 * Request parameters for getStocksV1Dividends operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksV1DividendsRequest
 */
export interface DefaultApiGetStocksV1DividendsRequest {
    /**
     * Stock symbol for the company issuing the dividend
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly ticker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly tickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly tickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly tickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly tickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly tickerLte?: string

    /**
     * Date when the stock begins trading without the dividend value Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly exDividendDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly exDividendDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly exDividendDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly exDividendDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly exDividendDateLte?: string

    /**
     * How many times per year this dividend is expected to occur. A value of 0 means the distribution is non-recurring or irregular (e.g., special, supplemental, or a one-off dividend). Other possible values include 1 (annual), 2 (semi-annual), 3 (trimester), 4 (quarterly), 12 (monthly), 24 (bi-monthly), 26 (bi-weekly), 52 (weekly), and 365 (daily) depending on the issuer\&#39;s declared or inferred payout cadence. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly frequency?: number

    /**
     * Filter greater than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly frequencyGt?: number

    /**
     * Filter greater than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly frequencyGte?: number

    /**
     * Filter less than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly frequencyLt?: number

    /**
     * Filter less than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly frequencyLte?: number

    /**
     * Classification describing the nature of this dividend\&#39;s recurrence pattern: recurring (paid on a regular schedule), special (one-time or commemorative), supplemental (extra beyond the regular schedule), irregular (unpredictable or non-recurring), unknown (cannot be classified from available data)
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly distributionType?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly distributionTypeAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly distributionTypeGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly distributionTypeGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly distributionTypeLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly distributionTypeLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Dividends
     */
    readonly sort?: string
}

/**
 * Request parameters for getStocksV1Exchanges operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksV1ExchangesRequest
 */
export interface DefaultApiGetStocksV1ExchangesRequest {
    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;999\&#39;.
     * @type {number}
     * @memberof DefaultApiGetStocksV1Exchanges
     */
    readonly limit?: number
}

/**
 * Request parameters for getStocksV1ShortInterest operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksV1ShortInterestRequest
 */
export interface DefaultApiGetStocksV1ShortInterestRequest {
    /**
     * The primary ticker symbol for the stock.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly ticker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly tickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly tickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly tickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly tickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly tickerLte?: string

    /**
     * Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly daysToCover?: number

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly daysToCoverAnyOf?: string

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly daysToCoverGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly daysToCoverGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly daysToCoverLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly daysToCoverLte?: number

    /**
     * The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly settlementDate?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly settlementDateAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly settlementDateGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly settlementDateGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly settlementDateLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly settlementDateLte?: string

    /**
     * The average daily trading volume for the stock over a specified period, typically used to contextualize short interest. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly avgDailyVolume?: number

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly avgDailyVolumeAnyOf?: string

    /**
     * Filter greater than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly avgDailyVolumeGt?: number

    /**
     * Filter greater than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly avgDailyVolumeGte?: number

    /**
     * Filter less than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly avgDailyVolumeLt?: number

    /**
     * Filter less than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly avgDailyVolumeLte?: number

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;10\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortInterest
     */
    readonly sort?: string
}

/**
 * Request parameters for getStocksV1ShortVolume operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksV1ShortVolumeRequest
 */
export interface DefaultApiGetStocksV1ShortVolumeRequest {
    /**
     * The primary ticker symbol for the stock.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly ticker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly tickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly tickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly tickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly tickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly tickerLte?: string

    /**
     * The date of trade activity reported in the format YYYY-MM-DD
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly date?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly dateAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly dateGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly dateGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly dateLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly dateLte?: string

    /**
     * The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly shortVolumeRatio?: number

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly shortVolumeRatioAnyOf?: string

    /**
     * Filter greater than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly shortVolumeRatioGt?: number

    /**
     * Filter greater than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly shortVolumeRatioGte?: number

    /**
     * Filter less than the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly shortVolumeRatioLt?: number

    /**
     * Filter less than or equal to the value. Value must be a floating point number.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly shortVolumeRatioLte?: number

    /**
     * Total reported volume across all venues for the ticker on the given date. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly totalVolume?: number

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly totalVolumeAnyOf?: string

    /**
     * Filter greater than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly totalVolumeGt?: number

    /**
     * Filter greater than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly totalVolumeGte?: number

    /**
     * Filter less than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly totalVolumeLt?: number

    /**
     * Filter less than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly totalVolumeLte?: number

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;10\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;ticker\&#39; if not specified. The sort order defaults to \&#39;asc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetStocksV1ShortVolume
     */
    readonly sort?: string
}

/**
 * Request parameters for getStocksV1Splits operation in DefaultApi.
 * @export
 * @interface DefaultApiGetStocksV1SplitsRequest
 */
export interface DefaultApiGetStocksV1SplitsRequest {
    /**
     * Stock symbol for the company that executed the split
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly ticker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly tickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly tickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly tickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly tickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly tickerLte?: string

    /**
     * Date when the stock split was applied and shares adjusted Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly executionDate?: string

    /**
     * Filter greater than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly executionDateGt?: string

    /**
     * Filter greater than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly executionDateGte?: string

    /**
     * Filter less than the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly executionDateLt?: string

    /**
     * Filter less than or equal to the value. Value must be formatted \&#39;yyyy-mm-dd\&#39;.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly executionDateLte?: string

    /**
     * Classification of the share-change event. Possible values include: forward_split (share count increases), reverse_split (share count decreases), stock_dividend (shares issued as a dividend)
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly adjustmentType?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly adjustmentTypeAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly adjustmentTypeGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly adjustmentTypeGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly adjustmentTypeLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly adjustmentTypeLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;5000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;execution_date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetStocksV1Splits
     */
    readonly sort?: string
}

/**
 * Request parameters for getTicker operation in DefaultApi.
 * @export
 * @interface DefaultApiGetTickerRequest
 */
export interface DefaultApiGetTickerRequest {
    /**
     * Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiGetTicker
     */
    readonly ticker: string

    /**
     * Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date.
     * @type {string}
     * @memberof DefaultApiGetTicker
     */
    readonly date?: string
}

/**
 * Request parameters for getTmxV1CorporateEvents operation in DefaultApi.
 * @export
 * @interface DefaultApiGetTmxV1CorporateEventsRequest
 */
export interface DefaultApiGetTmxV1CorporateEventsRequest {
    /**
     * Scheduled date of the corporate event, formatted as YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly date?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly dateAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly dateGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly dateGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly dateLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly dateLte?: string

    /**
     * The normalized type of corporate event. Possible values include: analyst_day, business_update, capital_markets_day, conference, dividend, earnings_announcement_date, earnings_conference_call, earnings_results_announcement, forum, interim_statement, other_interim_announcement, production_update, research_and_development_day, seminar, shareholder_meeting, sales_update, stock_split, summit, service_level_update, tradeshow, company_travel, and workshop.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly type?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly typeAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly typeGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly typeGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly typeLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly typeLte?: string

    /**
     * The current status of the event. Possible values include: approved, canceled, confirmed, historical, pending_approval, postponed, and unconfirmed.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly status?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly statusAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly statusGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly statusGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly statusLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly statusLte?: string

    /**
     * The company\&#39;s stock symbol.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly ticker?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tickerAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tickerGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tickerGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tickerLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tickerLte?: string

    /**
     * Standard international identifier for the company\&#39;s common stock.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly isin?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly isinAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly isinGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly isinGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly isinLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly isinLte?: string

    /**
     * MIC (Market Identifier Code) of the exchange where the company\&#39;s stock is listed.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tradingVenue?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tradingVenueAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tradingVenueGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tradingVenueGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tradingVenueLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tradingVenueLte?: string

    /**
     * Unique numeric identifier for the company used by TMX. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tmxCompanyId?: number

    /**
     * Filter greater than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tmxCompanyIdGt?: number

    /**
     * Filter greater than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tmxCompanyIdGte?: number

    /**
     * Filter less than the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tmxCompanyIdLt?: number

    /**
     * Filter less than or equal to the value. Value must be an integer.
     * @type {number}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tmxCompanyIdLte?: number

    /**
     * The unique alphanumeric identifier for the event record used by TMX.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tmxRecordId?: string

    /**
     * Filter equal to any of the values. Multiple values can be specified by using a comma separated list.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tmxRecordIdAnyOf?: string

    /**
     * Filter greater than the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tmxRecordIdGt?: string

    /**
     * Filter greater than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tmxRecordIdGte?: string

    /**
     * Filter less than the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tmxRecordIdLt?: string

    /**
     * Filter less than or equal to the value.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly tmxRecordIdLte?: string

    /**
     * Limit the maximum number of results returned. Defaults to \&#39;100\&#39; if not specified. The maximum allowed limit is \&#39;50000\&#39;.
     * @type {number}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly limit?: number

    /**
     * A comma separated list of sort columns. For each column, append \&#39;.asc\&#39; or \&#39;.desc\&#39; to specify the sort direction. The sort column defaults to \&#39;date\&#39; if not specified. The sort order defaults to \&#39;desc\&#39; if not specified.
     * @type {string}
     * @memberof DefaultApiGetTmxV1CorporateEvents
     */
    readonly sort?: string
}

/**
 * Request parameters for listConditions operation in DefaultApi.
 * @export
 * @interface DefaultApiListConditionsRequest
 */
export interface DefaultApiListConditionsRequest {
    /**
     * Filter for conditions within a given asset class.
     * @type {'stocks' | 'options' | 'crypto' | 'fx'}
     * @memberof DefaultApiListConditions
     */
    readonly assetClass?: ListConditionsAssetClassEnum

    /**
     * Filter by data type.
     * @type {'trade' | 'bbo' | 'nbbo'}
     * @memberof DefaultApiListConditions
     */
    readonly dataType?: ListConditionsDataTypeEnum

    /**
     * Filter for conditions with a given ID.
     * @type {number}
     * @memberof DefaultApiListConditions
     */
    readonly id?: number

    /**
     * Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned.
     * @type {'CTA' | 'UTP' | 'OPRA'}
     * @memberof DefaultApiListConditions
     */
    readonly sip?: ListConditionsSipEnum

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiListConditions
     */
    readonly order?: ListConditionsOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 1000.
     * @type {number}
     * @memberof DefaultApiListConditions
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'asset_class' | 'id' | 'type' | 'name' | 'data_types' | 'legacy'}
     * @memberof DefaultApiListConditions
     */
    readonly sort?: ListConditionsSortEnum
}

/**
 * Request parameters for listDividends operation in DefaultApi.
 * @export
 * @interface DefaultApiListDividendsRequest
 */
export interface DefaultApiListDividendsRequest {
    /**
     * Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly ticker?: string

    /**
     * Query by ex-dividend date with the format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly exDividendDate?: string

    /**
     * Query by record date with the format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly recordDate?: string

    /**
     * Query by declaration date with the format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly declarationDate?: string

    /**
     * Query by pay date with the format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly payDate?: string

    /**
     * Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly).
     * @type {0 | 1 | 2 | 4 | 12 | 24 | 52}
     * @memberof DefaultApiListDividends
     */
    readonly frequency?: ListDividendsFrequencyEnum

    /**
     * Query by the cash amount of the dividend.
     * @type {number}
     * @memberof DefaultApiListDividends
     */
    readonly cashAmount?: number

    /**
     * Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.
     * @type {'CD' | 'SC' | 'LT' | 'ST'}
     * @memberof DefaultApiListDividends
     */
    readonly dividendType?: ListDividendsDividendTypeEnum

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly tickerGte?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly tickerGt?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly tickerLte?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly tickerLt?: string

    /**
     * Range by ex_dividend_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly exDividendDateGte?: string

    /**
     * Range by ex_dividend_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly exDividendDateGt?: string

    /**
     * Range by ex_dividend_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly exDividendDateLte?: string

    /**
     * Range by ex_dividend_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly exDividendDateLt?: string

    /**
     * Range by record_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly recordDateGte?: string

    /**
     * Range by record_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly recordDateGt?: string

    /**
     * Range by record_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly recordDateLte?: string

    /**
     * Range by record_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly recordDateLt?: string

    /**
     * Range by declaration_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly declarationDateGte?: string

    /**
     * Range by declaration_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly declarationDateGt?: string

    /**
     * Range by declaration_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly declarationDateLte?: string

    /**
     * Range by declaration_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly declarationDateLt?: string

    /**
     * Range by pay_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly payDateGte?: string

    /**
     * Range by pay_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly payDateGt?: string

    /**
     * Range by pay_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly payDateLte?: string

    /**
     * Range by pay_date.
     * @type {string}
     * @memberof DefaultApiListDividends
     */
    readonly payDateLt?: string

    /**
     * Range by cash_amount.
     * @type {number}
     * @memberof DefaultApiListDividends
     */
    readonly cashAmountGte?: number

    /**
     * Range by cash_amount.
     * @type {number}
     * @memberof DefaultApiListDividends
     */
    readonly cashAmountGt?: number

    /**
     * Range by cash_amount.
     * @type {number}
     * @memberof DefaultApiListDividends
     */
    readonly cashAmountLte?: number

    /**
     * Range by cash_amount.
     * @type {number}
     * @memberof DefaultApiListDividends
     */
    readonly cashAmountLt?: number

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiListDividends
     */
    readonly order?: ListDividendsOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 1000.
     * @type {number}
     * @memberof DefaultApiListDividends
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'ex_dividend_date' | 'pay_date' | 'declaration_date' | 'record_date' | 'cash_amount' | 'ticker'}
     * @memberof DefaultApiListDividends
     */
    readonly sort?: ListDividendsSortEnum
}

/**
 * Request parameters for listExchanges operation in DefaultApi.
 * @export
 * @interface DefaultApiListExchangesRequest
 */
export interface DefaultApiListExchangesRequest {
    /**
     * Filter by asset class.
     * @type {'stocks' | 'options' | 'crypto' | 'fx' | 'futures'}
     * @memberof DefaultApiListExchanges
     */
    readonly assetClass?: ListExchangesAssetClassEnum

    /**
     * Filter by locale.
     * @type {'us' | 'global'}
     * @memberof DefaultApiListExchanges
     */
    readonly locale?: ListExchangesLocaleEnum
}

/**
 * Request parameters for listFinancials operation in DefaultApi.
 * @export
 * @interface DefaultApiListFinancialsRequest
 */
export interface DefaultApiListFinancialsRequest {
    /**
     * Query by company ticker.
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly ticker?: string

    /**
     * Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly cik?: string

    /**
     * Query by company name.
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly companyName?: string

    /**
     * Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;)
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly sic?: string

    /**
     * Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly filingDate?: string

    /**
     * The period of report for the filing with financials data in YYYY-MM-DD format.
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly periodOfReportDate?: string

    /**
     * Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4
     * @type {'annual' | 'quarterly' | 'ttm'}
     * @memberof DefaultApiListFinancials
     */
    readonly timeframe?: ListFinancialsTimeframeEnum

    /**
     * Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default.
     * @type {boolean}
     * @memberof DefaultApiListFinancials
     */
    readonly includeSources?: boolean

    /**
     * Search by company_name.
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly companyNameSearch?: string

    /**
     * Search by filing_date.
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly filingDateGte?: string

    /**
     * Search by filing_date.
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly filingDateGt?: string

    /**
     * Search by filing_date.
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly filingDateLte?: string

    /**
     * Search by filing_date.
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly filingDateLt?: string

    /**
     * Search by period_of_report_date.
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly periodOfReportDateGte?: string

    /**
     * Search by period_of_report_date.
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly periodOfReportDateGt?: string

    /**
     * Search by period_of_report_date.
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly periodOfReportDateLte?: string

    /**
     * Search by period_of_report_date.
     * @type {string}
     * @memberof DefaultApiListFinancials
     */
    readonly periodOfReportDateLt?: string

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiListFinancials
     */
    readonly order?: ListFinancialsOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 100.
     * @type {number}
     * @memberof DefaultApiListFinancials
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'filing_date' | 'period_of_report_date'}
     * @memberof DefaultApiListFinancials
     */
    readonly sort?: ListFinancialsSortEnum
}

/**
 * Request parameters for listIPOs operation in DefaultApi.
 * @export
 * @interface DefaultApiListIPOsRequest
 */
export interface DefaultApiListIPOsRequest {
    /**
     * Specify a case-sensitive ticker symbol. For example, TSLA represents Tesla Inc.
     * @type {string}
     * @memberof DefaultApiListIPOs
     */
    readonly ticker?: string

    /**
     * Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
     * @type {string}
     * @memberof DefaultApiListIPOs
     */
    readonly usCode?: string

    /**
     * Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world.
     * @type {string}
     * @memberof DefaultApiListIPOs
     */
    readonly isin?: string

    /**
     * Specify a listing date. This is the first trading date for the newly listed entity.
     * @type {string}
     * @memberof DefaultApiListIPOs
     */
    readonly listingDate?: string

    /**
     * Specify an IPO status.
     * @type {'direct_listing_process' | 'history' | 'new' | 'pending' | 'postponed' | 'rumor' | 'withdrawn'}
     * @memberof DefaultApiListIPOs
     */
    readonly ipoStatus?: ListIPOsIpoStatusEnum

    /**
     * Range by listing_date.
     * @type {string}
     * @memberof DefaultApiListIPOs
     */
    readonly listingDateGte?: string

    /**
     * Range by listing_date.
     * @type {string}
     * @memberof DefaultApiListIPOs
     */
    readonly listingDateGt?: string

    /**
     * Range by listing_date.
     * @type {string}
     * @memberof DefaultApiListIPOs
     */
    readonly listingDateLte?: string

    /**
     * Range by listing_date.
     * @type {string}
     * @memberof DefaultApiListIPOs
     */
    readonly listingDateLt?: string

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiListIPOs
     */
    readonly order?: ListIPOsOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 1000.
     * @type {number}
     * @memberof DefaultApiListIPOs
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'listing_date' | 'ticker' | 'last_updated' | 'security_type' | 'issuer_name' | 'currency_code' | 'isin' | 'us_code' | 'final_issue_price' | 'min_shares_offered' | 'max_shares_offered' | 'lowest_offer_price' | 'highest_offer_price' | 'total_offer_size' | 'shares_outstanding' | 'primary_exchange' | 'lot_size' | 'security_description' | 'ipo_status' | 'announced_date'}
     * @memberof DefaultApiListIPOs
     */
    readonly sort?: ListIPOsSortEnum
}

/**
 * Request parameters for listNews operation in DefaultApi.
 * @export
 * @interface DefaultApiListNewsRequest
 */
export interface DefaultApiListNewsRequest {
    /**
     * Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiListNews
     */
    readonly ticker?: string

    /**
     * Return results published on, before, or after this date.
     * @type {ListNewsPublishedUtcParameter}
     * @memberof DefaultApiListNews
     */
    readonly publishedUtc?: ListNewsPublishedUtcParameter

    /**
     * Search by ticker.
     * @type {string}
     * @memberof DefaultApiListNews
     */
    readonly tickerGte?: string

    /**
     * Search by ticker.
     * @type {string}
     * @memberof DefaultApiListNews
     */
    readonly tickerGt?: string

    /**
     * Search by ticker.
     * @type {string}
     * @memberof DefaultApiListNews
     */
    readonly tickerLte?: string

    /**
     * Search by ticker.
     * @type {string}
     * @memberof DefaultApiListNews
     */
    readonly tickerLt?: string

    /**
     * Search by published_utc.
     * @type {ListNewsPublishedUtcParameter}
     * @memberof DefaultApiListNews
     */
    readonly publishedUtcGte?: ListNewsPublishedUtcParameter

    /**
     * Search by published_utc.
     * @type {ListNewsPublishedUtcParameter}
     * @memberof DefaultApiListNews
     */
    readonly publishedUtcGt?: ListNewsPublishedUtcParameter

    /**
     * Search by published_utc.
     * @type {ListNewsPublishedUtcParameter}
     * @memberof DefaultApiListNews
     */
    readonly publishedUtcLte?: ListNewsPublishedUtcParameter

    /**
     * Search by published_utc.
     * @type {ListNewsPublishedUtcParameter}
     * @memberof DefaultApiListNews
     */
    readonly publishedUtcLt?: ListNewsPublishedUtcParameter

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiListNews
     */
    readonly order?: ListNewsOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 1000.
     * @type {number}
     * @memberof DefaultApiListNews
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'published_utc'}
     * @memberof DefaultApiListNews
     */
    readonly sort?: ListNewsSortEnum
}

/**
 * Request parameters for listOptionsContracts operation in DefaultApi.
 * @export
 * @interface DefaultApiListOptionsContractsRequest
 */
export interface DefaultApiListOptionsContractsRequest {
    /**
     * Query for contracts relating to an underlying stock ticker.
     * @type {string}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly underlyingTicker?: string

    /**
     * This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://massive.com/docs/rest/options/contracts/contract-overview).
     * @type {string}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly ticker?: string

    /**
     * Query by the type of contract.
     * @type {'call' | 'put'}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly contractType?: ListOptionsContractsContractTypeEnum

    /**
     * Query by contract expiration with date format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly expirationDate?: string

    /**
     * Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today\&#39;s date.
     * @type {string}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly asOf?: string

    /**
     * Query by strike price of a contract.
     * @type {number}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly strikePrice?: number

    /**
     * Query for expired contracts. Default is false.
     * @type {boolean}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly expired?: boolean

    /**
     * Range by underlying_ticker.
     * @type {string}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly underlyingTickerGte?: string

    /**
     * Range by underlying_ticker.
     * @type {string}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly underlyingTickerGt?: string

    /**
     * Range by underlying_ticker.
     * @type {string}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly underlyingTickerLte?: string

    /**
     * Range by underlying_ticker.
     * @type {string}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly underlyingTickerLt?: string

    /**
     * Range by expiration_date.
     * @type {string}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly expirationDateGte?: string

    /**
     * Range by expiration_date.
     * @type {string}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly expirationDateGt?: string

    /**
     * Range by expiration_date.
     * @type {string}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly expirationDateLte?: string

    /**
     * Range by expiration_date.
     * @type {string}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly expirationDateLt?: string

    /**
     * Range by strike_price.
     * @type {number}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly strikePriceGte?: number

    /**
     * Range by strike_price.
     * @type {number}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly strikePriceGt?: number

    /**
     * Range by strike_price.
     * @type {number}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly strikePriceLte?: number

    /**
     * Range by strike_price.
     * @type {number}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly strikePriceLt?: number

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly order?: ListOptionsContractsOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 1000.
     * @type {number}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'ticker' | 'underlying_ticker' | 'expiration_date' | 'strike_price'}
     * @memberof DefaultApiListOptionsContracts
     */
    readonly sort?: ListOptionsContractsSortEnum
}

/**
 * Request parameters for listStockSplits operation in DefaultApi.
 * @export
 * @interface DefaultApiListStockSplitsRequest
 */
export interface DefaultApiListStockSplitsRequest {
    /**
     * Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @type {string}
     * @memberof DefaultApiListStockSplits
     */
    readonly ticker?: string

    /**
     * Query by execution date with the format YYYY-MM-DD.
     * @type {string}
     * @memberof DefaultApiListStockSplits
     */
    readonly executionDate?: string

    /**
     * Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used.
     * @type {boolean}
     * @memberof DefaultApiListStockSplits
     */
    readonly reverseSplit?: boolean | null

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiListStockSplits
     */
    readonly tickerGte?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiListStockSplits
     */
    readonly tickerGt?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiListStockSplits
     */
    readonly tickerLte?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiListStockSplits
     */
    readonly tickerLt?: string

    /**
     * Range by execution_date.
     * @type {string}
     * @memberof DefaultApiListStockSplits
     */
    readonly executionDateGte?: string

    /**
     * Range by execution_date.
     * @type {string}
     * @memberof DefaultApiListStockSplits
     */
    readonly executionDateGt?: string

    /**
     * Range by execution_date.
     * @type {string}
     * @memberof DefaultApiListStockSplits
     */
    readonly executionDateLte?: string

    /**
     * Range by execution_date.
     * @type {string}
     * @memberof DefaultApiListStockSplits
     */
    readonly executionDateLt?: string

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiListStockSplits
     */
    readonly order?: ListStockSplitsOrderEnum

    /**
     * Limit the number of results returned, default is 10 and max is 1000.
     * @type {number}
     * @memberof DefaultApiListStockSplits
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'execution_date' | 'ticker'}
     * @memberof DefaultApiListStockSplits
     */
    readonly sort?: ListStockSplitsSortEnum
}

/**
 * Request parameters for listTickerTypes operation in DefaultApi.
 * @export
 * @interface DefaultApiListTickerTypesRequest
 */
export interface DefaultApiListTickerTypesRequest {
    /**
     * Filter by asset class.
     * @type {'stocks' | 'options' | 'crypto' | 'fx' | 'indices'}
     * @memberof DefaultApiListTickerTypes
     */
    readonly assetClass?: ListTickerTypesAssetClassEnum

    /**
     * Filter by locale.
     * @type {'us' | 'global'}
     * @memberof DefaultApiListTickerTypes
     */
    readonly locale?: ListTickerTypesLocaleEnum
}

/**
 * Request parameters for listTickers operation in DefaultApi.
 * @export
 * @interface DefaultApiListTickersRequest
 */
export interface DefaultApiListTickersRequest {
    /**
     * Specify a ticker symbol. Defaults to empty string which queries all tickers.
     * @type {string}
     * @memberof DefaultApiListTickers
     */
    readonly ticker?: string

    /**
     * Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://massive.com/docs/rest/stocks/tickers/ticker-types). Defaults to empty string which queries all types.
     * @type {'CS' | 'ADRC' | 'ADRP' | 'ADRR' | 'UNIT' | 'RIGHT' | 'PFD' | 'FUND' | 'SP' | 'WARRANT' | 'INDEX' | 'ETF' | 'ETN' | 'OS' | 'GDR' | 'OTHER' | 'NYRS' | 'AGEN' | 'EQLK' | 'BOND' | 'ADRW' | 'BASKET' | 'LT'}
     * @memberof DefaultApiListTickers
     */
    readonly type?: ListTickersTypeEnum

    /**
     * Filter by market type. By default all markets are included.
     * @type {'stocks' | 'crypto' | 'fx' | 'otc' | 'indices'}
     * @memberof DefaultApiListTickers
     */
    readonly market?: ListTickersMarketEnum

    /**
     * Specify the asset\&#39;s primary exchange Market Identifier Code (MIC) according to [ISO 10383](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges.
     * @type {string}
     * @memberof DefaultApiListTickers
     */
    readonly exchange?: string

    /**
     * Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
     * @type {string}
     * @memberof DefaultApiListTickers
     */
    readonly cusip?: string

    /**
     * Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs.
     * @type {string}
     * @memberof DefaultApiListTickers
     */
    readonly cik?: string

    /**
     * Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date.
     * @type {string}
     * @memberof DefaultApiListTickers
     */
    readonly date?: string

    /**
     * Search for terms within the ticker and/or company name.
     * @type {string}
     * @memberof DefaultApiListTickers
     */
    readonly search?: string

    /**
     * Specify if the tickers returned should be actively traded on the queried date. Default is true.
     * @type {boolean}
     * @memberof DefaultApiListTickers
     */
    readonly active?: boolean

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiListTickers
     */
    readonly tickerGte?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiListTickers
     */
    readonly tickerGt?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiListTickers
     */
    readonly tickerLte?: string

    /**
     * Range by ticker.
     * @type {string}
     * @memberof DefaultApiListTickers
     */
    readonly tickerLt?: string

    /**
     * Order results based on the &#x60;sort&#x60; field.
     * @type {'asc' | 'desc'}
     * @memberof DefaultApiListTickers
     */
    readonly order?: ListTickersOrderEnum

    /**
     * Limit the number of results returned, default is 100 and max is 1000.
     * @type {number}
     * @memberof DefaultApiListTickers
     */
    readonly limit?: number

    /**
     * Sort field used for ordering.
     * @type {'ticker' | 'name' | 'market' | 'locale' | 'primary_exchange' | 'type' | 'currency_symbol' | 'currency_name' | 'base_currency_symbol' | 'base_currency_name' | 'cik' | 'composite_figi' | 'share_class_figi' | 'last_updated_utc' | 'delisted_utc'}
     * @memberof DefaultApiListTickers
     */
    readonly sort?: ListTickersSortEnum
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Ticker Full Book (L2)
     * @param {DefaultApiDeprecatedGetCryptoSnapshotTickerBookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deprecatedGetCryptoSnapshotTickerBook(requestParameters: DefaultApiDeprecatedGetCryptoSnapshotTickerBookRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deprecatedGetCryptoSnapshotTickerBook(requestParameters.ticker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get historic trade ticks for a cryptocurrency pair. 
     * @summary Historic Crypto Trades
     * @param {DefaultApiDeprecatedGetHistoricCryptoTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deprecatedGetHistoricCryptoTrades(requestParameters: DefaultApiDeprecatedGetHistoricCryptoTradesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deprecatedGetHistoricCryptoTrades(requestParameters.from, requestParameters.to, requestParameters.date, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get historic ticks for a forex currency pair. 
     * @summary Historic Forex Ticks
     * @param {DefaultApiDeprecatedGetHistoricForexQuotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deprecatedGetHistoricForexQuotes(requestParameters: DefaultApiDeprecatedGetHistoricForexQuotesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deprecatedGetHistoricForexQuotes(requestParameters.from, requestParameters.to, requestParameters.date, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get NBBO quotes for a given ticker symbol on a specified date. 
     * @summary Quotes (NBBO)
     * @param {DefaultApiDeprecatedGetHistoricStocksQuotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deprecatedGetHistoricStocksQuotes(requestParameters: DefaultApiDeprecatedGetHistoricStocksQuotesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deprecatedGetHistoricStocksQuotes(requestParameters.ticker, requestParameters.date, requestParameters.timestamp, requestParameters.timestampLimit, requestParameters.reverse, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a given ticker symbol on a specified date. 
     * @summary Trades
     * @param {DefaultApiDeprecatedGetHistoricStocksTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deprecatedGetHistoricStocksTrades(requestParameters: DefaultApiDeprecatedGetHistoricStocksTradesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deprecatedGetHistoricStocksTrades(requestParameters.ticker, requestParameters.date, requestParameters.timestamp, requestParameters.timestampLimit, requestParameters.reverse, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A comprehensive database of financial analyst insights and ratings for various publicly traded companies, capturing detailed information about analyst recommendations and price targets.
     * @param {DefaultApiGetBenzingaV1AnalystInsightsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1AnalystInsights(requestParameters: DefaultApiGetBenzingaV1AnalystInsightsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1AnalystInsights(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGt, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLt, requestParameters.lastUpdatedLte, requestParameters.firm, requestParameters.firmAnyOf, requestParameters.firmGt, requestParameters.firmGte, requestParameters.firmLt, requestParameters.firmLte, requestParameters.ratingAction, requestParameters.ratingActionAnyOf, requestParameters.ratingActionGt, requestParameters.ratingActionGte, requestParameters.ratingActionLt, requestParameters.ratingActionLte, requestParameters.benzingaFirmId, requestParameters.benzingaFirmIdAnyOf, requestParameters.benzingaFirmIdGt, requestParameters.benzingaFirmIdGte, requestParameters.benzingaFirmIdLt, requestParameters.benzingaFirmIdLte, requestParameters.benzingaRatingId, requestParameters.benzingaRatingIdAnyOf, requestParameters.benzingaRatingIdGt, requestParameters.benzingaRatingIdGte, requestParameters.benzingaRatingIdLt, requestParameters.benzingaRatingIdLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A comprehensive database of financial analysts, containing detailed performance metrics and identification information for individual analysts across various financial firms.
     * @param {DefaultApiGetBenzingaV1AnalystsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1Analysts(requestParameters: DefaultApiGetBenzingaV1AnalystsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1Analysts(requestParameters.benzingaId, requestParameters.benzingaIdAnyOf, requestParameters.benzingaIdGt, requestParameters.benzingaIdGte, requestParameters.benzingaIdLt, requestParameters.benzingaIdLte, requestParameters.benzingaFirmId, requestParameters.benzingaFirmIdAnyOf, requestParameters.benzingaFirmIdGt, requestParameters.benzingaFirmIdGte, requestParameters.benzingaFirmIdLt, requestParameters.benzingaFirmIdLte, requestParameters.firmName, requestParameters.firmNameAnyOf, requestParameters.firmNameGt, requestParameters.firmNameGte, requestParameters.firmNameLt, requestParameters.firmNameLte, requestParameters.fullName, requestParameters.fullNameAnyOf, requestParameters.fullNameGt, requestParameters.fullNameGte, requestParameters.fullNameLt, requestParameters.fullNameLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A comprehensive financial consensus ratings table that aggregates analyst recommendations and price targets for individual stock tickers, capturing detailed rating breakdowns and statistical insights.
     * @param {DefaultApiGetBenzingaV1ConsensusRatingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1ConsensusRatings(requestParameters: DefaultApiGetBenzingaV1ConsensusRatingsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1ConsensusRatings(requestParameters.ticker, requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This table contains earnings data from Benzinga, tracking both actual and estimated financial metrics for publicly traded companies. It includes EPS and revenue figures with surprise calculations, along with metadata like fiscal periods, company identifiers, and reporting timestamps.
     * @param {DefaultApiGetBenzingaV1EarningsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1Earnings(requestParameters: DefaultApiGetBenzingaV1EarningsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1Earnings(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.importance, requestParameters.importanceAnyOf, requestParameters.importanceGt, requestParameters.importanceGte, requestParameters.importanceLt, requestParameters.importanceLte, requestParameters.lastUpdated, requestParameters.lastUpdatedAnyOf, requestParameters.lastUpdatedGt, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLt, requestParameters.lastUpdatedLte, requestParameters.dateStatus, requestParameters.dateStatusAnyOf, requestParameters.dateStatusGt, requestParameters.dateStatusGte, requestParameters.dateStatusLt, requestParameters.dateStatusLte, requestParameters.epsSurprisePercent, requestParameters.epsSurprisePercentAnyOf, requestParameters.epsSurprisePercentGt, requestParameters.epsSurprisePercentGte, requestParameters.epsSurprisePercentLt, requestParameters.epsSurprisePercentLte, requestParameters.revenueSurprisePercent, requestParameters.revenueSurprisePercentAnyOf, requestParameters.revenueSurprisePercentGt, requestParameters.revenueSurprisePercentGte, requestParameters.revenueSurprisePercentLt, requestParameters.revenueSurprisePercentLte, requestParameters.fiscalYear, requestParameters.fiscalYearAnyOf, requestParameters.fiscalYearGt, requestParameters.fiscalYearGte, requestParameters.fiscalYearLt, requestParameters.fiscalYearLte, requestParameters.fiscalPeriod, requestParameters.fiscalPeriodAnyOf, requestParameters.fiscalPeriodGt, requestParameters.fiscalPeriodGte, requestParameters.fiscalPeriodLt, requestParameters.fiscalPeriodLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A comprehensive database of financial firms, tracking unique identifiers, names, and basic metadata for various financial institutions and research firms.
     * @param {DefaultApiGetBenzingaV1FirmsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1Firms(requestParameters: DefaultApiGetBenzingaV1FirmsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1Firms(requestParameters.benzingaId, requestParameters.benzingaIdAnyOf, requestParameters.benzingaIdGt, requestParameters.benzingaIdGte, requestParameters.benzingaIdLt, requestParameters.benzingaIdLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A comprehensive database of financial guidance and earnings estimates for various companies, capturing key metrics related to earnings per share (EPS) and revenue projections across different fiscal periods.
     * @param {DefaultApiGetBenzingaV1GuidanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1Guidance(requestParameters: DefaultApiGetBenzingaV1GuidanceRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1Guidance(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.positioning, requestParameters.positioningAnyOf, requestParameters.positioningGt, requestParameters.positioningGte, requestParameters.positioningLt, requestParameters.positioningLte, requestParameters.importance, requestParameters.importanceAnyOf, requestParameters.importanceGt, requestParameters.importanceGte, requestParameters.importanceLt, requestParameters.importanceLte, requestParameters.lastUpdated, requestParameters.lastUpdatedAnyOf, requestParameters.lastUpdatedGt, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLt, requestParameters.lastUpdatedLte, requestParameters.fiscalYear, requestParameters.fiscalYearAnyOf, requestParameters.fiscalYearGt, requestParameters.fiscalYearGte, requestParameters.fiscalYearLt, requestParameters.fiscalYearLte, requestParameters.fiscalPeriod, requestParameters.fiscalPeriodAnyOf, requestParameters.fiscalPeriodGt, requestParameters.fiscalPeriodGte, requestParameters.fiscalPeriodLt, requestParameters.fiscalPeriodLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A comprehensive news article database from Benzinga, containing detailed information about financial news articles including metadata, content, and associated financial information.
     * @param {DefaultApiGetBenzingaV1NewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1News(requestParameters: DefaultApiGetBenzingaV1NewsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1News(requestParameters.published, requestParameters.publishedAnyOf, requestParameters.publishedGt, requestParameters.publishedGte, requestParameters.publishedLt, requestParameters.publishedLte, requestParameters.lastUpdated, requestParameters.lastUpdatedAnyOf, requestParameters.lastUpdatedGt, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLt, requestParameters.lastUpdatedLte, requestParameters.tickers, requestParameters.tickersAllOf, requestParameters.tickersAnyOf, requestParameters.channels, requestParameters.channelsAllOf, requestParameters.channelsAnyOf, requestParameters.tags, requestParameters.tagsAllOf, requestParameters.tagsAnyOf, requestParameters.author, requestParameters.authorAnyOf, requestParameters.authorGt, requestParameters.authorGte, requestParameters.authorLt, requestParameters.authorLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This table contains analyst ratings and price target data from investment firms, tracking rating changes (upgrades, downgrades, initiates coverage, etc.) and price target adjustments for publicly traded companies. Each record includes the analyst details, company information, current and previous ratings/targets, and metadata like timestamps and Benzinga identifiers.
     * @param {DefaultApiGetBenzingaV1RatingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV1Ratings(requestParameters: DefaultApiGetBenzingaV1RatingsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV1Ratings(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.importance, requestParameters.importanceGt, requestParameters.importanceGte, requestParameters.importanceLt, requestParameters.importanceLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGt, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLt, requestParameters.lastUpdatedLte, requestParameters.ratingAction, requestParameters.ratingActionAnyOf, requestParameters.ratingActionGt, requestParameters.ratingActionGte, requestParameters.ratingActionLt, requestParameters.ratingActionLte, requestParameters.priceTargetAction, requestParameters.priceTargetActionAnyOf, requestParameters.priceTargetActionGt, requestParameters.priceTargetActionGte, requestParameters.priceTargetActionLt, requestParameters.priceTargetActionLte, requestParameters.benzingaId, requestParameters.benzingaIdAnyOf, requestParameters.benzingaIdGt, requestParameters.benzingaIdGte, requestParameters.benzingaIdLt, requestParameters.benzingaIdLte, requestParameters.benzingaAnalystId, requestParameters.benzingaAnalystIdAnyOf, requestParameters.benzingaAnalystIdGt, requestParameters.benzingaAnalystIdGte, requestParameters.benzingaAnalystIdLt, requestParameters.benzingaAnalystIdLte, requestParameters.benzingaFirmId, requestParameters.benzingaFirmIdAnyOf, requestParameters.benzingaFirmIdGt, requestParameters.benzingaFirmIdGte, requestParameters.benzingaFirmIdLt, requestParameters.benzingaFirmIdLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A comprehensive news article database from Benzinga, containing detailed information about financial news articles including metadata, content, and associated financial information.
     * @param {DefaultApiGetBenzingaV2NewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBenzingaV2News(requestParameters: DefaultApiGetBenzingaV2NewsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBenzingaV2News(requestParameters.published, requestParameters.publishedGt, requestParameters.publishedGte, requestParameters.publishedLt, requestParameters.publishedLte, requestParameters.channels, requestParameters.channelsAllOf, requestParameters.channelsAnyOf, requestParameters.tags, requestParameters.tagsAllOf, requestParameters.tagsAnyOf, requestParameters.author, requestParameters.authorAnyOf, requestParameters.authorGt, requestParameters.authorGte, requestParameters.authorLt, requestParameters.authorLte, requestParameters.stocks, requestParameters.stocksAllOf, requestParameters.stocksAnyOf, requestParameters.tickers, requestParameters.tickersAllOf, requestParameters.tickersAnyOf, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {DefaultApiGetCryptoAggregatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoAggregates(requestParameters: DefaultApiGetCryptoAggregatesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoAggregates(requestParameters.cryptoTicker, requestParameters.multiplier, requestParameters.timespan, requestParameters.from, requestParameters.to, requestParameters.adjusted, requestParameters.sort, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {DefaultApiGetCryptoEMARequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoEMA(requestParameters: DefaultApiGetCryptoEMARequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoEMA(requestParameters.cryptoTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {DefaultApiGetCryptoMACDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoMACD(requestParameters: DefaultApiGetCryptoMACDRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoMACD(requestParameters.cryptoTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.shortWindow, requestParameters.longWindow, requestParameters.signalWindow, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the open, close prices of a cryptocurrency symbol on a certain day. 
     * @summary Daily Open/Close
     * @param {DefaultApiGetCryptoOpenCloseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoOpenClose(requestParameters: DefaultApiGetCryptoOpenCloseRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoOpenClose(requestParameters.from, requestParameters.to, requestParameters.date, requestParameters.adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {DefaultApiGetCryptoRSIRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoRSI(requestParameters: DefaultApiGetCryptoRSIRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoRSI(requestParameters.cryptoTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {DefaultApiGetCryptoSMARequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoSMA(requestParameters: DefaultApiGetCryptoSMARequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoSMA(requestParameters.cryptoTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current top 20 gainers or losers of the day in cryptocurrency markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Gainers/Losers
     * @param {DefaultApiGetCryptoSnapshotDirectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoSnapshotDirection(requestParameters: DefaultApiGetCryptoSnapshotDirectionRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoSnapshotDirection(requestParameters.direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Ticker
     * @param {DefaultApiGetCryptoSnapshotTickerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoSnapshotTicker(requestParameters: DefaultApiGetCryptoSnapshotTickerRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoSnapshotTicker(requestParameters.ticker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @summary All Tickers
     * @param {DefaultApiGetCryptoSnapshotTickersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoSnapshotTickers(requestParameters: DefaultApiGetCryptoSnapshotTickersRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoSnapshotTickers(requestParameters.tickers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a crypto ticker symbol in a given time range.
     * @summary Trades
     * @param {DefaultApiGetCryptoTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoTrades(requestParameters: DefaultApiGetCryptoTradesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoTrades(requestParameters.cryptoTicker, requestParameters.timestamp, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Global cryptocurrency exchanges and digital asset trading platforms, including major centralized exchanges (Coinbase, Binance, Bitfinex, etc.) that facilitate trading of cryptocurrencies and digital tokens worldwide.
     * @param {DefaultApiGetCryptoV1ExchangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCryptoV1Exchanges(requestParameters: DefaultApiGetCryptoV1ExchangesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCryptoV1Exchanges(requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
     * @summary Real-time Currency Conversion
     * @param {DefaultApiGetCurrencyConversionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCurrencyConversion(requestParameters: DefaultApiGetCurrencyConversionRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCurrencyConversion(requestParameters.from, requestParameters.to, requestParameters.amount, requestParameters.precision, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ETF Global analytics data containing risk scores, reward metrics, and quantitative analysis for ETF composite tickers.
     * @param {DefaultApiGetEtfGlobalV1AnalyticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEtfGlobalV1Analytics(requestParameters: DefaultApiGetEtfGlobalV1AnalyticsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEtfGlobalV1Analytics(requestParameters.compositeTicker, requestParameters.compositeTickerAnyOf, requestParameters.compositeTickerGt, requestParameters.compositeTickerGte, requestParameters.compositeTickerLt, requestParameters.compositeTickerLte, requestParameters.processedDate, requestParameters.processedDateGt, requestParameters.processedDateGte, requestParameters.processedDateLt, requestParameters.processedDateLte, requestParameters.effectiveDate, requestParameters.effectiveDateGt, requestParameters.effectiveDateGte, requestParameters.effectiveDateLt, requestParameters.effectiveDateLte, requestParameters.riskTotalScore, requestParameters.riskTotalScoreGt, requestParameters.riskTotalScoreGte, requestParameters.riskTotalScoreLt, requestParameters.riskTotalScoreLte, requestParameters.rewardScore, requestParameters.rewardScoreGt, requestParameters.rewardScoreGte, requestParameters.rewardScoreLt, requestParameters.rewardScoreLte, requestParameters.quantTotalScore, requestParameters.quantTotalScoreGt, requestParameters.quantTotalScoreGte, requestParameters.quantTotalScoreLt, requestParameters.quantTotalScoreLte, requestParameters.quantGrade, requestParameters.quantGradeAnyOf, requestParameters.quantGradeGt, requestParameters.quantGradeGte, requestParameters.quantGradeLt, requestParameters.quantGradeLte, requestParameters.quantCompositeTechnical, requestParameters.quantCompositeTechnicalGt, requestParameters.quantCompositeTechnicalGte, requestParameters.quantCompositeTechnicalLt, requestParameters.quantCompositeTechnicalLte, requestParameters.quantCompositeSentiment, requestParameters.quantCompositeSentimentGt, requestParameters.quantCompositeSentimentGte, requestParameters.quantCompositeSentimentLt, requestParameters.quantCompositeSentimentLte, requestParameters.quantCompositeBehavioral, requestParameters.quantCompositeBehavioralGt, requestParameters.quantCompositeBehavioralGte, requestParameters.quantCompositeBehavioralLt, requestParameters.quantCompositeBehavioralLte, requestParameters.quantCompositeFundamental, requestParameters.quantCompositeFundamentalGt, requestParameters.quantCompositeFundamentalGte, requestParameters.quantCompositeFundamentalLt, requestParameters.quantCompositeFundamentalLte, requestParameters.quantCompositeGlobal, requestParameters.quantCompositeGlobalGt, requestParameters.quantCompositeGlobalGte, requestParameters.quantCompositeGlobalLt, requestParameters.quantCompositeGlobalLte, requestParameters.quantCompositeQuality, requestParameters.quantCompositeQualityGt, requestParameters.quantCompositeQualityGte, requestParameters.quantCompositeQualityLt, requestParameters.quantCompositeQualityLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ETF Global constituents data containing detailed information about the securities held within ETFs, including weights, market values, and security identifiers.
     * @param {DefaultApiGetEtfGlobalV1ConstituentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEtfGlobalV1Constituents(requestParameters: DefaultApiGetEtfGlobalV1ConstituentsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEtfGlobalV1Constituents(requestParameters.compositeTicker, requestParameters.compositeTickerAnyOf, requestParameters.compositeTickerGt, requestParameters.compositeTickerGte, requestParameters.compositeTickerLt, requestParameters.compositeTickerLte, requestParameters.constituentTicker, requestParameters.constituentTickerAnyOf, requestParameters.constituentTickerGt, requestParameters.constituentTickerGte, requestParameters.constituentTickerLt, requestParameters.constituentTickerLte, requestParameters.effectiveDate, requestParameters.effectiveDateGt, requestParameters.effectiveDateGte, requestParameters.effectiveDateLt, requestParameters.effectiveDateLte, requestParameters.processedDate, requestParameters.processedDateGt, requestParameters.processedDateGte, requestParameters.processedDateLt, requestParameters.processedDateLte, requestParameters.usCode, requestParameters.usCodeAnyOf, requestParameters.usCodeGt, requestParameters.usCodeGte, requestParameters.usCodeLt, requestParameters.usCodeLte, requestParameters.isin, requestParameters.isinAnyOf, requestParameters.isinGt, requestParameters.isinGte, requestParameters.isinLt, requestParameters.isinLte, requestParameters.figi, requestParameters.figiAnyOf, requestParameters.figiGt, requestParameters.figiGte, requestParameters.figiLt, requestParameters.figiLte, requestParameters.sedol, requestParameters.sedolAnyOf, requestParameters.sedolGt, requestParameters.sedolGte, requestParameters.sedolLt, requestParameters.sedolLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ETF Global fund flow data containing information about ETF share movements, net asset values, and fund flow metrics.
     * @param {DefaultApiGetEtfGlobalV1FundFlowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEtfGlobalV1FundFlows(requestParameters: DefaultApiGetEtfGlobalV1FundFlowsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEtfGlobalV1FundFlows(requestParameters.processedDate, requestParameters.processedDateGt, requestParameters.processedDateGte, requestParameters.processedDateLt, requestParameters.processedDateLte, requestParameters.effectiveDate, requestParameters.effectiveDateGt, requestParameters.effectiveDateGte, requestParameters.effectiveDateLt, requestParameters.effectiveDateLte, requestParameters.compositeTicker, requestParameters.compositeTickerAnyOf, requestParameters.compositeTickerGt, requestParameters.compositeTickerGte, requestParameters.compositeTickerLt, requestParameters.compositeTickerLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ETF Global industry profile data containing comprehensive ETF metadata including financial metrics, operational details, and exposure information.
     * @param {DefaultApiGetEtfGlobalV1ProfilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEtfGlobalV1Profiles(requestParameters: DefaultApiGetEtfGlobalV1ProfilesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEtfGlobalV1Profiles(requestParameters.processedDate, requestParameters.processedDateGt, requestParameters.processedDateGte, requestParameters.processedDateLt, requestParameters.processedDateLte, requestParameters.effectiveDate, requestParameters.effectiveDateGt, requestParameters.effectiveDateGte, requestParameters.effectiveDateLt, requestParameters.effectiveDateLte, requestParameters.compositeTicker, requestParameters.compositeTickerAnyOf, requestParameters.compositeTickerGt, requestParameters.compositeTickerGte, requestParameters.compositeTickerLt, requestParameters.compositeTickerLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ETF Global taxonomy data containing detailed classification and categorization information for ETFs including investment strategy, methodology, and structural characteristics.
     * @param {DefaultApiGetEtfGlobalV1TaxonomiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEtfGlobalV1Taxonomies(requestParameters: DefaultApiGetEtfGlobalV1TaxonomiesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEtfGlobalV1Taxonomies(requestParameters.processedDate, requestParameters.processedDateGt, requestParameters.processedDateGte, requestParameters.processedDateLt, requestParameters.processedDateLte, requestParameters.effectiveDate, requestParameters.effectiveDateGt, requestParameters.effectiveDateGte, requestParameters.effectiveDateLt, requestParameters.effectiveDateLte, requestParameters.compositeTicker, requestParameters.compositeTickerAnyOf, requestParameters.compositeTickerGt, requestParameters.compositeTickerGte, requestParameters.compositeTickerLt, requestParameters.compositeTickerLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
     * @summary Ticker Events
     * @param {DefaultApiGetEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEvents(requestParameters: DefaultApiGetEventsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEvents(requestParameters.id, requestParameters.types, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A table tracking inflation and price indices, including Consumer Price Index (CPI) and Personal Consumption Expenditures (PCE) metrics over time.
     * @param {DefaultApiGetFedV1InflationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFedV1Inflation(requestParameters: DefaultApiGetFedV1InflationRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFedV1Inflation(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A table tracking inflation expectations from both market-based and economic model perspectives across different time horizons.
     * @param {DefaultApiGetFedV1InflationExpectationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFedV1InflationExpectations(requestParameters: DefaultApiGetFedV1InflationExpectationsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFedV1InflationExpectations(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A record of U.S. Treasury bond yields across various maturity periods, tracking historical interest rates from short-term to long-term government securities.
     * @param {DefaultApiGetFedV1TreasuryYieldsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFedV1TreasuryYields(requestParameters: DefaultApiGetFedV1TreasuryYieldsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFedV1TreasuryYields(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for a forex pair over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {DefaultApiGetForexAggregatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexAggregates(requestParameters: DefaultApiGetForexAggregatesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexAggregates(requestParameters.forexTicker, requestParameters.multiplier, requestParameters.timespan, requestParameters.from, requestParameters.to, requestParameters.adjusted, requestParameters.sort, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {DefaultApiGetForexEMARequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexEMA(requestParameters: DefaultApiGetForexEMARequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexEMA(requestParameters.fxTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {DefaultApiGetForexMACDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexMACD(requestParameters: DefaultApiGetForexMACDRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexMACD(requestParameters.fxTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.shortWindow, requestParameters.longWindow, requestParameters.signalWindow, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get BBO quotes for a ticker symbol in a given time range.
     * @summary Quotes (BBO)
     * @param {DefaultApiGetForexQuotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexQuotes(requestParameters: DefaultApiGetForexQuotesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexQuotes(requestParameters.fxTicker, requestParameters.timestamp, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {DefaultApiGetForexRSIRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexRSI(requestParameters: DefaultApiGetForexRSIRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexRSI(requestParameters.fxTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {DefaultApiGetForexSMARequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexSMA(requestParameters: DefaultApiGetForexSMARequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexSMA(requestParameters.fxTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current top 20 gainers or losers of the day in forex markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Gainers/Losers
     * @param {DefaultApiGetForexSnapshotDirectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexSnapshotDirection(requestParameters: DefaultApiGetForexSnapshotDirectionRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexSnapshotDirection(requestParameters.direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded currency symbol. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @summary Ticker
     * @param {DefaultApiGetForexSnapshotTickerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexSnapshotTicker(requestParameters: DefaultApiGetForexSnapshotTickerRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexSnapshotTicker(requestParameters.ticker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded forex symbols. <br /> <br /> Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @summary All Tickers
     * @param {DefaultApiGetForexSnapshotTickersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexSnapshotTickers(requestParameters: DefaultApiGetForexSnapshotTickersRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexSnapshotTickers(requestParameters.tickers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Global foreign exchange (FX) trading venues and market infrastructure, including electronic trading platforms, banks, and other institutions facilitating currency pair trading worldwide.
     * @param {DefaultApiGetForexV1ExchangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getForexV1Exchanges(requestParameters: DefaultApiGetForexV1ExchangesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getForexV1Exchanges(requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregates for a contract in a given time range.
     * @summary Aggregates
     * @param {DefaultApiGetFuturesAggregatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFuturesAggregates(requestParameters: DefaultApiGetFuturesAggregatesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFuturesAggregates(requestParameters.ticker, requestParameters.resolution, requestParameters.windowStart, requestParameters.limit, requestParameters.windowStartGte, requestParameters.windowStartGt, requestParameters.windowStartLte, requestParameters.windowStartLt, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Contract Details endpoint returns the details for a single contract at a specific point in time.
     * @summary Contract Details
     * @param {DefaultApiGetFuturesContractDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFuturesContractDetails(requestParameters: DefaultApiGetFuturesContractDetailsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFuturesContractDetails(requestParameters.ticker, requestParameters.asOf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Contracts endpoint returns a list of futures contracts. This endpoint can be used to query for contracts based on a variety of parameters, including the contract\'s ticker, product code, first trade date, last trade date, and whether or not the contract was active on a given date.
     * @summary Contracts
     * @param {DefaultApiGetFuturesContractsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFuturesContracts(requestParameters: DefaultApiGetFuturesContractsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFuturesContracts(requestParameters.productCode, requestParameters.firstTradeDate, requestParameters.lastTradeDate, requestParameters.asOf, requestParameters.active, requestParameters.type, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Trading-Date Based Futures Schedules API provides detailed trading schedules for all products on a specific day. This API allows you to retrieve detailed information about trading sessions, including market events like preopen, open, and closed, along with their precise timestamps.
     * @summary Daily Schedules
     * @param {DefaultApiGetFuturesDailySchedulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFuturesDailySchedules(requestParameters: DefaultApiGetFuturesDailySchedulesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFuturesDailySchedules(requestParameters.sessionEndDate, requestParameters.tradingVenue, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The market status endpoint returns the current status of the futures market for the given product code(s).
     * @summary Market Status
     * @param {DefaultApiGetFuturesMarketStatusesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFuturesMarketStatuses(requestParameters: DefaultApiGetFuturesMarketStatusesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFuturesMarketStatuses(requestParameters.productCodeAnyOf, requestParameters.productCode, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Product Details endpoint returns the details for a single product as of a specific day.
     * @summary Product Details
     * @param {DefaultApiGetFuturesProductDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFuturesProductDetails(requestParameters: DefaultApiGetFuturesProductDetailsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFuturesProductDetails(requestParameters.productCode, requestParameters.type, requestParameters.asOf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Product-Specific Futures Schedules API provides detailed trading schedules for a specific futures product. This API allows you to query schedules for a single product across a range of dates. Users can access comprehensive information about trading sessions, including market events such as preopen, open, and closed, along with their precise timestamps.
     * @summary Product Schedules
     * @param {DefaultApiGetFuturesProductSchedulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFuturesProductSchedules(requestParameters: DefaultApiGetFuturesProductSchedulesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFuturesProductSchedules(requestParameters.productCode, requestParameters.sessionEndDate, requestParameters.limit, requestParameters.sessionEndDateGte, requestParameters.sessionEndDateGt, requestParameters.sessionEndDateLte, requestParameters.sessionEndDateLt, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Products endpoint returns a list of futures products. This endpoint can be used to query for products based on a variety of parameters, including by the product\'s name, exchange, sector, sub-sector, asset class, asset sub-class, and type.
     * @summary Products
     * @param {DefaultApiGetFuturesProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFuturesProducts(requestParameters: DefaultApiGetFuturesProductsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFuturesProducts(requestParameters.name, requestParameters.asOf, requestParameters.tradingVenue, requestParameters.sector, requestParameters.subSector, requestParameters.assetClass, requestParameters.assetSubClass, requestParameters.type, requestParameters.limit, requestParameters.nameSearch, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get quotes for a contract in a given time range.
     * @summary Quotes
     * @param {DefaultApiGetFuturesQuotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFuturesQuotes(requestParameters: DefaultApiGetFuturesQuotesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFuturesQuotes(requestParameters.ticker, requestParameters.timestamp, requestParameters.sessionEndDate, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.sessionEndDateGte, requestParameters.sessionEndDateGt, requestParameters.sessionEndDateLte, requestParameters.sessionEndDateLt, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a contract in a given time range.
     * @summary Trades
     * @param {DefaultApiGetFuturesTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFuturesTrades(requestParameters: DefaultApiGetFuturesTradesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFuturesTrades(requestParameters.ticker, requestParameters.timestamp, requestParameters.sessionEndDate, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.sessionEndDateGte, requestParameters.sessionEndDateGt, requestParameters.sessionEndDateLte, requestParameters.sessionEndDateLt, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information about a specific futures contract identified by its ticker. The response includes comprehensive attributes such as active status, trade dates, days to maturity, exchange code, order quantity limits, settlement date, tick sizes, and other key metrics. Users can specify a point-in-time (as_of) to view the contract\'s state on a particular date, supporting informed trading decisions and historical analysis.  Use Cases: Contract specification, historical product checks, system integration, trading decision support.
     * @summary futures_contracts_v1 API
     * @param {DefaultApiGetFuturesVXContractsNewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFuturesVXContractsNew(requestParameters: DefaultApiGetFuturesVXContractsNewRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFuturesVXContractsNew(requestParameters.date, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.productCode, requestParameters.productCodeAnyOf, requestParameters.productCodeGt, requestParameters.productCodeGte, requestParameters.productCodeLt, requestParameters.productCodeLte, requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.active, requestParameters.type, requestParameters.typeAnyOf, requestParameters.typeGt, requestParameters.typeGte, requestParameters.typeLt, requestParameters.typeLte, requestParameters.firstTradeDate, requestParameters.firstTradeDateGt, requestParameters.firstTradeDateGte, requestParameters.firstTradeDateLt, requestParameters.firstTradeDateLte, requestParameters.lastTradeDate, requestParameters.lastTradeDateGt, requestParameters.lastTradeDateGte, requestParameters.lastTradeDateLt, requestParameters.lastTradeDateLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * US futures exchanges and trading venues including major derivatives exchanges (CME, CBOT, NYMEX, COMEX) and other futures market infrastructure for commodity, financial, and other derivative contract trading.
     * @param {DefaultApiGetFuturesVXExchangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFuturesVXExchanges(requestParameters: DefaultApiGetFuturesVXExchangesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFuturesVXExchanges(requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information about a single futures product as of a specified date, including its asset class, exchange code, full product name, settlement details, pricing quotation, sector classifications, and unit of measure. Optional parameters such as product type (single or combo) and as_of allow you to capture the products state on a specific day, providing essential context for trading decisions and system integrations.  Use Cases: Product specification, historical product checks, risk management, trading system integration.
     * @summary futures_products_v1 API
     * @param {DefaultApiGetFuturesVXProductsNewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFuturesVXProductsNew(requestParameters: DefaultApiGetFuturesVXProductsNewRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFuturesVXProductsNew(requestParameters.name, requestParameters.nameAnyOf, requestParameters.nameGt, requestParameters.nameGte, requestParameters.nameLt, requestParameters.nameLte, requestParameters.productCode, requestParameters.productCodeAnyOf, requestParameters.productCodeGt, requestParameters.productCodeGte, requestParameters.productCodeLt, requestParameters.productCodeLte, requestParameters.date, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.sector, requestParameters.sectorAnyOf, requestParameters.sectorGt, requestParameters.sectorGte, requestParameters.sectorLt, requestParameters.sectorLte, requestParameters.subSector, requestParameters.subSectorAnyOf, requestParameters.subSectorGt, requestParameters.subSectorGte, requestParameters.subSectorLt, requestParameters.subSectorLte, requestParameters.assetClass, requestParameters.assetClassAnyOf, requestParameters.assetClassGt, requestParameters.assetClassGte, requestParameters.assetClassLt, requestParameters.assetClassLte, requestParameters.assetSubClass, requestParameters.assetSubClassAnyOf, requestParameters.assetSubClassGt, requestParameters.assetSubClassGte, requestParameters.assetSubClassLt, requestParameters.assetSubClassLte, requestParameters.type, requestParameters.typeAnyOf, requestParameters.typeGt, requestParameters.typeGte, requestParameters.typeLt, requestParameters.typeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a snapshot of the most recent futures contract data.
     * @summary futures_snapshot_v1 API
     * @param {DefaultApiGetFuturesVXSnapshotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFuturesVXSnapshot(requestParameters: DefaultApiGetFuturesVXSnapshotRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFuturesVXSnapshot(requestParameters.productCode, requestParameters.productCodeAnyOf, requestParameters.productCodeGt, requestParameters.productCodeGte, requestParameters.productCodeLt, requestParameters.productCodeLte, requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
     * @summary Grouped Daily (Bars)
     * @param {DefaultApiGetGroupedCryptoAggregatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGroupedCryptoAggregates(requestParameters: DefaultApiGetGroupedCryptoAggregatesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGroupedCryptoAggregates(requestParameters.date, requestParameters.adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
     * @summary Grouped Daily (Bars)
     * @param {DefaultApiGetGroupedForexAggregatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGroupedForexAggregates(requestParameters: DefaultApiGetGroupedForexAggregatesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGroupedForexAggregates(requestParameters.date, requestParameters.adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
     * @summary Grouped Daily (Bars)
     * @param {DefaultApiGetGroupedStocksAggregatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGroupedStocksAggregates(requestParameters: DefaultApiGetGroupedStocksAggregatesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGroupedStocksAggregates(requestParameters.date, requestParameters.adjusted, requestParameters.includeOtc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for an index over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {DefaultApiGetIndicesAggregatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicesAggregates(requestParameters: DefaultApiGetIndicesAggregatesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicesAggregates(requestParameters.indicesTicker, requestParameters.multiplier, requestParameters.timespan, requestParameters.from, requestParameters.to, requestParameters.sort, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {DefaultApiGetIndicesEMARequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicesEMA(requestParameters: DefaultApiGetIndicesEMARequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicesEMA(requestParameters.indicesTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {DefaultApiGetIndicesMACDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicesMACD(requestParameters: DefaultApiGetIndicesMACDRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicesMACD(requestParameters.indicesTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.shortWindow, requestParameters.longWindow, requestParameters.signalWindow, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the open, close and afterhours values of a index symbol on a certain date. 
     * @summary Daily Open/Close
     * @param {DefaultApiGetIndicesOpenCloseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicesOpenClose(requestParameters: DefaultApiGetIndicesOpenCloseRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicesOpenClose(requestParameters.indicesTicker, requestParameters.date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {DefaultApiGetIndicesRSIRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicesRSI(requestParameters: DefaultApiGetIndicesRSIRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicesRSI(requestParameters.indicesTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {DefaultApiGetIndicesSMARequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicesSMA(requestParameters: DefaultApiGetIndicesSMARequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicesSMA(requestParameters.indicesTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Snapshot of indices data for said tickers
     * @summary Indices Snapshot
     * @param {DefaultApiGetIndicesSnapshotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIndicesSnapshot(requestParameters: DefaultApiGetIndicesSnapshotRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIndicesSnapshot(requestParameters.tickerAnyOf, requestParameters.ticker, requestParameters.tickerGte, requestParameters.tickerGt, requestParameters.tickerLte, requestParameters.tickerLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the last trade tick for a cryptocurrency pair.
     * @summary Last Trade for a Crypto Pair
     * @param {DefaultApiGetLastCryptoTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLastCryptoTrade(requestParameters: DefaultApiGetLastCryptoTradeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLastCryptoTrade(requestParameters.from, requestParameters.to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the last quote tick for a forex currency pair.
     * @summary Last Quote for a Currency Pair
     * @param {DefaultApiGetLastCurrencyQuoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLastCurrencyQuote(requestParameters: DefaultApiGetLastCurrencyQuoteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLastCurrencyQuote(requestParameters.from, requestParameters.to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most recent trade for a given options contract.
     * @summary Last Trade
     * @param {DefaultApiGetLastOptionsTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLastOptionsTrade(requestParameters: DefaultApiGetLastOptionsTradeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLastOptionsTrade(requestParameters.optionsTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most recent NBBO (Quote) tick for a given stock.
     * @summary Last Quote
     * @param {DefaultApiGetLastStocksQuoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLastStocksQuote(requestParameters: DefaultApiGetLastStocksQuoteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLastStocksQuote(requestParameters.stocksTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most recent trade for a given stock.
     * @summary Last Trade
     * @param {DefaultApiGetLastStocksTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLastStocksTrade(requestParameters: DefaultApiGetLastStocksTradeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLastStocksTrade(requestParameters.stocksTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get upcoming market holidays and their open/close times.
     * @summary Market Holidays
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMarketHolidays(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMarketHolidays(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current trading status of the exchanges and overall financial markets.
     * @summary Market Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMarketStatus(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMarketStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the snapshot of an option contract for a stock equity.
     * @summary Option Contract
     * @param {DefaultApiGetOptionContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionContract(requestParameters: DefaultApiGetOptionContractRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionContract(requestParameters.underlyingAsset, requestParameters.optionContract, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for an option contract over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {DefaultApiGetOptionsAggregatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsAggregates(requestParameters: DefaultApiGetOptionsAggregatesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsAggregates(requestParameters.optionsTicker, requestParameters.multiplier, requestParameters.timespan, requestParameters.from, requestParameters.to, requestParameters.adjusted, requestParameters.sort, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the snapshot of all options contracts for an underlying ticker.
     * @summary Options Chain
     * @param {DefaultApiGetOptionsChainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsChain(requestParameters: DefaultApiGetOptionsChainRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsChain(requestParameters.underlyingAsset, requestParameters.strikePrice, requestParameters.expirationDate, requestParameters.contractType, requestParameters.strikePriceGte, requestParameters.strikePriceGt, requestParameters.strikePriceLte, requestParameters.strikePriceLt, requestParameters.expirationDateGte, requestParameters.expirationDateGt, requestParameters.expirationDateLte, requestParameters.expirationDateLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an options contract
     * @summary Options Contract
     * @param {DefaultApiGetOptionsContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsContract(requestParameters: DefaultApiGetOptionsContractRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsContract(requestParameters.optionsTicker, requestParameters.asOf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {DefaultApiGetOptionsEMARequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsEMA(requestParameters: DefaultApiGetOptionsEMARequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsEMA(requestParameters.optionsTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {DefaultApiGetOptionsMACDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsMACD(requestParameters: DefaultApiGetOptionsMACDRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsMACD(requestParameters.optionsTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.shortWindow, requestParameters.longWindow, requestParameters.signalWindow, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the open, close and afterhours prices of an options contract on a certain date. 
     * @summary Daily Open/Close
     * @param {DefaultApiGetOptionsOpenCloseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsOpenClose(requestParameters: DefaultApiGetOptionsOpenCloseRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsOpenClose(requestParameters.optionsTicker, requestParameters.date, requestParameters.adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get quotes for an options ticker symbol in a given time range.
     * @summary Quotes
     * @param {DefaultApiGetOptionsQuotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsQuotes(requestParameters: DefaultApiGetOptionsQuotesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsQuotes(requestParameters.optionsTicker, requestParameters.timestamp, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {DefaultApiGetOptionsRSIRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsRSI(requestParameters: DefaultApiGetOptionsRSIRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsRSI(requestParameters.optionsTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {DefaultApiGetOptionsSMARequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsSMA(requestParameters: DefaultApiGetOptionsSMARequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsSMA(requestParameters.optionsTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for an options ticker symbol in a given time range.
     * @summary Trades
     * @param {DefaultApiGetOptionsTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsTrades(requestParameters: DefaultApiGetOptionsTradesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsTrades(requestParameters.optionsTicker, requestParameters.timestamp, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * US options exchanges and trading venues including traditional options exchanges (CBOE, ISE, etc.), Securities Information Processors (SIP), and other options market infrastructure for derivatives trading.
     * @param {DefaultApiGetOptionsV1ExchangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOptionsV1Exchanges(requestParameters: DefaultApiGetOptionsV1ExchangesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOptionsV1Exchanges(requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
     * @summary Previous Close
     * @param {DefaultApiGetPreviousCryptoAggregatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPreviousCryptoAggregates(requestParameters: DefaultApiGetPreviousCryptoAggregatesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPreviousCryptoAggregates(requestParameters.cryptoTicker, requestParameters.adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified forex pair. 
     * @summary Previous Close
     * @param {DefaultApiGetPreviousForexAggregatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPreviousForexAggregates(requestParameters: DefaultApiGetPreviousForexAggregatesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPreviousForexAggregates(requestParameters.forexTicker, requestParameters.adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified index. 
     * @summary Previous Close
     * @param {DefaultApiGetPreviousIndicesAggregatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPreviousIndicesAggregates(requestParameters: DefaultApiGetPreviousIndicesAggregatesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPreviousIndicesAggregates(requestParameters.indicesTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified option contract. 
     * @summary Previous Close
     * @param {DefaultApiGetPreviousOptionsAggregatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPreviousOptionsAggregates(requestParameters: DefaultApiGetPreviousOptionsAggregatesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPreviousOptionsAggregates(requestParameters.optionsTicker, requestParameters.adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the previous day\'s open, high, low, and close (OHLC) for the specified stock ticker. 
     * @summary Previous Close
     * @param {DefaultApiGetPreviousStocksAggregatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPreviousStocksAggregates(requestParameters: DefaultApiGetPreviousStocksAggregatesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPreviousStocksAggregates(requestParameters.stocksTicker, requestParameters.adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of tickers related to the queried ticker based on News and Returns data.
     * @summary Related Companies
     * @param {DefaultApiGetRelatedCompaniesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRelatedCompanies(requestParameters: DefaultApiGetRelatedCompaniesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRelatedCompanies(requestParameters.ticker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
     * @summary Summaries
     * @param {DefaultApiGetSnapshotSummaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSnapshotSummary(requestParameters: DefaultApiGetSnapshotSummaryRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSnapshotSummary(requestParameters.tickerAnyOf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get snapshots for assets of all types
     * @summary Universal Snapshot
     * @param {DefaultApiGetSnapshotsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSnapshots(requestParameters: DefaultApiGetSnapshotsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSnapshots(requestParameters.ticker, requestParameters.type, requestParameters.tickerGte, requestParameters.tickerGt, requestParameters.tickerLte, requestParameters.tickerLt, requestParameters.tickerAnyOf, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregate bars for a stock over a given date range in custom time window sizes. <br /> <br /> For example, if timespan = minute and multiplier = 5 then 5-minute bars will be returned. 
     * @summary Aggregates (Bars)
     * @param {DefaultApiGetStocksAggregatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksAggregates(requestParameters: DefaultApiGetStocksAggregatesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksAggregates(requestParameters.stocksTicker, requestParameters.multiplier, requestParameters.timespan, requestParameters.from, requestParameters.to, requestParameters.adjusted, requestParameters.sort, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @summary Exponential Moving Average (EMA)
     * @param {DefaultApiGetStocksEMARequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksEMA(requestParameters: DefaultApiGetStocksEMARequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksEMA(requestParameters.stockTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A comprehensive financial dataset containing quarterly and annual balance sheet data for public companies. Includes detailed asset, liability, and equity positions representing the company\'s financial position at specific points in time. Balance sheet data represents point-in-time snapshots rather than cumulative flows, showing what the company owns, owes, and shareholders\' equity as of each period end date.
     * @param {DefaultApiGetStocksFinancialsV1BalanceSheetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksFinancialsV1BalanceSheets(requestParameters: DefaultApiGetStocksFinancialsV1BalanceSheetsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksFinancialsV1BalanceSheets(requestParameters.cik, requestParameters.cikAnyOf, requestParameters.cikGt, requestParameters.cikGte, requestParameters.cikLt, requestParameters.cikLte, requestParameters.tickers, requestParameters.tickersAllOf, requestParameters.tickersAnyOf, requestParameters.periodEnd, requestParameters.periodEndGt, requestParameters.periodEndGte, requestParameters.periodEndLt, requestParameters.periodEndLte, requestParameters.filingDate, requestParameters.filingDateGt, requestParameters.filingDateGte, requestParameters.filingDateLt, requestParameters.filingDateLte, requestParameters.fiscalYear, requestParameters.fiscalYearGt, requestParameters.fiscalYearGte, requestParameters.fiscalYearLt, requestParameters.fiscalYearLte, requestParameters.fiscalQuarter, requestParameters.fiscalQuarterGt, requestParameters.fiscalQuarterGte, requestParameters.fiscalQuarterLt, requestParameters.fiscalQuarterLte, requestParameters.timeframe, requestParameters.timeframeAnyOf, requestParameters.timeframeGt, requestParameters.timeframeGte, requestParameters.timeframeLt, requestParameters.timeframeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A comprehensive financial dataset containing quarterly, annual, and trailing twelve-month cash flow statement data for public companies. Includes detailed operating, investing, and financing cash flows with proper TTM calculations that sum all cash flow components over four quarters. TTM records are validated to ensure exactly four distinct quarters spanning 250-400 days for accurate trailing twelve-month cash flow analysis.
     * @param {DefaultApiGetStocksFinancialsV1CashFlowStatementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksFinancialsV1CashFlowStatements(requestParameters: DefaultApiGetStocksFinancialsV1CashFlowStatementsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksFinancialsV1CashFlowStatements(requestParameters.cik, requestParameters.cikAnyOf, requestParameters.cikGt, requestParameters.cikGte, requestParameters.cikLt, requestParameters.cikLte, requestParameters.periodEnd, requestParameters.periodEndGt, requestParameters.periodEndGte, requestParameters.periodEndLt, requestParameters.periodEndLte, requestParameters.filingDate, requestParameters.filingDateGt, requestParameters.filingDateGte, requestParameters.filingDateLt, requestParameters.filingDateLte, requestParameters.tickers, requestParameters.tickersAllOf, requestParameters.tickersAnyOf, requestParameters.fiscalYear, requestParameters.fiscalYearGt, requestParameters.fiscalYearGte, requestParameters.fiscalYearLt, requestParameters.fiscalYearLte, requestParameters.fiscalQuarter, requestParameters.fiscalQuarterGt, requestParameters.fiscalQuarterGte, requestParameters.fiscalQuarterLt, requestParameters.fiscalQuarterLte, requestParameters.timeframe, requestParameters.timeframeAnyOf, requestParameters.timeframeGt, requestParameters.timeframeGte, requestParameters.timeframeLt, requestParameters.timeframeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A comprehensive database of income statement financial data for public companies, including key metrics such as revenue, expenses, and net income for various reporting periods.
     * @param {DefaultApiGetStocksFinancialsV1IncomeStatementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksFinancialsV1IncomeStatements(requestParameters: DefaultApiGetStocksFinancialsV1IncomeStatementsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksFinancialsV1IncomeStatements(requestParameters.cik, requestParameters.cikAnyOf, requestParameters.cikGt, requestParameters.cikGte, requestParameters.cikLt, requestParameters.cikLte, requestParameters.tickers, requestParameters.tickersAllOf, requestParameters.tickersAnyOf, requestParameters.periodEnd, requestParameters.periodEndGt, requestParameters.periodEndGte, requestParameters.periodEndLt, requestParameters.periodEndLte, requestParameters.filingDate, requestParameters.filingDateGt, requestParameters.filingDateGte, requestParameters.filingDateLt, requestParameters.filingDateLte, requestParameters.fiscalYear, requestParameters.fiscalYearGt, requestParameters.fiscalYearGte, requestParameters.fiscalYearLt, requestParameters.fiscalYearLte, requestParameters.fiscalQuarter, requestParameters.fiscalQuarterGt, requestParameters.fiscalQuarterGte, requestParameters.fiscalQuarterLt, requestParameters.fiscalQuarterLte, requestParameters.timeframe, requestParameters.timeframeAnyOf, requestParameters.timeframeGt, requestParameters.timeframeGte, requestParameters.timeframeLt, requestParameters.timeframeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A comprehensive financial ratios dataset providing key valuation, profitability, liquidity, and leverage metrics for public companies. Combines data from income statements, balance sheets, and cash flow statements with daily stock prices to calculate ratios on a daily basis. Uses trailing twelve months (TTM) data for income/cash flow metrics and quarterly data for balance sheet items. Fundamental data updates are applied starting from each filing\'s period end date. Market cap calculations use point-in-time shares outstanding for historical accuracy.
     * @param {DefaultApiGetStocksFinancialsV1RatiosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksFinancialsV1Ratios(requestParameters: DefaultApiGetStocksFinancialsV1RatiosRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksFinancialsV1Ratios(requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.cik, requestParameters.cikAnyOf, requestParameters.cikGt, requestParameters.cikGte, requestParameters.cikLt, requestParameters.cikLte, requestParameters.price, requestParameters.priceGt, requestParameters.priceGte, requestParameters.priceLt, requestParameters.priceLte, requestParameters.averageVolume, requestParameters.averageVolumeGt, requestParameters.averageVolumeGte, requestParameters.averageVolumeLt, requestParameters.averageVolumeLte, requestParameters.marketCap, requestParameters.marketCapGt, requestParameters.marketCapGte, requestParameters.marketCapLt, requestParameters.marketCapLte, requestParameters.earningsPerShare, requestParameters.earningsPerShareGt, requestParameters.earningsPerShareGte, requestParameters.earningsPerShareLt, requestParameters.earningsPerShareLte, requestParameters.priceToEarnings, requestParameters.priceToEarningsGt, requestParameters.priceToEarningsGte, requestParameters.priceToEarningsLt, requestParameters.priceToEarningsLte, requestParameters.priceToBook, requestParameters.priceToBookGt, requestParameters.priceToBookGte, requestParameters.priceToBookLt, requestParameters.priceToBookLte, requestParameters.priceToSales, requestParameters.priceToSalesGt, requestParameters.priceToSalesGte, requestParameters.priceToSalesLt, requestParameters.priceToSalesLte, requestParameters.priceToCashFlow, requestParameters.priceToCashFlowGt, requestParameters.priceToCashFlowGte, requestParameters.priceToCashFlowLt, requestParameters.priceToCashFlowLte, requestParameters.priceToFreeCashFlow, requestParameters.priceToFreeCashFlowGt, requestParameters.priceToFreeCashFlowGte, requestParameters.priceToFreeCashFlowLt, requestParameters.priceToFreeCashFlowLte, requestParameters.dividendYield, requestParameters.dividendYieldGt, requestParameters.dividendYieldGte, requestParameters.dividendYieldLt, requestParameters.dividendYieldLte, requestParameters.returnOnAssets, requestParameters.returnOnAssetsGt, requestParameters.returnOnAssetsGte, requestParameters.returnOnAssetsLt, requestParameters.returnOnAssetsLte, requestParameters.returnOnEquity, requestParameters.returnOnEquityGt, requestParameters.returnOnEquityGte, requestParameters.returnOnEquityLt, requestParameters.returnOnEquityLte, requestParameters.debtToEquity, requestParameters.debtToEquityGt, requestParameters.debtToEquityGte, requestParameters.debtToEquityLt, requestParameters.debtToEquityLte, requestParameters.current, requestParameters.currentGt, requestParameters.currentGte, requestParameters.currentLt, requestParameters.currentLte, requestParameters.quick, requestParameters.quickGt, requestParameters.quickGte, requestParameters.quickLt, requestParameters.quickLte, requestParameters.cash, requestParameters.cashGt, requestParameters.cashGte, requestParameters.cashLt, requestParameters.cashLte, requestParameters.evToSales, requestParameters.evToSalesGt, requestParameters.evToSalesGte, requestParameters.evToSalesLt, requestParameters.evToSalesLte, requestParameters.evToEbitda, requestParameters.evToEbitdaGt, requestParameters.evToEbitdaGte, requestParameters.evToEbitdaLt, requestParameters.evToEbitdaLte, requestParameters.enterpriseValue, requestParameters.enterpriseValueGt, requestParameters.enterpriseValueGte, requestParameters.enterpriseValueLt, requestParameters.enterpriseValueLte, requestParameters.freeCashFlow, requestParameters.freeCashFlowGt, requestParameters.freeCashFlowGte, requestParameters.freeCashFlowLt, requestParameters.freeCashFlowLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @summary Moving Average Convergence/Divergence (MACD)
     * @param {DefaultApiGetStocksMACDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksMACD(requestParameters: DefaultApiGetStocksMACDRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksMACD(requestParameters.stockTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.shortWindow, requestParameters.longWindow, requestParameters.signalWindow, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the open, close and afterhours prices of a stock symbol on a certain date. 
     * @summary Daily Open/Close
     * @param {DefaultApiGetStocksOpenCloseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksOpenClose(requestParameters: DefaultApiGetStocksOpenCloseRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksOpenClose(requestParameters.stocksTicker, requestParameters.date, requestParameters.adjusted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get NBBO quotes for a ticker symbol in a given time range.
     * @summary Quotes (NBBO)
     * @param {DefaultApiGetStocksQuotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksQuotes(requestParameters: DefaultApiGetStocksQuotesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksQuotes(requestParameters.stockTicker, requestParameters.timestamp, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @summary Relative Strength Index (RSI)
     * @param {DefaultApiGetStocksRSIRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksRSI(requestParameters: DefaultApiGetStocksRSIRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksRSI(requestParameters.stockTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @summary Simple Moving Average (SMA)
     * @param {DefaultApiGetStocksSMARequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksSMA(requestParameters: DefaultApiGetStocksSMARequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksSMA(requestParameters.stockTicker, requestParameters.timestamp, requestParameters.timespan, requestParameters.adjusted, requestParameters.window, requestParameters.seriesType, requestParameters.expandUnderlying, requestParameters.order, requestParameters.limit, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. <br /> <br /> Top gainers are those tickers whose price has increased by the highest percentage since the previous day\'s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day\'s close. This output will only include tickers with a trading volume of 10,000 or more. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
     * @summary Gainers/Losers
     * @param {DefaultApiGetStocksSnapshotDirectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksSnapshotDirection(requestParameters: DefaultApiGetStocksSnapshotDirectionRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksSnapshotDirection(requestParameters.direction, requestParameters.includeOtc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most up-to-date market data for a single traded stock ticker. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @summary Ticker
     * @param {DefaultApiGetStocksSnapshotTickerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksSnapshotTicker(requestParameters: DefaultApiGetStocksSnapshotTickerRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksSnapshotTicker(requestParameters.stocksTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most up-to-date market data for all traded stock symbols. <br /> <br /> Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @summary All Tickers
     * @param {DefaultApiGetStocksSnapshotTickersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksSnapshotTickers(requestParameters: DefaultApiGetStocksSnapshotTickersRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksSnapshotTickers(requestParameters.tickers, requestParameters.includeOtc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades for a ticker symbol in a given time range.
     * @summary Trades
     * @param {DefaultApiGetStocksTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksTrades(requestParameters: DefaultApiGetStocksTradesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksTrades(requestParameters.stockTicker, requestParameters.timestamp, requestParameters.timestampGte, requestParameters.timestampGt, requestParameters.timestampLte, requestParameters.timestampLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Contains historical dividend payment records for US stocks with split-adjusted amounts and historical adjustment factors for price normalization.
     * @param {DefaultApiGetStocksV1DividendsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksV1Dividends(requestParameters: DefaultApiGetStocksV1DividendsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksV1Dividends(requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.exDividendDate, requestParameters.exDividendDateGt, requestParameters.exDividendDateGte, requestParameters.exDividendDateLt, requestParameters.exDividendDateLte, requestParameters.frequency, requestParameters.frequencyGt, requestParameters.frequencyGte, requestParameters.frequencyLt, requestParameters.frequencyLte, requestParameters.distributionType, requestParameters.distributionTypeAnyOf, requestParameters.distributionTypeGt, requestParameters.distributionTypeGte, requestParameters.distributionTypeLt, requestParameters.distributionTypeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * US stock exchanges, trading venues, and reporting facilities including exchanges (NYSE, Nasdaq), Trade Reporting Facilities (TRF), Securities Information Processors (SIP), and OTC Reporting Facilities (ORF) for equity trading.
     * @param {DefaultApiGetStocksV1ExchangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksV1Exchanges(requestParameters: DefaultApiGetStocksV1ExchangesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksV1Exchanges(requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Comprehensive FINRA short interest data that tracks the short selling metrics for securities on a specific settlement date.
     * @param {DefaultApiGetStocksV1ShortInterestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksV1ShortInterest(requestParameters: DefaultApiGetStocksV1ShortInterestRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksV1ShortInterest(requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.daysToCover, requestParameters.daysToCoverAnyOf, requestParameters.daysToCoverGt, requestParameters.daysToCoverGte, requestParameters.daysToCoverLt, requestParameters.daysToCoverLte, requestParameters.settlementDate, requestParameters.settlementDateAnyOf, requestParameters.settlementDateGt, requestParameters.settlementDateGte, requestParameters.settlementDateLt, requestParameters.settlementDateLte, requestParameters.avgDailyVolume, requestParameters.avgDailyVolumeAnyOf, requestParameters.avgDailyVolumeGt, requestParameters.avgDailyVolumeGte, requestParameters.avgDailyVolumeLt, requestParameters.avgDailyVolumeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Contains short selling volume for different stock tickers, capturing total trading volume, short sale details, and breakdown by different trading platforms.
     * @param {DefaultApiGetStocksV1ShortVolumeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksV1ShortVolume(requestParameters: DefaultApiGetStocksV1ShortVolumeRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksV1ShortVolume(requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.shortVolumeRatio, requestParameters.shortVolumeRatioAnyOf, requestParameters.shortVolumeRatioGt, requestParameters.shortVolumeRatioGte, requestParameters.shortVolumeRatioLt, requestParameters.shortVolumeRatioLte, requestParameters.totalVolume, requestParameters.totalVolumeAnyOf, requestParameters.totalVolumeGt, requestParameters.totalVolumeGte, requestParameters.totalVolumeLt, requestParameters.totalVolumeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Contains historical stock split and reverse split events for US equities with historical adjustment factors for price normalization.
     * @param {DefaultApiGetStocksV1SplitsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStocksV1Splits(requestParameters: DefaultApiGetStocksV1SplitsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStocksV1Splits(requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.executionDate, requestParameters.executionDateGt, requestParameters.executionDateGte, requestParameters.executionDateLt, requestParameters.executionDateLte, requestParameters.adjustmentType, requestParameters.adjustmentTypeAnyOf, requestParameters.adjustmentTypeGt, requestParameters.adjustmentTypeGte, requestParameters.adjustmentTypeLt, requestParameters.adjustmentTypeLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single ticker supported by Massive.com. This response will have detailed information about the ticker and the company behind it.
     * @summary Ticker Details v3
     * @param {DefaultApiGetTickerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTicker(requestParameters: DefaultApiGetTickerRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTicker(requestParameters.ticker, requestParameters.date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Contains corporate events and announcements for publicly traded companies, including earnings releases, conferences, dividends, and business updates sourced from TMX.
     * @param {DefaultApiGetTmxV1CorporateEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTmxV1CorporateEvents(requestParameters: DefaultApiGetTmxV1CorporateEventsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTmxV1CorporateEvents(requestParameters.date, requestParameters.dateAnyOf, requestParameters.dateGt, requestParameters.dateGte, requestParameters.dateLt, requestParameters.dateLte, requestParameters.type, requestParameters.typeAnyOf, requestParameters.typeGt, requestParameters.typeGte, requestParameters.typeLt, requestParameters.typeLte, requestParameters.status, requestParameters.statusAnyOf, requestParameters.statusGt, requestParameters.statusGte, requestParameters.statusLt, requestParameters.statusLte, requestParameters.ticker, requestParameters.tickerAnyOf, requestParameters.tickerGt, requestParameters.tickerGte, requestParameters.tickerLt, requestParameters.tickerLte, requestParameters.isin, requestParameters.isinAnyOf, requestParameters.isinGt, requestParameters.isinGte, requestParameters.isinLt, requestParameters.isinLte, requestParameters.tradingVenue, requestParameters.tradingVenueAnyOf, requestParameters.tradingVenueGt, requestParameters.tradingVenueGte, requestParameters.tradingVenueLt, requestParameters.tradingVenueLte, requestParameters.tmxCompanyId, requestParameters.tmxCompanyIdGt, requestParameters.tmxCompanyIdGte, requestParameters.tmxCompanyIdLt, requestParameters.tmxCompanyIdLte, requestParameters.tmxRecordId, requestParameters.tmxRecordIdAnyOf, requestParameters.tmxRecordIdGt, requestParameters.tmxRecordIdGte, requestParameters.tmxRecordIdLt, requestParameters.tmxRecordIdLte, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all conditions that Massive uses.
     * @summary Conditions
     * @param {DefaultApiListConditionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listConditions(requestParameters: DefaultApiListConditionsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listConditions(requestParameters.assetClass, requestParameters.dataType, requestParameters.id, requestParameters.sip, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
     * @summary Dividends v3
     * @param {DefaultApiListDividendsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listDividends(requestParameters: DefaultApiListDividendsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listDividends(requestParameters.ticker, requestParameters.exDividendDate, requestParameters.recordDate, requestParameters.declarationDate, requestParameters.payDate, requestParameters.frequency, requestParameters.cashAmount, requestParameters.dividendType, requestParameters.tickerGte, requestParameters.tickerGt, requestParameters.tickerLte, requestParameters.tickerLt, requestParameters.exDividendDateGte, requestParameters.exDividendDateGt, requestParameters.exDividendDateLte, requestParameters.exDividendDateLt, requestParameters.recordDateGte, requestParameters.recordDateGt, requestParameters.recordDateLte, requestParameters.recordDateLt, requestParameters.declarationDateGte, requestParameters.declarationDateGt, requestParameters.declarationDateLte, requestParameters.declarationDateLt, requestParameters.payDateGte, requestParameters.payDateGt, requestParameters.payDateLte, requestParameters.payDateLt, requestParameters.cashAmountGte, requestParameters.cashAmountGt, requestParameters.cashAmountLte, requestParameters.cashAmountLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all exchanges that Massive knows about.
     * @summary Exchanges
     * @param {DefaultApiListExchangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listExchanges(requestParameters: DefaultApiListExchangesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listExchanges(requestParameters.assetClass, requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined <a rel=\"noopener noreferrer nofollow\" target=\"_blank\" href=\"http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\">here</a>.
     * @summary Stock Financials vX
     * @param {DefaultApiListFinancialsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listFinancials(requestParameters: DefaultApiListFinancialsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listFinancials(requestParameters.ticker, requestParameters.cik, requestParameters.companyName, requestParameters.sic, requestParameters.filingDate, requestParameters.periodOfReportDate, requestParameters.timeframe, requestParameters.includeSources, requestParameters.companyNameSearch, requestParameters.filingDateGte, requestParameters.filingDateGt, requestParameters.filingDateLte, requestParameters.filingDateLt, requestParameters.periodOfReportDateGte, requestParameters.periodOfReportDateGt, requestParameters.periodOfReportDateLte, requestParameters.periodOfReportDateLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
     * @summary IPOs
     * @param {DefaultApiListIPOsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listIPOs(requestParameters: DefaultApiListIPOsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listIPOs(requestParameters.ticker, requestParameters.usCode, requestParameters.isin, requestParameters.listingDate, requestParameters.ipoStatus, requestParameters.listingDateGte, requestParameters.listingDateGt, requestParameters.listingDateLte, requestParameters.listingDateLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
     * @summary Ticker News
     * @param {DefaultApiListNewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listNews(requestParameters: DefaultApiListNewsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listNews(requestParameters.ticker, requestParameters.publishedUtc, requestParameters.tickerGte, requestParameters.tickerGt, requestParameters.tickerLte, requestParameters.tickerLt, requestParameters.publishedUtcGte, requestParameters.publishedUtcGt, requestParameters.publishedUtcLte, requestParameters.publishedUtcLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query for historical options contracts. This provides both active and expired options contracts.
     * @summary Options Contracts
     * @param {DefaultApiListOptionsContractsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listOptionsContracts(requestParameters: DefaultApiListOptionsContractsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listOptionsContracts(requestParameters.underlyingTicker, requestParameters.ticker, requestParameters.contractType, requestParameters.expirationDate, requestParameters.asOf, requestParameters.strikePrice, requestParameters.expired, requestParameters.underlyingTickerGte, requestParameters.underlyingTickerGt, requestParameters.underlyingTickerLte, requestParameters.underlyingTickerLt, requestParameters.expirationDateGte, requestParameters.expirationDateGt, requestParameters.expirationDateLte, requestParameters.expirationDateLt, requestParameters.strikePriceGte, requestParameters.strikePriceGt, requestParameters.strikePriceLte, requestParameters.strikePriceLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
     * @summary Stock Splits v3
     * @param {DefaultApiListStockSplitsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listStockSplits(requestParameters: DefaultApiListStockSplitsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listStockSplits(requestParameters.ticker, requestParameters.executionDate, requestParameters.reverseSplit, requestParameters.tickerGte, requestParameters.tickerGt, requestParameters.tickerLte, requestParameters.tickerLt, requestParameters.executionDateGte, requestParameters.executionDateGt, requestParameters.executionDateLte, requestParameters.executionDateLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all ticker types that Massive.com has.
     * @summary Ticker Types
     * @param {DefaultApiListTickerTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTickerTypes(requestParameters: DefaultApiListTickerTypesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listTickerTypes(requestParameters.assetClass, requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query all ticker symbols which are supported by Massive.com. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
     * @summary Tickers
     * @param {DefaultApiListTickersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTickers(requestParameters: DefaultApiListTickersRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listTickers(requestParameters.ticker, requestParameters.type, requestParameters.market, requestParameters.exchange, requestParameters.cusip, requestParameters.cik, requestParameters.date, requestParameters.search, requestParameters.active, requestParameters.tickerGte, requestParameters.tickerGt, requestParameters.tickerLte, requestParameters.tickerLt, requestParameters.order, requestParameters.limit, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum GetCryptoAggregatesTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoAggregatesSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoEMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoEMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoEMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoMACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoMACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoMACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoRSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoRSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoRSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoSMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoSMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoSMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoSnapshotDirectionDirectionEnum {
    Gainers = 'gainers',
    Losers = 'losers'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoTradesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCryptoTradesSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum GetCurrencyConversionPrecisionEnum {
    NUMBER_0 = 0,
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_3 = 3,
    NUMBER_4 = 4
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexAggregatesTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexAggregatesSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexEMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexEMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexEMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexMACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexMACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexMACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexQuotesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexQuotesSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexRSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexRSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexRSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexSMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexSMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexSMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetForexSnapshotDirectionDirectionEnum {
    Gainers = 'gainers',
    Losers = 'losers'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesAggregatesSortEnum {
    WindowStartAsc = 'window_start.asc',
    WindowStartDesc = 'window_start.desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesContractsActiveEnum {
    All = 'all',
    True = 'true',
    False = 'false'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesContractsTypeEnum {
    All = 'all',
    Single = 'single',
    Combo = 'combo'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesContractsSortEnum {
    ProductCodeAsc = 'product_code.asc',
    ProductCodeDesc = 'product_code.desc',
    FirstTradeDateAsc = 'first_trade_date.asc',
    FirstTradeDateDesc = 'first_trade_date.desc',
    LastTradeDateAsc = 'last_trade_date.asc',
    LastTradeDateDesc = 'last_trade_date.desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesDailySchedulesSortEnum {
    TradingVenueAsc = 'trading_venue.asc',
    TradingVenueDesc = 'trading_venue.desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesMarketStatusesSortEnum {
    ProductCodeAsc = 'product_code.asc',
    ProductCodeDesc = 'product_code.desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesProductDetailsTypeEnum {
    Single = 'single',
    Combo = 'combo'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesProductSchedulesSortEnum {
    SessionEndDateAsc = 'session_end_date.asc',
    SessionEndDateDesc = 'session_end_date.desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesProductsSectorEnum {
    Asia = 'asia',
    Base = 'base',
    Biofuels = 'biofuels',
    Coal = 'coal',
    CrossRates = 'cross_rates',
    CrudeOil = 'crude_oil',
    CustomIndex = 'custom_index',
    Dairy = 'dairy',
    DjUbsCi = 'dj_ubs_ci',
    Electricity = 'electricity',
    Emissions = 'emissions',
    Europe = 'europe',
    Fertilizer = 'fertilizer',
    Forestry = 'forestry',
    GrainsAndOilseeds = 'grains_and_oilseeds',
    IntlIndex = 'intl_index',
    LiqNatGasLng = 'liq_nat_gas_lng',
    Livestock = 'livestock',
    LongTermGov = 'long_term_gov',
    LongTermNonGov = 'long_term_non_gov',
    Majors = 'majors',
    Minors = 'minors',
    NatGas = 'nat_gas',
    NatGasLiqPetro = 'nat_gas_liq_petro',
    Precious = 'precious',
    RefinedProducts = 'refined_products',
    SAndPGsci = 's_and_p_gsci',
    SelSectorIndex = 'sel_sector_index',
    ShortTermGov = 'short_term_gov',
    ShortTermNonGov = 'short_term_non_gov',
    Softs = 'softs',
    Us = 'us',
    UsIndex = 'us_index',
    WetBulk = 'wet_bulk'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesProductsSubSectorEnum {
    Asian = 'asian',
    Canadian = 'canadian',
    Cat = 'cat',
    CoolingDegreeDays = 'cooling_degree_days',
    Ercot = 'ercot',
    European = 'european',
    Gulf = 'gulf',
    HeatingDegreeDays = 'heating_degree_days',
    IsoNe = 'iso_ne',
    LargeCapIndex = 'large_cap_index',
    MidCapIndex = 'mid_cap_index',
    Miso = 'miso',
    NorthAmerican = 'north_american',
    Nyiso = 'nyiso',
    Pjm = 'pjm',
    SmallCapIndex = 'small_cap_index',
    West = 'west',
    WesternPower = 'western_power'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesProductsAssetClassEnum {
    AltInvestment = 'alt_investment',
    Commodity = 'commodity',
    Financials = 'financials'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesProductsAssetSubClassEnum {
    Agricultural = 'agricultural',
    CommodityIndex = 'commodity_index',
    Energy = 'energy',
    Equity = 'equity',
    ForeignExchange = 'foreign_exchange',
    Freight = 'freight',
    Housing = 'housing',
    InterestRate = 'interest_rate',
    Metals = 'metals',
    Weather = 'weather'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesProductsTypeEnum {
    All = 'all',
    Single = 'single',
    Combo = 'combo'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesProductsSortEnum {
    NameAsc = 'name.asc',
    NameDesc = 'name.desc',
    TradingVenueAsc = 'trading_venue.asc',
    TradingVenueDesc = 'trading_venue.desc',
    SectorAsc = 'sector.asc',
    SectorDesc = 'sector.desc',
    SubSectorAsc = 'sub_sector.asc',
    SubSectorDesc = 'sub_sector.desc',
    AssetClassAsc = 'asset_class.asc',
    AssetClassDesc = 'asset_class.desc',
    AssetSubClassAsc = 'asset_sub_class.asc',
    AssetSubClassDesc = 'asset_sub_class.desc',
    TypeAsc = 'type.asc',
    TypeDesc = 'type.desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesQuotesSortEnum {
    TimestampAsc = 'timestamp.asc',
    TimestampDesc = 'timestamp.desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetFuturesTradesSortEnum {
    TimestampAsc = 'timestamp.asc',
    TimestampDesc = 'timestamp.desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesAggregatesTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesAggregatesSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesEMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesEMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesEMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesMACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesMACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesMACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesRSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesRSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesRSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesSMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesSMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesSMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesSnapshotOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetIndicesSnapshotSortEnum {
    Ticker = 'ticker'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsAggregatesTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsAggregatesSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsChainContractTypeEnum {
    Call = 'call',
    Put = 'put'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsChainOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsChainSortEnum {
    Ticker = 'ticker',
    ExpirationDate = 'expiration_date',
    StrikePrice = 'strike_price'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsEMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsEMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsEMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsMACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsMACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsMACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsQuotesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsQuotesSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsRSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsRSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsRSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsSMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsSMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsSMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsTradesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetOptionsTradesSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum GetSnapshotsTypeEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx',
    Indices = 'indices'
}
/**
  * @export
  * @enum {string}
  */
export enum GetSnapshotsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetSnapshotsSortEnum {
    Ticker = 'ticker'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksAggregatesTimespanEnum {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksAggregatesSortEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksEMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksEMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksEMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksMACDTimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksMACDSeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksMACDOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksQuotesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksQuotesSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksRSITimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksRSISeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksRSIOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksSMATimespanEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Quarter = 'quarter',
    Year = 'year'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksSMASeriesTypeEnum {
    Open = 'open',
    High = 'high',
    Low = 'low',
    Close = 'close'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksSMAOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksSnapshotDirectionDirectionEnum {
    Gainers = 'gainers',
    Losers = 'losers'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksTradesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum GetStocksTradesSortEnum {
    Timestamp = 'timestamp'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsDataTypeEnum {
    Trade = 'trade',
    Bbo = 'bbo',
    Nbbo = 'nbbo'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsSipEnum {
    Cta = 'CTA',
    Utp = 'UTP',
    Opra = 'OPRA'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListConditionsSortEnum {
    AssetClass = 'asset_class',
    Id = 'id',
    Type = 'type',
    Name = 'name',
    DataTypes = 'data_types',
    Legacy = 'legacy'
}
/**
  * @export
  * @enum {string}
  */
export enum ListDividendsFrequencyEnum {
    NUMBER_0 = 0,
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_4 = 4,
    NUMBER_12 = 12,
    NUMBER_24 = 24,
    NUMBER_52 = 52
}
/**
  * @export
  * @enum {string}
  */
export enum ListDividendsDividendTypeEnum {
    Cd = 'CD',
    Sc = 'SC',
    Lt = 'LT',
    St = 'ST'
}
/**
  * @export
  * @enum {string}
  */
export enum ListDividendsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListDividendsSortEnum {
    ExDividendDate = 'ex_dividend_date',
    PayDate = 'pay_date',
    DeclarationDate = 'declaration_date',
    RecordDate = 'record_date',
    CashAmount = 'cash_amount',
    Ticker = 'ticker'
}
/**
  * @export
  * @enum {string}
  */
export enum ListExchangesAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx',
    Futures = 'futures'
}
/**
  * @export
  * @enum {string}
  */
export enum ListExchangesLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
  * @export
  * @enum {string}
  */
export enum ListFinancialsTimeframeEnum {
    Annual = 'annual',
    Quarterly = 'quarterly',
    Ttm = 'ttm'
}
/**
  * @export
  * @enum {string}
  */
export enum ListFinancialsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListFinancialsSortEnum {
    FilingDate = 'filing_date',
    PeriodOfReportDate = 'period_of_report_date'
}
/**
  * @export
  * @enum {string}
  */
export enum ListIPOsIpoStatusEnum {
    DirectListingProcess = 'direct_listing_process',
    History = 'history',
    New = 'new',
    Pending = 'pending',
    Postponed = 'postponed',
    Rumor = 'rumor',
    Withdrawn = 'withdrawn'
}
/**
  * @export
  * @enum {string}
  */
export enum ListIPOsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListIPOsSortEnum {
    ListingDate = 'listing_date',
    Ticker = 'ticker',
    LastUpdated = 'last_updated',
    SecurityType = 'security_type',
    IssuerName = 'issuer_name',
    CurrencyCode = 'currency_code',
    Isin = 'isin',
    UsCode = 'us_code',
    FinalIssuePrice = 'final_issue_price',
    MinSharesOffered = 'min_shares_offered',
    MaxSharesOffered = 'max_shares_offered',
    LowestOfferPrice = 'lowest_offer_price',
    HighestOfferPrice = 'highest_offer_price',
    TotalOfferSize = 'total_offer_size',
    SharesOutstanding = 'shares_outstanding',
    PrimaryExchange = 'primary_exchange',
    LotSize = 'lot_size',
    SecurityDescription = 'security_description',
    IpoStatus = 'ipo_status',
    AnnouncedDate = 'announced_date'
}
/**
  * @export
  * @enum {string}
  */
export enum ListNewsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListNewsSortEnum {
    PublishedUtc = 'published_utc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListOptionsContractsContractTypeEnum {
    Call = 'call',
    Put = 'put'
}
/**
  * @export
  * @enum {string}
  */
export enum ListOptionsContractsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListOptionsContractsSortEnum {
    Ticker = 'ticker',
    UnderlyingTicker = 'underlying_ticker',
    ExpirationDate = 'expiration_date',
    StrikePrice = 'strike_price'
}
/**
  * @export
  * @enum {string}
  */
export enum ListStockSplitsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListStockSplitsSortEnum {
    ExecutionDate = 'execution_date',
    Ticker = 'ticker'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickerTypesAssetClassEnum {
    Stocks = 'stocks',
    Options = 'options',
    Crypto = 'crypto',
    Fx = 'fx',
    Indices = 'indices'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickerTypesLocaleEnum {
    Us = 'us',
    Global = 'global'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickersTypeEnum {
    Cs = 'CS',
    Adrc = 'ADRC',
    Adrp = 'ADRP',
    Adrr = 'ADRR',
    Unit = 'UNIT',
    Right = 'RIGHT',
    Pfd = 'PFD',
    Fund = 'FUND',
    Sp = 'SP',
    Warrant = 'WARRANT',
    Index = 'INDEX',
    Etf = 'ETF',
    Etn = 'ETN',
    Os = 'OS',
    Gdr = 'GDR',
    Other = 'OTHER',
    Nyrs = 'NYRS',
    Agen = 'AGEN',
    Eqlk = 'EQLK',
    Bond = 'BOND',
    Adrw = 'ADRW',
    Basket = 'BASKET',
    Lt = 'LT'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickersMarketEnum {
    Stocks = 'stocks',
    Crypto = 'crypto',
    Fx = 'fx',
    Otc = 'otc',
    Indices = 'indices'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickersOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ListTickersSortEnum {
    Ticker = 'ticker',
    Name = 'name',
    Market = 'market',
    Locale = 'locale',
    PrimaryExchange = 'primary_exchange',
    Type = 'type',
    CurrencySymbol = 'currency_symbol',
    CurrencyName = 'currency_name',
    BaseCurrencySymbol = 'base_currency_symbol',
    BaseCurrencyName = 'base_currency_name',
    Cik = 'cik',
    CompositeFigi = 'composite_figi',
    ShareClassFigi = 'share_class_figi',
    LastUpdatedUtc = 'last_updated_utc',
    DelistedUtc = 'delisted_utc'
}


